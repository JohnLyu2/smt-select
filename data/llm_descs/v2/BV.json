[
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_15.smt2",
    "description": "This instance is a satisfiability query over 32‑bit vectors that encodes a mix of linear inequalities and equalities originating from a redundancy‑removal technique for non‑convex polyhedra (as described in the SMT‑08 paper).  The formula contains several nested quantifier alternations (four universal and four existential blocks) with many multiplied‑by‑constant expressions, creating a heavily quantified linear‑arithmetic benchmark.  The combination of deep term nesting (depth 13), a moderate number of bit‑vector operations, and the alternation of ∀/∃ makes the problem challenging for quantifier‑handling solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_13.smt2",
    "description": "The instance encodes a quantified bit‑vector formula that originated from a linear‑constraint redundancy‑removal problem for non‑convex polyhedra (translated to 32‑bit BV arithmetic). It asks whether a large system of linear inequalities—expressed with `bvadd`, `bvmul`, and signed comparisons—holds under a mixture of nested universal and existential quantifiers over the auxiliary variables. The formula features several quantifier alternations, deep term nesting (depth 20), and a high count of arithmetic operations, making the satisfiability check a non‑trivial quantified‑BV verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_16.smt2",
    "description": "This instance encodes a single quantified formula over 32‑bit bit‑vectors that represents a large system of linear (signed) inequalities and equalities. It originates from the Scholl et al. 2008 study on using SMT and Craig interpolation to detect redundant linear constraints in non‑convex polyhedra, later translated to bit‑vector arithmetic. The benchmark stresses solvers with many alternating ∀/∃ quantifiers (35 ∀, 19 ∃), deep term nesting (depth 24) and a heavy mix of addition, multiplication and negation, making it a challenging satisfiability‑checking problem for quantified bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_30.smt2",
    "description": "This instance encodes a single quantified satisfiability query over 32‑bit bit‑vectors.  It contains a mixture of universal and existential quantifiers (several alternations), with four free constants and many bound variables that appear only inside linear‑arithmetic expressions built from constant‑multiplied variables, additions, negations and comparisons.  The formula was generated from the “redundant linear‑constraint detection for non‑convex polyhedra” benchmark (Scholl et al., SMT‑08) and thus tests a solver’s ability to handle deep, heavily nested quantifier blocks, a large number of arithmetic terms (≈ 240 multiplications, 155 additions) and a high term depth (18) in the BV logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_24.smt2",
    "description": "This instance is a quantified 32‑bit bit‑vector satisfiability check that originates from the Scholl‑et‑al. paper on using SMT and Craig interpolation to eliminate redundant linear constraints in non‑convex polyhedra (translated to BV by Mathias Preiner).  It encodes a single massive formula that mixes many ∀/∃ alternations over auxiliary variables with a dense collection of linear equalities and inequalities (multiplications by constant coefficients, additions, and signed comparisons), resulting in a deep term graph (depth 20) and thousands of arithmetic operations.  The solver must determine whether the quantified combination of these linear constraints is satisfiable, a task made difficult by the large number of quantifier alternations, nested let‑bindings, and the heavy use of bvmul/bvadd.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_6.smt2",
    "description": "This benchmark encodes a quantified bit‑vector formula that captures a set of linear (addition‑ and constant‑multiplication) constraints originally used for detecting redundant constraints in non‑convex polyhedra (as described in the SMT‑08 paper). The single top‑level assertion combines many nested ∀/∃ quantifiers, deep arithmetic terms (depth 21) and a large number of constant‑scaled multiplications, making the satisfiability check a hard instance for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_14.smt2",
    "description": "This instance asks whether a quantified bit‑vector formula over four 32‑bit variables is satisfiable.  It encodes a large conjunction of linear‑arithmetic constraints (sums, products, and signed comparisons) with alternating ∀/∃ quantifiers, reflecting the “redundant linear‑constraint detection” problem for non‑convex polyhedra described in the Scholl et al. paper.  The benchmark is challenging because it mixes many quantified variables, deep term nesting (depth ≈ 18) and a high density of multiplication and inequality operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_25.smt2",
    "description": "This instance is a quantified bit‑vector satisfiability problem (BV‑logic) that encodes a large, randomly generated system of linear‑arithmetical constraints over 32‑bit variables. It features a deep nesting of 22 universal and 23 existential quantifiers, with dozens of additive and multiplicative terms (over 700 multiplications) and a maximum term depth of 24, making it a challenging case for solvers that must handle heavy quantifier alternation and large linear inequality systems. The single top‑level assertion checks whether the whole quantified formula is satisfiable.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_23.smt2",
    "description": "This instance encodes a quantified satisfiability problem over 32‑bit signed bit‑vectors. It consists of a single large formula that combines three nested existential quantifiers (introducing three fresh vectors) and one universal quantifier, together with a dense mix of linear equalities and inequalities built from constant multiplications, additions and signed comparisons. The goal is simply to decide whether the whole system of constraints is SAT, and the formula’s high term depth (19), many arithmetic operations (≈ 190 multiplications) and alternating Boolean structure (numerous or/and nests) make it a challenging benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_4.smt2",
    "description": "This benchmark asks a BV‑solver to decide the satisfiability of a heavily quantified 32‑bit formula that originates from a study on detecting redundant linear constraints in non‑convex polyhedral representations. The single assertion consists of multiple alternations of ∀ and ∃ quantifiers over auxiliary variables, each combined with signed linear expressions built from bit‑vector multiplication, addition and inequality tests. The deep nesting (term depth 13) and dense use of linear arithmetic make it a challenging instance for quantified‑BV reasoning rather than a plain quantifier‑free check‑sat problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_2.smt2",
    "description": "This benchmark encodes a quantified bit‑vector satisfiability problem derived from the “redundant linear constraints in non‑convex polyhedra” study (Scholl et al., SMT‑08) and translated to 32‑bit arithmetic. The single assertion combines several alternating ∃/∀ blocks over linear combinations of the quantified variables and a few free constants, using a mixture of equalities and signed (in)equalities with term depth up to 15. The heavy quantifier alternation and dense network of linear constraints make it a challenging instance for BV solvers, especially those handling interpolation or quantifier reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_1.smt2",
    "description": "This instance is a quantified bit‑vector satisfiability problem (BV logic) originating from a benchmark on detecting redundant linear constraints in non‑convex polyhedra. It asks whether a 32‑bit variable x1 can satisfy a disjunction of two large sub‑formulas, each containing alternating existential and universal quantifiers over additional 32‑bit variables and composed exclusively of linear equalities and signed inequalities (multiplications by constant coefficients, additions, and negations). The benchmark tests a solver’s ability to handle several quantifier alternations and a moderate term depth (13) within a randomly generated, yet theoretically motivated, linear‑constraint encoding.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_21.smt2",
    "description": "This instance encodes a single, highly quantified feasibility problem over 32‑bit bit‑vectors. It consists of a massive conjunction of linear arithmetic constraints (constant‑multiplications, additions, and signed comparisons) nested inside dozens of alternating ∃/∀ quantifiers that capture the relationships among seven declared variables (x₁ and y₁…y₆). The goal is simply to decide whether the quantified system—derived from a non‑convex polyhedral representation used in redundancy‑removal research—is satisfiable; the large number of quantifier alternations, deep term nesting (depth 24), and thousands of arithmetic operations make it a difficult SAT/SMT benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_11.smt2",
    "description": "This benchmark encodes a consistency check for a large system of linear (multiplication‑by‑constant) constraints over 32‑bit bit‑vectors, arising from the “redundant linear‑constraint” removal method described in Scholl et al. (SMT‑08). The sole free variable x1 is examined under a tangled nest of 16 existential and 17 universal quantifiers that introduce auxiliary variables y1…y4, with dozens of inequalities (≤, ≥, <, >) and equalities built from deep (depth 18) additive and multiplicative terms. The problem therefore tests a solver’s ability to handle heavily quantified, quantified‑alternation‑rich linear arithmetic in the BV logic, a typical hard case for interpolation‑based redundancy detection.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_26.smt2",
    "description": "This benchmark is a quantified bit‑vector satisfiability query (BV‑logic, 32‑bit vectors) extracted from the paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* and translated to bit‑vectors by Mathias Preiner. It asserts a single, highly intricate formula that mixes existential and universal quantifiers (≈50 alternations), deep nested let‑expressions, and thousands of linear arithmetic terms (bvmul, bvadd, bvneg) to model linear constraints over non‑convex polyhedra. The instance is therefore a random‑looking but deliberately hard SAT check, featuring a large number of variables, a maximum term depth of 26, and a dense combination of inequalities (bvslt, bvsle, bvsgt, bvsge), which makes it challenging for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_22.smt2",
    "description": "This instance (from Scholl et al., “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”, 2008) encodes a large quantified linear‑arithmetic problem as 32‑bit bit‑vector arithmetic. The single assertion contains a dense nest of 26 existential and 22 universal quantifiers over five 32‑bit variables, with hundreds of signed multiplications, additions and comparisons, reaching a maximum term depth of 21. Consequently the benchmark challenges solvers with a highly non‑linear quantified formula that models redundancy checking for polyhedral constraints, rather than a simple random SAT/UNSAT case.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_36.smt2",
    "description": "This benchmark encodes a massive quantified bit‑vector formula (BV‑logic, 32‑bit vectors) that originates from the “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra” paper (Scholl et al., SMT‑08). The single assertion consists of deeply nested ∀/∃ quantifiers over seven constants (x1, y1‑y6) and a dense network of linear‑integer‑style constraints built from bvmul, bvadd, and signed comparisons, aiming to test the solver’s ability to handle redundancy detection/invariant checking for non‑convex polyhedral systems. The instance is unusually large (≈107 KB, term depth 27) with hundreds of arithmetic operations and over three hundred logical connectives, making it a challenging stress test for quantifier handling and arithmetic reasoning in bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_19.smt2",
    "description": "This instance encodes a single, highly quantified formula over 32‑bit signed bit‑vectors that combines dozens of linear arithmetic constraints (constant‑coefficients multiplied by variables, summed and compared with zero or other constants). It originates from the SMT‑08 benchmark suite used in “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”, and has been translated to bit‑vector logic. The problem is challenging because it features alternating existential and universal quantifiers (23 ∃, 19 ∀), deep term nesting (max depth 22), and a large number of arithmetic operations (≈ 300 bvmul and 200 bvadd), making it a hard case for quantifier‑handling and linear arithmetic reasoning in the BV theory.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_23.smt2",
    "description": "This instance encodes a single quantified bit‑vector satisfiability query originating from a study on using SMT and Craig interpolation to prune redundant linear constraints in non‑convex polyhedra (Scholl et al., SMT‑08, translated to BV by Preiner). It contains two universal quantifiers (over y₃ and y₄) with an inner existential quantifier, and a massive conjunction of signed linear inequalities expressed with 32‑bit multiplications, additions, and comparisons (≈ 220 bvmul, depth 17). The formula thus tests whether there exist 32‑bit values satisfying a dense system of linear constraints, making it a challenging random‑style quantified BV problem due to the quantifier alternation, high term depth, and the sheer number of arithmetic operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_28.smt2",
    "description": "**Summary**  \nThis benchmark is a quantified bit‑vector satisfiability problem taken from the 2008 paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* (translated to BV by Mathias Preiner). It encodes a large set of signed linear inequalities over 32‑bit variables (`x1`, `y1…y6`). The single top‑level assertion asks whether there exists an assignment to the free variables that satisfies a deeply nested combination of existential and universal quantifiers, each introducing additional copies of the `y` variables, together with many `bvadd`, `bvmul` and comparison operators (`bvslt`, `bvsle`, `bvsge`, `bvsgt`).  \n\nThe instance therefore tests **quantifier handling and linear arithmetic reasoning** in the BV logic. It is notable for its **high quantifier alternation count (≈30 quantified blocks), large term depth (26), and thousands of arithmetic operations (≈867 multiplications, 706 additions)**, which together make it a difficult case for SMT solvers that must reason about quantified linear constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_14.smt2",
    "description": "This instance asks the BV solver to decide the satisfiability of a single, highly nested quantified formula that combines dozens of linear (addition, multiplication, negation) constraints over 32‑bit bit‑vectors.  The formula originates from a translation of a redundancy‑removal problem for non‑convex polyhedra (as described in the Scholl et al. SMT‑08 paper) and features multiple alternations of ∀ and ∃ quantifiers, deep term nesting (depth ≈ 21) and a large number of linear arithmetic literals, making it a challenging benchmark for quantifier‑handling and interpolation techniques.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_40.smt2",
    "description": "**Summary**  \nThis benchmark is a quantifier‑heavy, bit‑vector encoding of a large system of linear (in)equalities that originated in the paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* (Scholl et al., SMT‑Workshop 2008). The original arithmetic constraints were translated to 32‑bit bit‑vector arithmetic (by Mathias Preiner) and then combined with a dense lattice of `or`/`and` clauses. The sole top‑level assertion asks whether there exist assignments to a handful of 32‑bit variables (`x1`, `y1…y6`) that satisfy a massive conjunction of signed‑comparison (`bvslt`, `bvsle`, `bvsge`, `bvsgt`) and equality constraints, each involving many scaled terms (`bvmul` with constant coefficients).\n\n**Key characteristics**\n- **Problem type:** Satisfiability of a quantified bit‑vector formula (essentially a feasibility check over a large, non‑convex polyhedral region).  \n- **Quantifier structure:** Deep nesting of alternations — up to 16 universal and 17 existential quantifiers, often combined (`∀…∃…∀…`) within the same clause.  \n- **Complexity:** 85 kB file, 1 top‑level assert, 7 declared constants, 1905 `bvmul`, 1538 `bvadd`, 1163 `bvneg`, and dozens of relational operators. The maximum term depth reaches **27**, indicating very deep arithmetic expressions.  \n- **Difficulty factors:** The combination of many quantified variables, high term depth, and a huge number of arithmetic multiplications creates a challenging search space for SMT solvers, especially in the BV logic where overflow semantics must be respected.  \n\nOverall, the instance tests an SMT solver’s ability to handle heavily quantified, large‑scale linear arithmetic over 32‑bit bit‑vectors, reflecting the complexity of redundancy detection in non‑convex polyhedral representations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_30.smt2",
    "description": "This instance is a quantified bit‑vector benchmark derived from the paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* (Preiner 2008). It encodes a set of linear‑inequality constraints over six 32‑bit variables, using a mixture of universal and existential quantifiers (21 ∀ and 24 ∃) that are deeply nested and combined with many linear‑term operations (multiplication, addition, negation) – the hardest part being the alternation of quantifiers and the high term depth (22). As a result, the problem tests an SMT solver’s ability to reason about quantified linear arithmetic in the bit‑vector domain, a typical challenge for verification‑style queries on polyhedral abstractions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_12.smt2",
    "description": "This instance encodes a quantified bit‑vector problem that originates from a benchmark on detecting redundant linear constraints in non‑convex polyhedra (Scholl et al., SMT‑08). It asks whether the free 32‑bit variables \\(x_1, y_1, y_2, y_3\\) can satisfy a single large conjunction of linear inequalities and equalities that involve alternating ∀/∃ quantifiers, signed comparisons, and constant‑coefficient multiplications. The formula is relatively dense (≈5 KB, depth 15), with 12 existential and 8 universal quantifiers, making it a challenging case for solvers that handle quantified bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_13.smt2",
    "description": "**Summary:**  \nThe file is a quantified bit‑vector satisfiability benchmark originating from the Scholl et al. 2008 study on removing redundant linear constraints in non‑convex polyhedra (later translated to BV by Preiner). It asks whether there exist 32‑bit values for three “y” variables such that a sizable conjunction of signed linear inequalities (expressed with `bvadd`, `bvmul`, and comparisons like `bvsle`, `bvsge`, `bvsgt`) holds for **all** choices of a fourth “y” variable, together with additional existential constraints on the same variables and a free variable `x1`. The instance contains a modest quantifier alternation pattern (∃ ∃ (∀ …) ∧ ∃) and a relatively deep term structure (depth 15) with many multiplication and negation operations, making it a challenging case for BV solvers that must handle quantified linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_15.smt2",
    "description": "This benchmark encodes a quantified linear‑arithmetic consistency check over 32‑bit bit‑vectors, taken from the SMT‑08 paper on detecting redundant linear constraints in non‑convex polyhedra (translated to BV by Mathias Preiner). The single asserted formula contains many alternating ∃/∀ quantifiers, deep nesting (term depth 21), and a large number of linear combinations built with `bvadd`, `bvmul` (by constants) and signed comparisons, exercising the solver’s handling of quantified bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_24.smt2",
    "description": "This benchmark encodes a single quantified bit‑vector assertion over four 32‑bit variables (x1, y1, y3, y4). It features a large conjunction of linear‑arithmetic‑like constraints built from constant‑multiplied variables (≈ 355 `bvmul` occurrences), with several alternations of universal and existential quantifiers and a nesting depth of about 20. The instance is intended to stress SMT solvers on quantified BV reasoning, especially handling many quantified multiplication constraints that arise from a translation of a non‑convex polyhedral redundancy‑removal problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_8.smt2",
    "description": "This benchmark encodes a quantified linear‑arithmetic problem over 32‑bit bit‑vectors.  It is taken from the Scholl‑et‑al. 2008 paper on detecting redundant linear constraints in non‑convex polyhedra (translated to BV by Preiner), and consists of several nested ∀/∃ blocks that combine the variables with constant‑coefficient multiplications and signed (in)equalities.  The formula has a moderate size (≈3 KB) but a relatively deep term structure (depth 17) and multiple quantifier alternations, which make it a challenging instance for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_33.smt2",
    "description": "This benchmark is a pure‑BV satisfiability query that encodes a single huge quantified formula. It contains nested `forall` and `exists` over 32‑bit bit‑vectors together with hundreds of linear (multiplicative) inequalities built from `bvmul`, `bvadd`, and relational operators, resulting from a translation of a non‑convex polyhedron redundancy‑removal problem. The instance features deep term nesting (depth 25), many quantifier alternations and a large number of arithmetic terms, making it a challenging random stress test for BV‑solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_1.smt2",
    "description": "This instance is a quantified‑bit‑vector (QBV) satisfiability problem taken from the SMT‑08 paper on using Craig interpolation to eliminate redundant linear constraints in non‑convex polyhedra (translated to 32‑bit BV arithmetic). It asks whether there exists a 32‑bit value x₁ such that a large disjunction of quantified sub‑formulas—each consisting of signed linear inequalities built from multiplications, additions and comparisons—is true; the sub‑formulas contain several alternations of ∃ and ∀ over additional 32‑bit variables. The formula’s heavy use of nested quantifiers, many arithmetic terms (≈ 57 multiplications) and a maximum term depth of 17 makes it a challenging benchmark for QBV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_3.smt2",
    "description": "This instance is a quantified bit‑vector satisfiability problem (BV logic) that encodes a set of linear‑arithmetic constraints originating from a redundancy‑removal technique for non‑convex polyhedra. It features three free 32‑bit variables together with a ∀∃∀ quantifier pattern, heavy use of constant‑multiplication, addition and signed comparisons, and a moderate term depth (12), making it a challenging benchmark for solvers handling quantifier alternations. The goal is simply to decide whether the quantified conjunction of these linear constraints is satisfiable.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_12.smt2",
    "description": "This instance encodes a quantified bit‑vector formula that stems from the SMT‑based redundancy‑removal technique for non‑convex polyhedra described in Scholl et al. (2008). It asks whether a large conjunction of linear (addition, multiplication, and signed inequality) constraints over 32‑bit variables can be satisfied, using many nested ∃/∀ alternations (≈ 17 existentials and 19 universals) and a deep term structure (depth 18). The combination of extensive quantified linear arithmetic, a modest number of free constants, and heavy use of bit‑vector arithmetic makes the benchmark particularly challenging for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_4.smt2",
    "description": "This instance is a satisfiability check in the quantifier‑rich fragment of 32‑bit bit‑vector arithmetic. It encodes a single, highly nested quantified assertion that combines several universal and existential quantifiers over auxiliary variables and a free variable x1, linked by many linear‑looking constraints built from constant multiplications, additions, and signed comparisons. Originating from the Scholl et al. 2008 benchmark on redundant linear constraints in non‑convex polyhedra (translated to BV), the problem tests a solver’s ability to handle alternating quantifiers and a dense mixture of arithmetic relations rather than any specific application domain.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_10.smt2",
    "description": "This benchmark encodes a quantified linear‑arithmetic problem over 32‑bit bit‑vectors, originating from a study on detecting redundant constraints in non‑convex polyhedra. It consists of a single assertion that combines two universal quantifiers (over y₂ and y₃) with existential quantifiers, linking several affine expressions of the free variable x₁ via signed‑less‑than, signed‑greater‑than, equality and disequality checks. The instance features a modest number of variables (three) but a non‑trivial alternation of ∀/∃ quantifiers and nested Boolean structure, yielding a medium‑depth (≈12) term graph that challenges solvers’ quantifier handling and bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_23.smt2",
    "description": "The instance is a quantified BV‑satisfiability problem originating from the SMT‑based redundancy‑removal technique for non‑convex polyhedra (Scholl et al., SMT‑08, later translated to bit‑vectors). It asserts a single, large formula consisting of many nested ∀/∃ quantifiers over five 32‑bit variables, with linear inequalities expressed as constant multiplications, additions and signed comparisons (≈ 400 `bvmul`, 300 `bvadd`, depth 23). The combination of alternating quantifiers, a high number of arithmetic operations, and deep term structure makes the instance a challenging benchmark for quantifier‑handling solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_1.smt2",
    "description": "This benchmark encodes a quantified linear‑arithmetic problem (originally a non‑convex polyhedron redundancy check) in 32‑bit bit‑vector arithmetic. The single assertion is a large Boolean combination of nested ∃/∀ quantifiers over seven bit‑vector variables, expressing dozens of linear (in)equalities, equalities, and disequalities built from many `bvadd`, `bvmul` and `bvneg` operations (term depth ≈ 18). The heavy quantifier alternation and deep arithmetic terms make it a demanding satisfiability test for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_20.smt2",
    "description": "This benchmark is a quantified bit‑vector satisfiability instance derived from the paper “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”, translated to 32‑bit BV by Mathias Preiner. It asks whether there exist assignments to five 32‑bit variables that satisfy a large conjunction of linear equalities and inequalities (expressed with bvmul, bvadd, and signed comparisons) under three alternating quantifier blocks (∀∃∀ and ∀∃). The formula contains about 120 constant‑multiplication terms, a maximum term depth of 18, and many nested Boolean connectives, making quantifier handling and linear arithmetic reasoning the main sources of difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_8.smt2",
    "description": "This benchmark is a quantified Bit‑Vector satisfiability check originating from the “redundant linear constraints in non‑convex polyhedra” study. It asks whether the four 32‑bit constants (three free and one shared) can satisfy a pair of nested ∀∃ formulas composed of linear‑looking bit‑vector multiplications by constants together with signed inequalities and an equality. The instance is a random‑looking, moderate‑size (≈1.7 KB) BV problem with two quantifier alternations, several nested Boolean combinations, and a term depth of 12, making it a typical stress test for solvers’ handling of quantified arithmetic over bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_29.smt2",
    "description": "This benchmark encodes a highly quantified, randomly generated 32‑bit bit‑vector formula that originates from the Scholl et al. “Detecting Redundant Linear Constraints in Non‑Convex Polyhedra” paper (SMT‑08) and was translated to BV by Preiner. The single assertion consists of a dense alternation of ∀/∃ quantifiers over many auxiliary variables, each guarded by numerous linear (addition, multiplication, negation) inequalities and equalities such as “bvsge”, “bvsle”, “bvsgt”, etc., forming a large conjunctive‑disjunctive structure. With 7 declared constants, 13 universal and 15 existential blocks, a maximum term depth of 24, and over 600 multiplication terms, the instance challenges solvers on quantified reasoning, deep arithmetic nesting, and bit‑vector linear constraint handling.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_28.smt2",
    "description": "This instance checks the satisfiability of a large, highly quantified bit‑vector formula that arose from the “redundant linear constraints in non‑convex polyhedra’’ benchmark (translated to BV by Mathias Preiner). It contains only four free 32‑bit variables but features 27 existential and 17 universal quantifiers, deep nesting (term depth 17) and hundreds of linear‑arithmetic atoms (mul, add, neg, signed comparisons), forming a massive conjunction of disjunctions. The problem therefore tests the solver’s ability to handle extensive quantifier alternations and deep term structures rather than any specific application logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_20.smt2",
    "description": "This benchmark asks whether a quantified system of linear bit‑vector constraints is satisfiable.  It consists of a three‑alternation quantified formula (∀y₂ ∃y₃ …, ∀y₃ …, ∃y₃ …) over 32‑bit vectors, where each clause is a linear inequality or equality built from additions, constant multiplications and negations.  The instance, derived from a study on redundant constraints in non‑convex polyhedra and then translated to bit‑vectors, tests a solver’s ability to handle deep term nesting (depth 14) and alternating quantifiers in the BV‑logic domain.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_27.smt2",
    "description": "This benchmark encodes a single quantified satisfiability query over 32‑bit bit‑vectors that originates from the “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra” paper (translated to BV by Mathias Preiner). It consists of a massive conjunction of linear‑arithmetic‑like constraints (multiplications by constants, additions, signed comparisons) wrapped in several nested quantifier blocks (∀ ∃ ∀…, with a total of six quantifiers) and uses deep term nesting (depth ≈ 20) with hundreds of arithmetic operations. The instance is intended to stress‑test solvers on quantified BV reasoning, featuring many alternations, a large number of variables (four free constants) and a high density of logical connectives.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_29.smt2",
    "description": "The file encodes a single quantified satisfiability query over 32‑bit bit‑vectors.  It asks whether there exists a valuation of the free variable x1 such that a complex conjunction of linear (constant‑multiplied) inequalities and equalities holds for all possible values of y2 and y3, with additional existentially‑quantified witnesses for y3 inside the formula.  The benchmark comes from the “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra” paper (pre‑processed to BV by Preiner), and its difficulty stems from the nested ∀∃ quantifier alternations and the large number of constant‑multiplied arithmetic terms (depth 17, > 150 arithmetic operators).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_7.smt2",
    "description": "This instance is a quantified bit‑vector satisfiability check in the BV logic. It asks whether there exists a 32‑bit value (and consequently some auxiliary existential variables) that satisfies a conjunction of linear‑arithmetic‑style constraints (inequalities, equalities, and signed comparisons) while simultaneously holding for all values of two other universally quantified 32‑bit variables. The formula contains three quantifier alternations (∃ … ∀ … ∀ …) with many nested multiplications and additions, giving a moderate term depth (13) and a non‑linear character that makes it a challenging benchmark for solvers handling quantified BV problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_9.smt2",
    "description": "This instance is a quantified bit‑vector satisfiability check that encodes a large system of linear inequalities over 32‑bit variables (the declared constants y1…y5 and x1).  It contains alternating blocks of existential and universal quantifiers (≈ 16 ∃ and 11 ∀), deep nested arithmetic expressions built from linear combinations (bvmul with constant coefficients, bvadd, bvneg) and several relational predicates (≤, <, ≥, =), yielding a term‑depth of 21.  The benchmark originates from a study on detecting redundant linear constraints in non‑convex polyhedra, so the solver must decide whether the quantified constraints are simultaneously satisfiable, a task that is challenging due to the high quantifier alternation and dense linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_9.smt2",
    "description": "This instance is a quantified bit‑vector satisfiability check that encodes a set of linear constraints (multiplications by constant bit‑vectors and signed inequalities/equalities) formerly used to model non‑convex polyhedra in a redundancy‑removal study. The solver must decide whether there exist values for four 32‑bit variables that satisfy a single large conjunction of nested ∃/∀ formulas, each involving several linear combinations of the variables. Although the formula is relatively small in size, its difficulty stems from multiple quantifier alternations and a term depth of 13, making it a non‑trivial quantified BV problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_18.smt2",
    "description": "This benchmark asks whether a quantified 32‑bit bit‑vector formula, built from many linear equalities and signed inequalities with constant coefficients, is satisfiable. It consists of an outer disjunction of two ∀‑∃ blocks, each containing dozens of algebraic constraints (additions, multiplications by constants, and signed comparisons) over three declared variables. The difficulty comes from the quantifier alternation and the dense, deeply‑nested linear arithmetic structure, a translation of a redundancy‑removal problem for non‑convex polyhedra.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_27.smt2",
    "description": "**Summary** – This benchmark encodes the redundancy‑removal problem for a non‑convex polyhedron (as described in Scholl et al., SMT‑08) after translation to 32‑bit bit‑vector arithmetic.  It consists of a single, large quantified formula that alternates ∀ and ∃ over many fresh 32‑bit variables and contains a dense network of linear inequalities expressed with `bvmul`, `bvadd`, and signed comparisons (`bvsge`, `bvsle`, `bvsgt`, `bvslt`).  The instance is therefore a highly quantified, deep‑term BV‑logic query (22‑level term depth, > 500 multiplications) that tests an SMT solver’s ability to handle quantifier reasoning and large numbers of linear constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_2.smt2",
    "description": "This benchmark encodes a quantified bit‑vector linear‑arithmetic formula (32‑bit vectors) originating from the SMT‑08 paper on using Craig interpolation to prune redundant linear constraints in non‑convex polyhedra. The single assertion consists of a dense mix of existential and universal quantifiers (≈ 21 ∃, 25 ∀) over linear expressions built with constant‑multiplication, addition and comparisons (≤, <, ≥, >), yielding a deep term structure (depth 18) and a high count of arithmetic operators. The task is simply to decide satisfiability, making it a challenging quantified‑BV instance that exercises quantifier handling and linear‑arithmetic reasoning in SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_36.smt2",
    "description": "This instance encodes a quantified bit‑vector satisfiability problem originating from the “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra” benchmark (translated to BV by Mathias Preiner). It asserts a single formula with an alternation of four quantifiers (∀ ?x1 ∃ ?x2 ∀ ?x3 ∃ ?x4) over four 32‑bit variables, and contains a huge conjunctive‑disjunctive network of linear arithmetic constraints built from many constant‑scaled multiplications, additions and signed comparisons. The formula is dense (≈250 bvmul, 190 bvadd) and reaches a term depth of 20, so the main difficulty lies in coping with the deep, highly tangled quantifier structure and the large number of linear bit‑vector constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_59.smt2",
    "description": "The benchmark encodes a quantified bit‑vector formula that originates from the paper “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”.  It contains a single ∃x₁ ∀x₂ ∃x₃ prefix over 32‑bit vectors, followed by a massive Boolean combination of linear equalities and inequalities built from constant‑multiplication (bvmul) and addition (bvadd) terms; the overall term depth reaches 21 and the formula includes hundreds of such multiplications.  The task is to decide satisfiability of this deep, alternated‑quantifier, linear‑arithmetic‑style BV instance, which is used to stress‑test solvers’ handling of quantifiers, interpolation and large numbers of linear constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_58.smt2",
    "description": "This benchmark is a quantified bit‑vector formula (BV, 32‑bit) originating from the 2008 SMT‑08 workshop on detecting redundant linear constraints. It encodes a dense system of linear equalities and signed inequalities over three variables with an ∃‑∀‑∃ quantifier alternation, using many constant‑scaled multiplications, additions and negations (≈ 180 bvmul occurrences, depth 18). The combination of deep arithmetic terms, multiple quantifier alternations, and a large Boolean structure makes the instance a tough test for BV‑solvers and interpolation engines.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_46.smt2",
    "description": "This benchmark checks the satisfiability of a quantified bit‑vector formula (∃ x₁ ∀ x₂ ∃ x₃) built from a large conjunction of linear‑arithmetic‑like constraints expressed with 32‑bit multiplications, additions, and signed comparisons. It originates from the “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra” paper (Scholl et al., SMT‑08) and was later translated to BV by Mathias Preiner. The instance features three quantified variables, three quantifier alternations, deep nesting (term depth 18), and over a hundred bit‑vector multiplications, making it a non‑linear, quantifier‑heavy challenge for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_31.smt2",
    "description": "This instance encodes a quantified bit‑vector formula that alternates two ∀‑∃ blocks ( ∀ x₁ ∃ x₂ ∀ x₃ ∃ x₄ ) over 32‑bit variables and asserts a large conjunction of linear inequalities built from constant‑multiplied terms and additions. It originates from a study on removing redundant linear constraints in non‑convex polyhedra, translated into the BV logic, and the solver must decide whether the quantified system of arithmetic constraints is satisfiable. The problem is challenging because of many quantified alternations, a deep term nesting (depth ≈ 20), and a high density of multiplications, additions and comparisons (≈ 200 bvmul, 158 bvadd).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_54.smt2",
    "description": "This benchmark encodes a quantified bit‑vector feasibility problem: it asserts an ∃ x₁ ∀ x₂ ∃ x₃ formula consisting of a large Boolean combination of linear inequalities (built from constant multiplications and additions) over 32‑bit vectors.  It stems from the “redundant linear‑constraint removal” study on non‑convex polyhedra, translated to BV, and features three quantified variables, three quantifier alternations, over 400 bvmul/bvadd operations and a term‑depth of 21, making it a demanding SAT/UNSAT check for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_12.smt2",
    "description": "The instance is a quantified bit‑vector satisfiability problem (BV logic) arising from the “redundant linear constraints in non‑convex polyhedra” benchmark suite (Scholl et al., SMT‑08, translated by Preiner). It contains a single large quantified formula with an ∃ ∀ ∃ alternation over three 32‑bit variables and a conjunction of many signed linear inequalities, equalities and disequalities built from constant‑coefficient multiplications, additions and negations. The formula encodes the search for a witness that satisfies a dense set of linear polyhedral constraints, making it a challenging case for solvers due to the quantifier alternation, the depth of nested arithmetic expressions (depth 16), and the high number of linear term occurrences (≈ 120).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_66.smt2",
    "description": "This benchmark is a quantified bit‑vector (BV) satisfiability check generated from the “redundant linear‑constraint detection” problem for non‑convex polyhedra described by Scholl et al. (SMT‑08) and translated to BV by Mathias Preiner. It consists of a single ∀x₁ ∃x₂ ∀x₃ ∃x₄ assertion that mixes thousands of bvadd, bvmul, and signed comparison atoms, with a maximum term depth of 30 and deep nesting of alternating quantifiers, making the instance a hard decision problem for BV solvers. The file belongs to the Preiner‑Scholl‑2008 random benchmark family (size ≈ 132 KB, 4 32‑bit variables, 2 quantifier alternations).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_5.smt2",
    "description": "This is a quantified bit‑vector satisfiability problem (BV logic) that encodes a set of linear constraints over three 32‑bit variables. The formula contains an **∃‑∀‑∃** quantifier pattern with several nested conjunctions, disjunctions and negations, and it heavily uses constant‑multiplication (≈30 bvmul occurrences) and addition, giving a maximum term depth of 15. It originates from the “redundant linear constraints in non‑convex polyhedra” benchmark (Preiner‑Scholl 2008) and tests a solver’s ability to handle quantified linear arithmetic over bit‑vectors rather than sheer variable count.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_35.smt2",
    "description": "This benchmark checks the satisfiability of a quantified bit‑vector formula that models a large set of linear (affine) inequalities, equalities and disequalities over four 32‑bit variables. It uses an alternating ∀∃∀∃ quantifier pattern (two alternations) together with hundreds of constant multiplications and additions, producing deep term nesting (depth ≈ 20). The instance originates from the “redundant linear constraint” study (Scholl et al.) and serves to stress‑test BV solvers on a complex quantified linear‑arithmetic problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_37.smt2",
    "description": "This benchmark encodes a quantified linear‑arithmetic problem (signed 32‑bit bit‑vectors) in the BV logic: a single formula with a ∀x₁ ∃x₂ ∀x₃ ∃x₄ prefix that checks a large conjunction of constant‑multiplied additions against signed inequalities ( <bvslt>, <bvsle>, <bvsge>, <bvsgt> ). It stems from Scholl et al.’s 2008 work on using SMT and Craig interpolation to prune redundant constraints in non‑convex polyhedra, and was translated to bit‑vectors by Mathias Preiner. The instance features a moderate number of variables (four) but a deep term structure (max depth 19), many arithmetic operations (≈ 87 bvmul, 62 bvadd) and two quantifier alternations, making quantifier‑instantiation and interpolation particularly challenging.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_43.smt2",
    "description": "This benchmark is a quantified bit‑vector satisfiability problem extracted from the paper “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”. It asks whether there exists a 32‑bit value for x₁ such that for every 32‑bit x₂ there is a 32‑bit x₃ making a large Boolean combination of linear (multiplication by constant) inequalities and equalities hold. The formula features a three‑alternation quantifier prefix (∃ x₁ ∀ x₂ ∃ x₃), about 80 multiplications, 24 disjunctions and a maximum term depth of 16, making it a challenging instance for BV‑theories solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_57.smt2",
    "description": "This benchmark is a quantified bit‑vector formula (logic BV) that encodes a system of linear integer constraints derived from redundant‑constraint detection in non‑convex polyhedra. It consists of a single massive assertion with a quantifier prefix **∀ x₁ ∃ x₂ ∀ x₃ ∃ x₄** followed by a conjunction of dozens of linear equalities and (in)equalities built from constant‑multiplications, additions and signed comparisons on 32‑bit vectors. The instance is deliberately challenging: it contains 424 bvmul, 381 bvadd, 280 bvneg operations, a nesting depth of 22, and a mixture of ∀/∃ alternations, making it a hard case for solvers that must reason about quantified linear arithmetic over bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_54.smt2",
    "description": "This instance is a quantified bit‑vector formula originating from Scholl et al.’s 2008 work on detecting redundant linear constraints in non‑convex polyhedra (translated to BV by Preiner). It encodes a ∀ x₁ ∃ x₂ ∀ x₃ ∃ x₄ pattern where a massive Boolean combination of signed ≤, <, ≥, > comparisons is built from linear expressions formed by many scalar bvmul and bvadd terms over 32‑bit vectors. The single assertion contains four quantifier alternations, ~700 additions, ~585 multiplications, depth 23 and a large disjunction/conjunction structure, making it a challenging benchmark for solvers’ quantifier‑handling and linear arithmetic capabilities.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_53.smt2",
    "description": "The instance checks the satisfiability of a quantified bit‑vector formula that originated from a redundancy‑removal benchmark for non‑convex polyhedra, translated into 32‑bit signed linear arithmetic. It contains three 32‑bit variables with a quantifier prefix **∃ x₁ ∀ x₂ ∃ x₃** and a single massive assertion that is a nested combination of dozens of constant‑scaled multiplications, additions and signed comparisons (≺, ≤, ≥, =), forming a large disjunction of conjunctions. With 226 `bvmul` occurrences, term depth 19 and multiple quantifier alternations, the problem is a random‑looking but highly non‑trivial SAT check for quantified BV constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_26.smt2",
    "description": "This instance encodes a quantified 32‑bit bit‑vector linear arithmetic problem derived from redundancy detection in non‑convex polyhedral representations.  It asks whether there exist values for a first variable such that, for all choices of a second variable, there is a third variable making a large conjunction of linear equalities and (signed) inequalities—each built from constant‑scaled multiplications and additions—true.  The formula features a single ∃ ∀ ∃ quantifier prefix, moderate term depth (16) and a dense use of bvmul/bvadd, making it a challenging SAT check for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_27.smt2",
    "description": "The instance is a quantified bit‑vector formula (logic BV) translated from a linear‑constraint problem on non‑convex polyhedra. It contains four 32‑bit variables and a single assertion of the form  \n\n ∀ x₁ ∃ x₂ ∀ x₃ ∃ x₄ · (large conjunction of signed linear inequalities),\n\nwhere each inequality is built from constant multiplications, additions and signed comparisons. The benchmark therefore tests a solver’s ability to handle alternating quantifiers over many linear‑arithmetic‑like bit‑vector terms (53 multiplications, depth 17), a typical hard case for quantifier‑instantiation and interpolation‑based techniques.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_60.smt2",
    "description": "This instance is a quantified bit‑vector satisfiability problem extracted from the work *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* (Scholl et al., SMT‑08) and translated to 32‑bit BV by Preiner. It asks whether there exists a 32‑bit value x₁ such that for every 32‑bit x₂ there is a 32‑bit x₃ satisfying a large conjunction of signed linear inequalities of the form c·x_i + c·x_j + … ≷ c, where the coefficients are constant bit‑vectors. The formula features three quantified variables (∃x₁ ∀x₂ ∃x₃), over 600 additions, 500 multiplications, and more than 200 comparators, with a maximal term depth of 22, making it a demanding case for solvers that handle quantifier alternation and heavy linear arithmetic on bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_2.smt2",
    "description": "This benchmark checks the satisfiability of a quantified bit‑vector formula (∃ x₁ ∀ x₂ ∃ x₃) that encodes a collection of linear equalities and inequalities over 32‑bit integers, originally taken from a study on redundant constraints in non‑convex polyhedra and translated to BV by Mathias Preiner. The single assertion combines about sixty signed comparisons (≤, ≥, <, >) and equalities built from constant‑multiplication, addition and negation, with a maximum term depth of 14 and only three variables, but the alternating quantifier pattern makes the instance non‑trivial for SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_52.smt2",
    "description": "The file encodes a single quantified BV‑satisfiability query of the form ∃ x₁ ∀ x₂ ∃ x₃ ⋯ with a massive conjunction of linear (affine) inequalities built from constant multiplications, additions and comparisons on three 32‑bit bit‑vectors. It originates from the “detecting redundant linear constraints in non‑convex polyhedra’’ benchmark (Scholl et al., SMT‑08) and therefore tests a solver’s ability to handle deep, quantified arithmetic (alternating ∃/∀) and a large number of arithmetic literals (hundreds of bvadd, bvmul, and relational atoms). The instance is deliberately difficult because of the high term depth (22), extensive use of quantified bit‑vector arithmetic, and the dense web of constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_44.smt2",
    "description": "This instance encodes a quantified bit‑vector satisfiability problem derived from the “redundant linear constraints in non‑convex polyhedra” paper (translated to 32‑bit BV by Preiner). It contains a single‑level ∃ x₁ ∀ x₂ ∃ x₃ prefix over three 32‑bit variables, and a massive conjunction of linear‑style constraints built from dozens of multiplications, additions and signed comparisons (≈200 bvmul, 135 bvadd, depth 19). The formula’s heavy use of alternated quantifiers, deep arithmetic terms, and a large number of Boolean combinations makes it a difficult benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_16.smt2",
    "description": "This instance is a quantified satisfiability check over 32‑bit bit‑vectors, originating from a study on eliminating redundant linear constraints in non‑convex polyhedra (Scholl et al., SMT‑08) and translated to the BV logic by Mathias Preiner. It asserts a single, deeply nested formula with a ∀ x₁ ∃ x₂ ∀ x₃ ∃ x₄ prefix, where the body is a large Boolean combination of linear equalities and signed inequalities built from constant‑multiplied variables (bvmul) and additions. The problem features many alternating quantifiers, a high term depth (≈18), and a dense mix of arithmetic constraints, making it a challenging benchmark for solvers that handle quantified bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_53.smt2",
    "description": "This instance encodes a quantified linear‑arithmetic problem over four 32‑bit variables (x₁…x₄) using only bit‑vector addition, multiplication by constants, and signed comparisons. It contains a single quantified formula with the pattern ∀x₁ ∃x₂ ∀x₃ ∃x₄ … followed by a large conjunction/disjunction of linear inequality and equality constraints (≈ 300 multiplications and 250 additions), producing a deep term structure (depth 21). The goal is simply to decide SAT/UNSAT of this quantified BV formula, which originates from a translation of a redundant‑constraint‑detection task for non‑convex polyhedra (Scholl et al., SMT‑08). The challenge lies in the alternating quantifiers and the massive number of linear constraints rather than the number of variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_62.smt2",
    "description": "This instance is a quantified bit‑vector satisfiability check originating from the “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra” paper (Scholl et al., 2008), translated to BV by Mathias Preiner. It asks whether there exist 32‑bit vectors x₂ and x₄ such that for every 32‑bit vector x₁ and for every 32‑bit vector x₃ a massive conjunction of linear (and some non‑linear) inequalities—mostly of the form bvslt, bvsle, bvsgt, bvsge on sums of many constant‑scaled multiplications (bvmul, bvneg, bvadd)—holds. The formula features a four‑alternation quantifier prefix (∀∃∀∃), 4 declared variables, a deep term nesting (depth 29), and thousands of arithmetic literals, making it a highly challenging SAT/UNSAT instance for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_29.smt2",
    "description": "This instance encodes a quantified bit‑vector problem originating from the SMT‑08 paper on using Craig interpolation to prune redundant linear constraints in non‑convex polyhedra. It asks whether there exist 32‑bit values ?x₁ and ?x₃ such that for all 32‑bit values ?x₂ a large conjunction of linear inequalities (built from constant‑multiplications, additions and signed comparisons) holds; the formula contains an ∃ ∀ ∃ quantifier prefix, about 5400 characters, 96 multiplications and a term depth of 16. The heavy use of quantified arithmetic, many disjunctions, and deep nesting make it a challenging benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_33.smt2",
    "description": "The instance encodes a quantified linear‑arithmetic property over three 32‑bit signed bit‑vectors, originating from the Scholl et al. SMT‑08 paper on redundant constraints in non‑convex polyhedra (translated to BV by Preiner). It asks whether a formula with an ∃∀∃ alternation—mixing many signed multiplications, additions, and inequality comparisons—holds, essentially a satisfiability check of a quantified linear‑integer (bit‑vector) system. The problem features a relatively deep term structure (depth 16) and a high density of arithmetic operations (≈50 multiplications), making it a challenging benchmark for quantified‑BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_20.smt2",
    "description": "This instance encodes a quantified bit‑vector satisfiability problem derived from the paper “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”. It asks whether there exist 32‑bit vectors x₁ and x₃ such that, for all 32‑bit vectors x₂, a large Boolean combination of linear (multiplication by constants, addition) signed inequalities and equalities holds; the formula originates from a redundancy‑removal test for non‑convex polyhedral representations. The benchmark features three quantified variables (∃ x₁ ∀ x₂ ∃ x₃), many nested arithmetic literals (≈30 multiplications, 18 adds), a term depth of 14, and a mix of conjunctions, disjunctions, and negations, making it a moderately sized, quantifier‑alternation‑heavy BV problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_55.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector quantified formula (∃/∀ alternating: ∀ x₁ ∃ x₂ ∀ x₃ ∃ x₄) taken from the Preiner‑Scholl 2008 paper on using SMT solving and Craig interpolation to prune redundant linear constraints in non‑convex polyhedra. It encodes a huge conjunction of linear (in)equalities built from constant‑scaled multiplications and additions of the four variables, resulting in over 600 bvmul and 900 bvadd terms with a maximum term depth of 24. The instance is challenging for solvers because of the deep quantifier alternation, the massive number of arithmetic sub‑terms, and the dense combination of signed comparison operators.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_6.smt2",
    "description": "The instance encodes a quantified linear‑arithmetic problem over 32‑bit signed bit‑vectors: an ∃ x₁ ∀ x₂ ∃ x₃ formula built from a mixture of constant‑scaled multiplications, additions, and signed comparisons (≥, ≤, <, >) together with several equality disequalities. It originates from a study on redundant linear constraints in non‑convex polyhedra that was translated to BV, and the solver must decide the satisfiability of this ∃∀∃ “polyhedral” constraint system. The difficulty stems from the alternating quantifiers, a relatively deep term nesting (depth 14), and a large number of arithmetic terms (≈35 multiplications), making it a challenging benchmark for quantified BV reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_68.smt2",
    "description": "This is a quantified bit‑vector problem that checks the truth of a single, huge conjunction of signed linear constraints over four 32‑bit variables x₁…x₄. The formula has an alternating quantifier prefix **∀ x₁ ∃ x₂ ∀ x₃ ∃ x₄**, and each constraint is a simple linear inequality built from bvadd, bvmul (by many constant coefficients), and signed comparisons (≤, <, ≥, >). The instance comes from a translation of a non‑convex polyhedron redundancy‑removal benchmark (Scholl et al., 2008) and is sizable (≈37 KB, depth 23) with a dense web of arithmetic terms, making it a challenging verification‑type task for SMT solvers that must handle quantifier alternation together with large numbers of linear bit‑vector constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_56.smt2",
    "description": "This is a quantified bit‑vector satisfiability problem (BV‑logic) taken from the Scholl et al. “Detecting Redundant Linear Constraints” benchmark and translated to bit‑vectors by Preiner. It asks whether there exist 32‑bit values x₁ and x₃ such that for all 32‑bit x₂ a huge conjunction of linear inequalities (built from many constant‑scaled products bvmul and additions bvadd) holds; the formula features an ∃ ∀ ∃ quantifier pattern, three variables, over 600 bvadd, 500 bvmul, and deep nesting (max term depth 22). The instance is designed to stress solvers with a large number of linear constraints and a non‑trivial quantifier alternation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_10.smt2",
    "description": "This instance encodes a quantified bit‑vector formula (∃ x₁ ∀ x₂ ∃ x₃) that combines linear‑arithmetic‑style constraints—additions, multiplications by constants, and signed comparisons—over three 32‑bit variables. It originates from a benchmark on detecting redundant linear constraints in non‑convex polyhedral representations (the “RNDPRE” family) and is presented as a single large conjunctive assertion with a nesting depth of 13 and several alternating quantifiers, making it a challenging SMT‑BV decision problem. The goal is to determine the overall satisfiability of this quantified conjunction.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_4.smt2",
    "description": "This instance is a quantified bit‑vector formula originating from the “redundant linear constraints in non‑convex polyhedra” benchmark (Scholl et al., SMT‑08), translated to BV by Preiner. It asks whether there exists a 32‑bit value ?x₁ such that for every 32‑bit ?x₂ there is a 32‑bit ?x₃ satisfying a large conjunction of linear BV inequalities (signed <, ≤, >, ≥) and disequalities, i.e. an ∃∀∃ quantifier alternation over a dense lattice of linear constraints. The problem features a moderate term depth (13) but a high count of multiplication and addition terms (≈25 bvmul, 15 bvadd), making it a non‑trivial quantified linear arithmetic challenge for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_9.smt2",
    "description": "This benchmark is a quantified bit‑vector satisfiability problem originating from the SMT‑08 paper on detecting redundant linear constraints in non‑convex polyhedra (translated to BV by Mathias Preiner). It asserts a single formula with a three‑alternation quantifier prefix **∃x₁ ∀x₂ ∃x₃** over 32‑bit vectors, consisting of a large disjunction of conjunctions of linear equalities and inequalities built from constant multiplications, additions and signed comparisons. The instance tests a solver’s ability to handle alternating quantifiers and relatively deep arithmetic terms (max depth 13) on a modest number of variables (three) and many constant‑coefficient operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_52.smt2",
    "description": "This instance comes from the Scholl et al. 2008 paper on using SMT solving and Craig interpolation to remove redundant linear constraints in non‑convex polyhedra; it was later translated to 32‑bit bit‑vectors by Mathias Preiner. The formula encodes a quantified linear‑arithmetic problem of the form  \n\n ∀ x₁ ∃ x₂ ∀ x₃ ∃ x₄ ⋀ C(x₁,x₂,x₃,x₄),\n\nwhere each conjunct C is a signed inequality ( bvslt / bvsle / bvsge / bvsgt ) built from many constant‑scaled multiplications (bvmul) and additions (bvadd). The main challenge is the huge number of such linear terms (≈660 bvmul and 957 bvadd), deep nesting (max term depth 24), and the double alternation of quantifiers, making it a hard quantified‑BV satisfiability check rather than a simple propositional or uninterpreted‑function problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_39.smt2",
    "description": "This benchmark encodes a quantified bit‑vector problem (∃ x₁ ∀ x₂ ∃ x₃) over 32‑bit integers where the three variables appear in a dense network of linear‑affine constraints built from constant multiplications, additions, and signed comparisons (≥, ≤, <, >). It originates from a study on eliminating redundant linear constraints in non‑convex polyhedra (translated to BV), resulting in a highly non‑trivial formula with deep terms (depth 18), many arithmetic operators (≈ 176 multiplications) and a single quantifier alternation, which makes it a difficult case for SMT solvers handling quantified bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_37.smt2",
    "description": "The file encodes a quantified bit‑vector satisfiability problem originating from the “redundant linear constraints in non‑convex polyhedra” benchmark (Scholl et al., SMT‑08). It contains three 32‑bit variables and a ∃ ∀ ∃ quantifier prefix that ties together a large conjunction of affine inequalities (bvmul, bvadd, comparisons) with constants, resulting in a moderately deep term structure (depth 17) and a dense arithmetic constraint network. The solver must decide whether an outer existential assignment exists such that, for every choice of the universal variable, a suitable inner existential value makes all the linear constraints hold.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_38.smt2",
    "description": "This instance is a quantified bit‑vector satisfiability problem that encodes a set of linear integer constraints (multiplications by constant coefficients, additions, and signed comparisons) originating from a paper on redundant linear constraints in non‑convex polyhedra. It features two quantifier alternations (∀x₁ ∃x₂ ∀x₃ ∃x₄) over four 32‑bit variables together with a dense conjunction of linear inequalities and equalities, giving a term depth of 16 and a high density of constant‑multiplication operations. The goal is simply to decide whether the quantified formula is satisfiable, a task that is challenging for BV solvers because of the nested quantifiers and the large number of arithmetic terms.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_41.smt2",
    "description": "This benchmark encodes a quantified bit‑vector problem that originates from the “redundant linear constraints in non‑convex polyhedra” case study (Scholl et al., SMT‑08), translated from integer linear arithmetic to 32‑bit signed BV arithmetic. It asks whether a formula of the form ∀ x₁ ∃ x₂ ∀ x₃ ∃ x₄ holds, where the body consists of a large conjunction/disjunction of signed linear (affine) inequalities built from many constant‑scaled products (≈ 325 bvmul and 284 bvadd) and comparisons (≈ 200 total). The instance features two quantifier alternations, deep terms (depth ≈ 21) and a dense mix of arithmetic constraints, making it a challenging case for quantifier‑handling and interpolation techniques in BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_12.smt2",
    "description": "This instance encodes a quantified bit‑vector verification problem derived from the “redundant linear constraints in non‑convex polyhedra” benchmark (Scholl et al., SMT‑08, translated to BV by Preiner). It asserts a nested ∀∃∀∃ property over four 32‑bit variables, consisting of a large conjunction of linear arithmetic constraints (multiplication by constants, additions, and signed (in)equalities) combined with several disjunctions and negations. The formula features a relatively deep term structure (depth 18) and a dense mix of arithmetic operators (≈ 80 multiplications, 60 adds), making the quantifier‑alternation and the sheer number of linear constraints the principal sources of difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_50.smt2",
    "description": "This instance is a quantified bit‑vector satisfiability problem (BV logic) taken from the 2008 SMT‑08 paper on detecting redundant linear constraints in non‑convex polyhedra. It contains a three‑alternation quantifier prefix ∃ ?x₁ ∀ ?x₂ ∃ ?x₃ over three 32‑bit variables, and the matrix is a large disjunction of conjunctions of linear (multiply‑by‑constant) inequalities and equalities (bvslt, bvsle, bvsge, bvsgt, =). The difficulty stems from the high number of arithmetic terms (≈200 multiplications, 140 negations), a maximum term depth of 19, and the presence of quantifier alternation, which together make the formula a tough test for solvers handling quantified linear arithmetic over bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_55.smt2",
    "description": "This instance is a single quantified bit‑vector formula in the BV logic that uses three 32‑bit variables (x1, x2, x3) under an **∃ ?x1 ∀ ?x2 ∃ ?x3** quantifier pattern. It consists of a massive conjunction of linear arithmetic constraints built from constant multiplications, additions, and signed comparisons (≈ 500 bvadd, 473 bvmul, 400 bvneg, and many relational atoms), giving a term depth of 23 and a highly tangled Boolean structure. The problem therefore tests a solver’s ability to handle deep, highly quantified BV arithmetic with many alternations and a large number of arithmetic literals, rather than encoding a specific verification or synthesis task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_48.smt2",
    "description": "This benchmark is a quantified bit‑vector satisfiability problem (∃ ?x₁ ∀ ?x₂ ∃ ?x₃ …) over three 32‑bit variables, encoding a large conjunction of linear (multiply‑by‑constant plus add) signed inequalities and disequalities. It originates from the Scholl et al. “Detect and Remove Redundant Linear Constraints in Non‑Convex Polyhedra” paper and was translated to BV by Mathias Preiner; the instance is deliberately random‑looking but contains 153 bvmul, 104 bvneg and 97 bvadd operations with a maximum term depth of 19, making it a heavy, deeply nested quantified BV challenge. The solver must decide whether there exists a value for ?x₁ such that for every ?x₂ there is a ?x₃ satisfying all the mixed signed‑comparison constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_16.smt2",
    "description": "This instance is a quantified bit‑vector satisfiability problem originating from a 2008 study on using SMT solving and Craig interpolation to eliminate redundant linear constraints in non‑convex polyhedra (the original linear constraints have been encoded as 32‑bit arithmetic). It contains a single assertion with a three‑alternation prefix ∃ ?x1 ∀ ?x2 ∃ ?x3, and the body is a large disjunction of linear‑like inequalities and disequalities built from `bvmul`, `bvadd`, and signed comparisons, resulting in 60 multiplications, a maximum term depth of 16, and a dense nesting of Boolean operators. The combination of quantifier alternation, many arithmetic operations, and deep term structure makes it a challenging benchmark for quantified BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_51.smt2",
    "description": "This instance encodes a three‑variable quantified linear‑arithmetic problem over 32‑bit bit‑vectors, originating from the Scholl et al. study on removing redundant constraints in non‑convex polyhedra (translated to BV by Preiner). It asks whether there exists a value for ?x1 such that for every ?x2 there is a ?x3 satisfying a large conjunction of signed‑inequality constraints built from many constant‑scaled multiplications (≈500 bvmul terms) and comparisons, i.e. an ∃∀∃ satisfiability check. The formula’s difficulty stems from the high number of arithmetic terms, deep term nesting (depth 20), and the alternating quantifiers, making it a challenging benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_40.smt2",
    "description": "This benchmark encodes a quantified linear‑arithmetic problem over 32‑bit signed bit‑vectors, taken from the SMT‑08 paper on detecting redundant linear constraints in non‑convex polyhedra (translated to BV by Preiner). The single assertion has the quantifier pattern ∀ x₁ ∃ x₂ ∀ x₃ ∃ x₄ and consists of a huge conjunction of linear equalities and signed inequalities built from constant multiplications, additions and negations. The four quantified variables, deep term nesting (depth 20), and more than two hundred bvmul occurrences create a demanding case for solvers that handle quantified BV formulas.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_32.smt2",
    "description": "This benchmark asks whether a quantified formula over four 32‑bit bit‑vectors is satisfiable. It has a ∀x₁ ∃x₂ ∀x₃ ∃x₄ prefix and a matrix that is a large conjunction of linear arithmetic atoms (constant‑multiplied variables combined with bvadd) linked together by many disjunctions, using signed comparisons (bvslt, bvsle, bvsgt, bvsge) and equalities. Originating from the Scholl‑et‑al. 2008 work on detecting redundant linear constraints in non‑convex polyhedra, the instance is difficult because of the four‑alternation quantifier block, a high density of bvmul/bvadd terms (over 200 multiplications), a max term depth of 19, and a heavily nested Boolean structure.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_50.smt2",
    "description": "This benchmark encodes a quantified bit‑vector problem derived from the “redundant linear constraints in non‑convex polyhedra” study (Scholl et al., SMT‑08), translated to 32‑bit arithmetic. It asks whether the formula with a ∀x₁ ∃x₂ ∀x₃ ∃x₄ prefix—combining hundreds of constant‑scaled multiplications, additions and signed (in)equality checks—has a satisfying assignment. The instance is a large, highly conjunctive/disjunctive QF_BV formula (≈ 17 k characters, term depth 21) that stresses quantifier handling and arithmetic reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_21.smt2",
    "description": "This instance is a quantified bit‑vector satisfiability problem that encodes a large system of linear (signed) inequalities and equalities over three 32‑bit variables. It originates from the “Detecting Redundant Linear Constraints in Non‑Convex Polyhedra” paper (SMT‑08) and was translated to BV by Preiner; the formula has an ∃‑∀‑∃ quantifier pattern (outer existential, universal inner, inner existential) with about 100 bvmul and 60 bvadd occurrences, term depth 17, and many nested conjunctions/disjunctions of signed comparison predicates. The solver must decide whether there exists a value for the first variable such that for every choice of a second variable there is a third variable satisfying all these combined linear constraints, making the instance challenging because of the quantifier alternation and high arithmetic term complexity.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_9.smt2",
    "description": "This instance is a quantified bit‑vector problem encoding the detection of redundant linear constraints in a non‑convex polyhedron (as described in Scholl et al., SMT‑08). It formulates a series of linear equalities and inequalities over four 32‑bit variables with an alternating quantifier pattern ∀x₁ ∃x₂ ∀x₃ ∃x₄, resulting in a moderately deep term structure (depth ≈ 15) and a dense mix of additions, multiplications by constants, and signed comparisons. The single, large quantified assertion tests whether the polyhedral representation satisfies the required redundancy property, making the benchmark challenging for solvers that handle BV quantifiers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_30.smt2",
    "description": "This SMT‑BV instance encodes a quantified linear‑arithmetic problem that stems from the SMT‑08 paper on detecting redundant linear constraints in non‑convex polyhedra (translated to 32‑bit bit‑vectors). It asks whether, for every value of the first variable, there exists a value of the second such that for every value of the third there exists a fourth satisfying a long conjunction of signed inequalities and equalities that are all linear combinations of the variables with constant coefficients (implemented with `bvmul` and `bvadd`). The formula contains a ∀∃∀∃ quantifier alternation over four 32‑bit variables, a term depth of 18, and hundreds of simple arithmetic literals, making it a non‑trivial satisfiability/validity check of a heavily constrained quantified bit‑vector model.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_30.smt2",
    "description": "This instance asks whether a quantified bit‑vector formula with three 32‑bit variables is satisfiable. It encodes a ∃ ?x₁ ∀ ?x₂ ∃ ?x₃ alternation over a large conjunctive‑disjunctive lattice of linear (constant‑multiplied) arithmetic constraints—inequalities, disequalities and equalities—over bit‑vectors. The problem originates from a study on removing redundant linear constraints in non‑convex polyhedra, and its difficulty stems from the deep term nesting (depth 16), the heavy use of constant multiplications, and the three‑level quantifier alternation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_4.smt2",
    "description": "This instance encodes a quantified linear‑arithmetic problem over 32‑bit bit‑vectors: a four‑alternation prefix (∀ x₁ ∃ x₂ ∀ x₃ ∃ x₄) is followed by a large conjunction of signed linear inequalities and equalities built from constants, additions and multiplications by constants. It originates from a paper on using SMT solving and Craig interpolation to eliminate redundant linear constraints in non‑convex polyhedral representations, so the formula essentially asks whether there exists a witness for the inner quantifiers that satisfies all the prescribed linear constraints. The problem features a modest number of variables but a deep term structure (depth 15) and nested quantifiers, making it a non‑trivial quantified BV‑logic instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_33.smt2",
    "description": "The benchmark encodes a quantified 32‑bit bit‑vector problem arising from the “redundant linear constraints in non‑convex polyhedra” paper, translated into BV. It consists of a single large formula with alternating quantifiers (∀x₁ ∃x₂ ∀x₃ ∃x₄) that combines many linear inequalities (multiplications by constants, additions, and signed comparisons) over the four variables, yielding a deep term structure (depth ≈ 17) and a high density of arithmetic operations. The task is to decide satisfiability of this quantified linear‑BV constraint set, which is challenging because of the quantifier alternation and the volume of conjunctive/disjunctive linear constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_2.smt2",
    "description": "The instance encodes a quantified bit‑vector problem originally taken from a study on using SMT solving and Craig interpolation to prune redundant linear constraints in non‑convex polyhedral representations. It consists of a single quantified formula with a ∀∃∀∃ alternation over four 32‑bit signed variables, where the matrix is a conjunction of linear (affine) inequalities and equalities built from many constant‑scaled additions and multiplications. The combination of multiple quantifier alternations, deep arithmetic terms (depth 16) and a relatively high density of BV arithmetic operators makes the solving task non‑trivial for BV‑solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_59.smt2",
    "description": "This SMT‑LIB file encodes a quantified bit‑vector satisfiability problem that stems from the “redundant linear constraints in non‑convex polyhedra” study (Scholl et al., SMT‑08), translated to 32‑bit bit‑vectors by Preiner. The formula has a ∀x₁ ∃x₂ ∀x₃ ∃x₄ prefix over four variables and consists of a dense conjunction of hundreds of linear (addition, multiplication by constant coefficients, and negation) equalities and inequalities, giving a max term depth of 23. Consequently, the instance is a highly quantified, large‑scale BV problem that tests a solver’s ability to handle deep arithmetic nesting and many quantifier alternations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_58.smt2",
    "description": "This instance encodes a quantified bit‑vector formula that originates from a linear‑constraint redundancy check for non‑convex polyhedra (as described in Scholl et al., SMT‑08). It contains a four‑alternation prefix `∀x₁ ∃x₂ ∀x₃ ∃x₄` over 32‑bit vectors, and the matrix is a large conjunction of linear inequalities built from many constant‑multiplied variables (≈ 240 multiplications, 180 additions) with nested `and`/`or` combinations. The problem is essentially a satisfiability/verification query for a heavily quantified, deep‑term BV formula, making it challenging due to the high alternation depth, the large number of arithmetic sub‑terms, and the overall term depth of 20.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_35.smt2",
    "description": "This instance encodes a quantified feasibility check on a system of linear‑integer‑like constraints that originated from the “redundant linear constraints in non‑convex polyhedra” benchmark (Scholl et al., SMT‑08) and was translated to 32‑bit bit‑vectors. The formula has a three‑level quantifier prefix (∃ x₁ ∀ x₂ ∃ x₃) and consists of a large conjunction of linear inequalities and equalities built from constant‑multiplied variables, additions, and signed comparisons (≈ 150 multiplications, depth 18). The problem therefore tests a BV solver’s ability to handle deep, quantifier‑alternating arithmetic formulas rather than simple SAT, making it a challenging verification‑style benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_49.smt2",
    "description": "This instance is a quantified bit‑vector formula originating from the SMT‑08 paper by Scholl et al. on detecting redundant linear constraints in non‑convex polyhedra (translated to BV by Mathias Preiner). It asserts a ∀·∃·∀·∃ alternation over four 32‑bit variables, combining dozens of constant‑multiplied variables with signed equalities, inequalities and Boolean connectives; the single massive clause contains hundreds of bvmul, bvadd and relational atoms with a maximal term depth of 20, which makes it a difficult benchmark for quantifier‑handling BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_34.smt2",
    "description": "This instance is a quantified bit‑vector SAT check that encodes a large conjunction/disjunction of linear‑like equalities and inequalities over three 32‑bit variables, using only constant‑multiplied terms (bvmul) and additions. It originates from the Scholl et al. 2008 study on Craig interpolation for eliminating redundant constraints in non‑convex polyhedra (translated to BV by Mathias Preiner) and features an ∃ ∀ ∃ quantifier prefix with a term‑depth of 17 and more than 130 constant multiplications, making it a comparatively hard benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_17.smt2",
    "description": "The benchmark encodes a quantified bit‑vector feasibility problem: three 32‑bit variables are constrained by a mixture of signed inequalities, equalities and constant‑multiplied linear expressions. It uses a single ∃‑∀‑∃ quantifier prefix (exists x₁ ∀ x₂ exists x₃) together with nested `and`, `or`, and `let` constructs, yielding a moderate term depth (15) and about twenty constant‑multiplications. The instance originates from a study on detecting redundant linear constraints in non‑convex polyhedra, so the core task is to decide whether the quantified linear‑arithmetic constraints are satisfiable.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_42.smt2",
    "description": "This instance encodes a redundancy‑removal check for a non‑convex polyhedral specification that has been translated into 32‑bit bit‑vector arithmetic.  It contains a single quantified formula (a ∀‑quantified “λ’’ and an ∃‑quantified “λ′’’) whose Boolean flags model the presence or absence of many linear constraints, and the body is a deep, highly nested combination of `and`, `not`, arithmetic comparisons (`bvsle`, `bvslt`, `bvadd`, `bvmul`, etc.).  The problem is therefore a quantified BV‑satisfiability / verification task with a very large term depth (≈112) and a dense Boolean structure, making it challenging for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_5.smt2",
    "description": "This instance encodes a redundancy‑detection problem for a set of linear constraints that model a non‑convex polyhedron, translated into 32‑bit bit‑vector arithmetic. The formula consists of a single quantified assertion with one universal and one existential quantifier, many guarded Boolean literals, and a mixture of addition, multiplication, negation and signed‑less‑or‑equal comparisons, yielding a relatively deep term structure (depth 19). Originating from the SMT‑08 paper on using interpolation to prune redundant constraints, the benchmark tests an SMT solver’s ability to handle quantifier‑heavy, bit‑vector intensive reasoning typical of industrial verification tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_17.smt2",
    "description": "This benchmark encodes a quantified bit‑vector feasibility problem that originates from the redundancy‑removal phase for linear constraints of non‑convex polyhedra (as described in Scholl et al., SMT‑08). A universally‑quantified 32‑bit parameter (λ) is constrained by a mixture of linear inequality checks (≤, <) built from additions, multiplications by constants and negations, while an existentially‑quantified witness (λ′) appears inside nested Boolean flags that model the presence or absence of individual constraints. The instance features a single large quantified assertion with deep term nesting (depth ≈ 30), many Boolean‑logic combinations, and a quantifier alternation (∀ λ ∃ λ′), making it a challenging industrial‑style BV verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_15.smt2",
    "description": "This instance encodes a verification‑style query on a set of linear (inequality) constraints that have been translated into 32‑bit vector arithmetic.  A universally quantified variable (λ) and an existentially quantified witness (λ′) are combined with a handful of Boolean flags to express whether a particular combination of arithmetic bounds can be satisfied, essentially modeling the detection of redundant linear constraints in a non‑convex polyhedral representation.  The formula features a single quantified assertion with alternating ∀/∃, deep nesting of bit‑vector multiplications, additions, divisions and signed comparisons, and a large number of Boolean conjuncts, giving it moderate size (≈1900 tokens) but non‑trivial solving difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_12.smt2",
    "description": "This benchmark encodes a quantified bit‑vector formula derived from a study on detecting and eliminating redundant linear constraints in non‑convex polyhedra. It features a universal 32‑bit variable together with an inner existential quantifier, and a large conjunction of linear inequalities (expressed with BV addition, multiplication, and signed‑less‑equal) intertwined with several Boolean flag conditions. The alternating quantifiers, deep term nesting (depth 19), and the mix of arithmetic and propositional reasoning create a challenging industrial‑style verification problem for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_67.smt2",
    "description": "This instance is a 32‑bit bit‑vector feasibility check originating from the “SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra” benchmark (Scholl et al., SMT‑08). It encodes a family of linear inequalities over three integer variables (x3, x4, x5) together with a set of Boolean flags, wrapped in a single ∀λ ∃λ′ quantifier block that tests whether a parameterised polyhedral region can satisfy all constraints. The formula is highly conjunctive (≈130 and, 127 not) with deep let‑nesting (depth 54) and many intertwined arithmetic and Boolean conditions, giving it the character of a dense, industrial‑scale BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_9.smt2",
    "description": "The instance encodes a quantified bit‑vector formula arising from a redundancy‑removal test for linear constraints in non‑convex polyhedra (as described in the Scholl et al. paper). It asserts that for every 32‑bit value λ there must exist a 32‑bit λ′ within a bounded interval such that a collection of linear inequalities (involving constants like 30, 4100, 4500, 4910, 4820) holds, while three Boolean flags control alternative sub‑cases. The benchmark features a single quantifier alternation (∀ λ ∃ λ′) with moderate term depth (≈17) and several bit‑vector arithmetic operations, making it a representative industrial case for quantifier reasoning in the BV logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_39.smt2",
    "description": "This benchmark asks whether a 32‑bit parameter λ can satisfy a large guarded system of linear (addition, multiplication, division and inequality) constraints on the two other 32‑bit variables x₃ and x₄, while there also exists a λ′ that meets the same family of constraints under a different set of guard‑flags.  It is a pure‐satisfiability/verification problem taken from Scholl et al.’s “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra” (SMT‑08), translated to bit‑vectors by Mathias Preiner.  The formula contains one universal and one existential quantifier, hundreds of Boolean flags combined with deep nested let/and/not structures (max term depth 142, ~14 KB size), which together make it a difficult industrial BV benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_56.smt2",
    "description": "This instance encodes a redundancy‑detection problem for a set of linear constraints (originating from the Scholl et al. “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra” benchmark) that has been translated into 32‑bit signed bit‑vector arithmetic. The single large assertion combines a universal quantifier over a parameter λ with an inner existential quantifier over λ′, a rich mixture of linear expressions (scaled adds, multiplications, signed divisions) and many Boolean selector variables, forming a deep (depth ≈ 42) Boolean‑arithmetic formula with numerous nested `let` bindings. The task is to decide satisfiability of these quantified constraints, a typical industrial BV benchmark that stresses solvers with alternating quantifiers, heavy use of signed comparisons, and a dense Boolean control structure.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_11.smt2",
    "description": "The benchmark encodes a verification condition that arises from the analysis of non‑convex polyhedral constraints: it asserts that for every 32‑bit integer λ either a suitable auxiliary integer λ′ exists satisfying a collection of signed linear inequalities (involving multiplications by constants such as –1, 20 and large negative bounds) together with three Boolean flags, or λ is negative, otherwise a contradictory inequality between two linear expressions must hold.  The problem originates from an industrial study on detecting and removing redundant linear constraints, and is challenging because it features a single, deeply nested ∀∃ quantified formula with multiple bit‑vector arithmetic operations and a term depth of 17.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_47.smt2",
    "description": "This benchmark encodes a quantified bit‑vector verification problem taken from the “redundant linear constraints in non‑convex polyhedra” case study (Scholl et al., SMT‑08). It asks whether there exists a 32‑bit value λ that satisfies a large conjunction of linear inequalities (expressed with additions, multiplications by constants, and signed divisions) together with a number of Boolean flag conditions, under a universal quantifier that also contains an inner existential quantifier over a second 32‑bit variable λ′. The instance is industrial‑style, features a single deep quantified assertion (quantifier alternation ∀∃), many Boolean combinators, and a term‑depth of 22, making it a non‑trivial challenge for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_52.smt2",
    "description": "This instance originates from the 2008 SMT‑Workshop paper on using Craig interpolation to eliminate redundant linear constraints from non‑convex polyhedra. It encodes a single quantified verification condition over 32‑bit bit‑vectors: a universal quantifier on a parameter λ and an inner existential quantifier on a second parameter λ′, combined with a large Boolean “control‑flag” matrix. The core constraints are linear (scaled additions and multiplications of the program variables x₃, x₄, x₅) bounded by numerous signed‑less‑or‑equal checks, representing the emptiness / redundancy test for a set of linear inequalities. The formula is highly Boolean‑dense, with deep nesting (term depth ≈ 43) and two quantifier alternations, making it a challenging industrial‑style quantified BV problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_26.smt2",
    "description": "This instance, taken from Scholl et al.’s work on using SMT and Craig interpolation to eliminate redundant linear constraints in non‑convex polyhedra, encodes a quantified bit‑vector verification problem. It asserts a universally quantified λ (32‑bit) and, for each λ, searches for a λ′ (via an existential quantifier) satisfying a dense conjunction of linear‑inequality‑style constraints expressed with `bvadd`, `bvmul`, `bvsle`, etc., controlled by a number of Boolean flags. The formula features a single large quantified assertion with alternating ∀/∃, deep term nesting (depth 21) and many Boolean combinations, making it a challenging industrial‑style BV problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_31.smt2",
    "description": "This instance is a quantified bit‑vector satisfiability problem originating from the paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* (SMT‑08). It encodes a set of linear inequalities over 32‑bit vectors together with a collection of Boolean flags, wrapped in a single ∀λ∃λ′ formula that checks whether a particular combination of bounds and conditional constraints can hold. The problem features a moderate number of variables (12 constants) but deep term nesting (depth 19) and many Boolean combinations, making it a challenging industrial‑style verification query for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_22.smt2",
    "description": "The benchmark encodes a verification‑style check for redundancy among a set of linear constraints that model a non‑convex polyhedron, after translating the original integer arithmetic into 32‑bit bit‑vectors.  It contains a single quantified assertion with a universal λ and an inner existential λ′, a lattice of Boolean flags (bool.b20 … bool.b23) that enable or disable individual constraints, and a mixture of BV additions, multiplications, divisions and signed comparisons; the formula is deep (max term depth 39) and heavily nested with 50 ∧, 52 ¬ and several let‑bindings.  The instance thus tests an SMT‑BV solver’s ability to handle quantified linear arithmetic together with many Boolean conditionals, a typical industrial problem arising from the “redundant linear constraints” case study of Scholl et al. (SMT‑08).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_36.smt2",
    "description": "This instance encodes a feasibility check on a large system of 32‑bit linear (difference) constraints that are gated by dozens of Boolean selector variables.  Originating from the “redundant linear constraints in non‑convex polyhedra” case study, the formula contains a universal quantifier over a parameter λ and an existential quantifier over a second parameter λ′, together with a deep nesting of conjunctive Boolean conditions and bit‑vector inequalities (≤, <, addition, multiplication, division).  The goal is to determine whether the combined arithmetic and Boolean constraints can be satisfied, a typical industrial‑style SAT/SMT problem that is difficult because of many inter‑dependent Booleans, a single quantifier alternation, and a maximal term depth of 144.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_7.smt2",
    "description": "This benchmark encodes a verification condition for detecting and eliminating redundant linear constraints in a non‑convex polyhedral model, translated into 32‑bit bit‑vector arithmetic. The single assertion is a ∀‑∃ formula that combines several signed inequality constraints (using bvsle/bvslt) with Boolean control flags, forming a nested combination of and, or, and not. Although it involves only a handful of bit‑vector and Boolean variables, the quantifier alternation and deep term structure (depth 19) make it a non‑trivial industrial BV instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_37.smt2",
    "description": "This instance encodes the feasibility of a highly constrained linear‑arithmetic system that originates from the redundancy‑removal problem for non‑convex polyhedra (as described in the Scholl et al. 2008 paper).  The formula combines a universal quantifier over a 32‑bit parameter λ with an existential witness λ′, together with a large conjunction of Boolean flags (bool.b …) and bit‑vector inequalities (additions, multiplications, divisions and signed comparisons) on the four 32‑bit variables λ, λ′, x3 and x4.  The goal is to check whether the quantified conjunction is satisfiable – i.e., whether there exists an assignment to the Boolean selectors and the numeric variables that respects all encoded linear constraints – a task typical of industrial verification / interpolation‑based redundancy detection.  The problem is challenging because it contains a single alternation of quantified variables but a very deep term nesting (depth ≈ 137) and hundreds of Boolean sub‑expressions, resulting in a massive conjunctive structure that stresses the solver’s handling of bit‑vector arithmetic and Boolean reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_11.smt2",
    "description": "This instance encodes a quantified bit‑vector verification problem derived from the redundancy‑removal analysis of non‑convex polyhedral constraints (as described in the SMT‑08 paper on Craig interpolation). It asserts a single ∀λ∃λ′ formula that combines linear‑type arithmetic (expressed through BV addition, multiplication and signed‑less‑equal) with a dense Boolean combination of auxiliary predicates, modelling the interplay of several linear inequalities. The benchmark is industrial‑style, featuring one quantifier alternation, deep term nesting (depth 19) and a sizable Boolean structure, which makes it a challenging case for solvers handling quantified BV logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_76.smt2",
    "description": "This instance encodes a feasibility check for a large system of 32‑bit linear inequalities that arise from the redundancy‑removal analysis of non‑convex polyhedra (the Scholl‑et‑al. “SMT‑based constraint reduction” benchmark).  The formula contains a single universally quantified parameter λ and an existentially quantified λ′ together with a host of Boolean selector variables that model the presence or absence of individual constraints; all constraints are expressed as bit‑vector additions, multiplications and signed comparisons (bvsle, bvslt).  The problem is essentially a verification/satisfiability test of a highly conjunctive, deeply nested Boolean‑arithmetic circuit (max term depth 77, ~150 ¬ and 156 ∧ operators), making it a challenging industrial benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_21.smt2",
    "description": "The instance encodes a verification task that checks the redundancy of a family of linear (inequality) constraints over 32‑bit integer variables, after they have been translated into bit‑vector arithmetic.  It asserts a universally quantified condition on a parameter λ (and an existentially quantified λ′) together with a number of Boolean flags that select which constraints are active, testing whether the combined set of signed‑inequalities can be satisfied without violating a bound (i.e., whether any redundant or contradictory constraint exists).  The problem is industrial‑style, features both universal and existential quantifiers, deep term nesting (depth ≈ 25), and a moderate number of Boolean‑control variables, making it a challenging quantified bit‑vector redundancy‑detection benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_40.smt2",
    "description": "This is an industrial bit‑vector benchmark that encodes a feasibility check for a system of linear inequalities derived from a non‑convex polyhedral model (the “redundant linear‑constraint detection” study). The single assertion combines a universally quantified parameter (λ) with an existentially quantified λ′, a collection of Boolean flags, and a large conjunction of bounded‑integer (32‑bit) arithmetic constraints (adds, multiplies, divisions and signed comparisons). The problem tests an SMT solver’s ability to handle deep (≈26) term nesting, many Boolean‑arithmetic combinations, and a quantifier alternation (∀ λ ∃ λ′) within the BV logic, making it a challenging SAT/unsat query for interpolation‑based or quantifier‑instantiation techniques.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_25.smt2",
    "description": "This instance is a quantified bit‑vector satisfiability problem derived from the paper “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra.”  It encodes a set of linear (in)equalities over 32‑bit variables together with a number of Boolean selectors that model the presence or removal of individual constraints; the core query is a single ∀λ∃λ′ formula that checks whether the remaining constraints admit any solution.  The benchmark features a deep term structure (depth ≈ 40), a mixture of arithmetic (addition, multiplication, signed division) and Boolean logic, and a single quantifier alternation, making it a challenging industrial‑style verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_63.smt2",
    "description": "This benchmark encodes a consistency check on a large set of linear bit‑vector inequalities derived from a non‑convex polyhedral model. It contains a single quantified formula with a universal quantifier over a 32‑bit parameter and an existential quantifier over a related parameter, together with a deep Boolean combination of “≤”, “<”, and arithmetic expressions that represent redundant‑constraint detection as described in Scholl et al. (SMT‑08). The instance features very high term depth (≈ 91) and many nested Boolean operators, making it a challenging industrial BV‑logic verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_27.smt2",
    "description": "This instance stems from a paper on using SMT and Craig interpolation to prune redundant linear constraints in non‑convex polyhedra; it has been translated to 32‑bit bit‑vector arithmetic. The single quantified assertion asks whether, for every value of a universally‑quantified parameter λ, there exists a λ′ such that a large conjunction of linear inequalities (expressed with BV addition, multiplication by constants, and signed‑less‑or‑equal checks) over three integer variables (x₃, x₄, x₅) and several Boolean condition flags can be satisfied. The formula features a forall–exists alternation, deep (≈20) term nesting, and a dense mix of Boolean and bit‑vector arithmetic, representing an industrial‑scale verification / redundancy‑detection problem that is challenging for solvers handling quantified BV constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_3.smt2",
    "description": "This benchmark encodes an industrial verification task that checks redundancy of a set of linear constraints (originating from a non‑convex polyhedron) after they have been translated to 32‑bit bit‑vectors. The single quantified assertion uses a ∀λ ∃λ′ pattern together with several optional Boolean flags to express that, for every λ, either a witness λ′ satisfies a bounded collection of arithmetic inequalities or a final bound is violated—i.e., the original constraint system is inconsistent or contains redundant clauses. The instance features a modest number of BV variables (six constants) but a non‑trivial quantifier alternation and deep arithmetic terms (max depth 19), typical of the “Preiner‑scholl‑smt08” industrial family.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_58.smt2",
    "description": "This instance encodes a quantified feasibility problem over 32‑bit integers that originates from the “redundant linear constraints in non‑convex polyhedra” benchmark.  It states that for every value of a parameter λ a large conjunction of guarded linear (bit‑vector) inequalities must hold, while simultaneously there exists a witness λ′ satisfying a second, tightly intertwined set of inequalities; the Boolean variables bool.b* act as control flags for the various guards.  The formula features a single ∀∃ alternation, deep nested let‑expressions, and many combined BV‑arithmetical constraints, making it a challenging industrial BV verification case.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_8.smt2",
    "description": "This instance is an industrial benchmark derived from the paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* (SMT‑08). It encodes a quantified bit‑vector problem: a universal quantifier over a 32‑bit variable and an inner existential quantifier, together with several linear BV constraints (additions, constant multiplications, a signed division) and three Boolean control flags. The goal is to check the satisfiability of the encoded redundancy‑removal condition; the formula is relatively shallow (max term depth 17) but features a quantifier alternation and mixed arithmetic‑logic, making it a typical challenging benchmark for BV‑quantifier solving.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_4.smt2",
    "description": "The benchmark encodes a redundancy‑detection query for a set of linear constraints that represent a non‑convex polyhedron, translated into 32‑bit bit‑vector arithmetic. It consists of a single quantified formula (a universal over λ with an inner existential over λ′) that combines several linear inequalities and Boolean flag conditions, yielding a fairly deep term structure (depth 21) and a forall‑exists alternation. This industrial‑style instance tests an SMT solver’s ability to handle bit‑vector arithmetic together with nested quantifiers and complex Boolean combinations, as required for Craig‑interpolation‑based constraint elimination.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_55.smt2",
    "description": "This instance encodes a single quantified formula over 32‑bit bit‑vectors that models a system of linear inequalities together with Boolean flags indicating whether individual constraints are active.  It originates from the “redundant linear constraints in non‑convex polyhedra” benchmark (Scholl et al., SMT‑08) and has been translated to the BV logic, featuring one universal quantifier, one existential quantifier, deep let‑bindings (max term depth 47) and a heavy mix of Boolean combinations (≈90 and, 80 not).  The solver is asked to decide whether the combined arithmetic and Boolean conditions are satisfiable, a typical industrial verification/constraint‑redundancy checking problem that is challenging due to the high quantifier alternation and heavily nested expressions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_64.smt2",
    "description": "This instance encodes the feasibility of a large, non‑convex polyhedral system that has been translated into 32‑bit‑vector arithmetic.  It features a single universally‑quantified parameter (λ) and a nested existential quantifier (λ′) together with dozens of Boolean guard variables (bool.b17 … bool.b24) that switch individual linear inequalities on and off, resulting in a massive conjunction of guarded bvsle/bvslt constraints.  The formula’s depth (75) and heavy use of let‑bindings, many Boolean operators, and quantifier alternation make it a challenging quantified‑BV satisfiability problem derived from the “redundant linear‑constraint removal” benchmark of Scholl et al. (SMT‑08).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_2.smt2",
    "description": "This benchmark is an industrial‑style redundancy‑check instance taken from Scholl et al.’s “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra” (SMT‑08) and translated to 32‑bit bit‑vector arithmetic. It consists of a single quantified assertion that mixes a universal quantifier over a bit‑vector λ with an inner existential quantifier over λ′, encoding several linear inequalities (e.g., 0 ≤ λ′ ≤ λ, … ≤ 33, … ≥ ‑4100) together with Boolean flags that model the presence or absence of individual constraints. The problem therefore asks whether the combination of these arithmetic and Boolean conditions is satisfiable, exercising quantifier reasoning, deep term nesting (depth ≈ 19) and a mix of arithmetic and propositional structure.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_35.smt2",
    "description": "This benchmark encodes a verification / redundancy‑elimination task from the paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* (SMT‑08). It is expressed in 32‑bit bit‑vector logic and contains a single universally‑quantified variable (λ) and an existentially‑quantified variable (λ′), ten bit‑vector constants (including x3, x4) and eight Boolean flags (bool.b17 … bool.b24). The formula consists of many linear inequalities (bvsle, bvslt, bvsdiv, bvadd, bvmul) combined through a huge nest of conjunctions and negations (≈ 468 and, 390 not, term depth 145), creating a deep, highly Boolean‑laden constraint graph that makes the instance challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_59.smt2",
    "description": "This instance encodes a consistency check for a large system of guarded linear (integer) inequalities that originate from a non‑convex polyhedral representation, as described in the Scholl et al. 2008 paper on detecting redundant constraints. The constraints are translated into 32‑bit signed bit‑vector arithmetic and combined with many Boolean flags; a universal quantifier over a parameter λ and an inner existential quantifier over λ′ create a single quantified alternation, while the formula contains deep nesting (term depth ≈ 90) of `let`, `and`, and `not` operators. The solver must decide whether the guarded set of inequalities is satisfiable, a task made difficult by the intricate Boolean control structure and the high combinatorial depth of the expressions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_38.smt2",
    "description": "This benchmark encodes a verification condition for detecting and removing redundant linear constraints in a non‑convex polyhedral representation. It uses 32‑bit signed bit‑vector arithmetic (additions, scalar multiplications, signed ≤/<) guarded by a number of Boolean flag variables, and combines a universal quantifier over a parameter with an existential quantifier for a witness inside a large disjunction. The formula is industrial‑style, with deep nesting (term depth 36) and a dense mix of Boolean and arithmetic constraints, making quantifier handling and bit‑vector reasoning the main sources of difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_69.smt2",
    "description": "This instance encodes a feasibility check for a highly constrained, non‑convex polyhedral region that originates from the “redundant linear‑constraint detection” study (Scholl et al., SMT‑08) and was translated into 32‑bit bit‑vector arithmetic. The formula contains a single universally‑quantified variable and an inner existential quantifier, together with a dense lattice of Boolean control flags and nested arithmetic bounds (linear combinations, divisions, and sign tests), producing a deep term structure (depth ≈ 64) and a large number of logical connectives. Consequently, the problem is a satisfiability query for a quantified BV formula with many intertwined linear constraints, typical of industrial verification‑style instances that are challenging for current solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_38.smt2",
    "description": "This instance encodes the “redundant linear‑constraint detection” problem from the 2008 SMT‑Workshop paper by Scholl et al., translated into 32‑bit bit‑vector arithmetic.  It asks whether there exist concrete values for the parameters (λ and λ′) that satisfy a large conjunction of linear inequalities on the variables x₃, x₄, expressed through many Boolean flag variables (bool.b …) and quantified both universally (over λ) and existentially (over λ′).  The formula is highly intricate – a single assertion with a term depth of 139, over 470 “and”s and nearly 400 “not”s, and a deep nesting of let‑bindings – making it a demanding industrial benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_10.smt2",
    "description": "This instance encodes a verification‑style check from the paper on detecting redundant linear constraints in non‑convex polyhedral representations.  After translation to 32‑bit bit‑vectors, the single asserted formula asserts that for every value of a universally quantified variable there exists a witness satisfying a set of linear inequalities (expressed with bvadd, bvmul, bvsdiv, and bvsle) together with three Boolean guard conditions.  The problem features a single quantifier alternation (∀∃) over bit‑vectors and a moderate term depth, making it a typical industrial quantified‑BV benchmark that tests a solver’s ability to handle nested linear constraints and Boolean side‑conditions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_17.smt2",
    "description": "This instance encodes a feasibility check over a set of parametric linear (affine) constraints that arise in the analysis of non‑convex polyhedra, as described in Scholl et al.’s 2008 paper on using SMT and Craig interpolation to prune redundant constraints.  It is a single quantified formula in the BV logic that universally quantifies a 32‑bit parameter λ and existentially quantifies a related parameter λ′, mixing Boolean flags with bit‑vector inequalities (≤, <) built from additions, scalar multiplications and negations; the formula contains several nested let‑bindings, many Boolean connectives, and a quantifier alternation depth of two.  The problem is thus an industrial‑style verification/invariant‑satisfaction query with moderate size (≈2 KB) but a high term‑depth (27) and a dense Boolean‑linear structure that makes it challenging for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_3.smt2",
    "description": "This instance encodes a quantified linear‐arithmetic decision problem over 32‑bit bit‑vectors that originates from an industrial case study on detecting and removing redundant linear constraints in non‑convex polyhedral models.  A single deeply nested formula contains a universal quantifier over a “λ” variable and an inner existential quantifier, combined with many Boolean flags and linear expressions (additions, multiplications, and order comparisons) that capture bound conditions such as 0 ≤ λ′ ≤ λ and various offset inequalities.  The problem therefore challenges the solver with a mixed‑quantifier, Boolean‑rich BV formula of moderate size (≈ 20 operators, term depth 19) rather than a plain quantifier‑free arithmetic check.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_50.smt2",
    "description": "This instance encodes the redundancy‑detection condition for a non‑convex polyhedron using 32‑bit bit‑vector linear arithmetic. A universally quantified parameter λ together with an existentially quantified λ′ (bounded by 0 ≤ λ′ ≤ λ) are constrained by a large conjunction of signed‑less‑or‑equal comparisons involving the variables x3, x4 and several Boolean “guard” flags (bool.b17…bool.b24) that select which linear bounds are active. The formula, originating from the Scholl et al. 2008 paper on eliminating redundant linear constraints, is industrial‑scale (≈7.5 k term nodes, depth 96) and features a deep hierarchy of let‑bindings, many nested negations and a single quantifier alternation, making it a challenging BV‑SAT/verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_33.smt2",
    "description": "The benchmark encodes a feasibility check for a system of linear (polyhedral) constraints that have been translated into 32‑bit bit‑vector arithmetic and guarded by a collection of Boolean flags.  A single quantified assertion combines a universal quantifier over a variable λ and an inner existential quantifier over λ′, expressing that for every λ within certain bounds all the guarded inequalities (including divisions, multiplications and signed comparisons) must hold, or else a contradiction is derived.  The instance is a relatively large, deeply nested BV formula (≈3 k AST nodes, depth 31) with many Boolean conjuncts, making it a challenging case for solvers that must handle mixed quantifiers and intricate bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_49.smt2",
    "description": "The instance encodes a feasibility check for a highly constrained non‑convex polyhedron that has been translated into 32‑bit bit‑vector arithmetic. It contains a single quantified formula with a universal quantifier over a parameter λ and an existential quantifier over a derived parameter λ′, together with a large Boolean “control‑flag” vector (bool.b17 … bool.b24) that toggles many linear inequalities; the formula is a deep nesting of let‑bindings, negations and conjunctions (≈150 ¬ and 140 ∧) and reaches a term depth of 96. Thus the problem is an industrial‑style verification task (detecting redundant linear constraints) that is challenging for solvers because of the extensive quantifier alternation, the many intertwined bit‑vector linear constraints, and the combinatorial explosion of Boolean combinations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_14.smt2",
    "description": "This benchmark encodes a quantified redundancy‑check for linear constraints in a non‑convex polyhedron, taken from Scholl et al.’s SMT‑08 paper on using interpolation to remove unnecessary constraints. It asserts a single formula with a universal 32‑bit variable λ and an existential 32‑bit variable λ′, together with three Boolean flags that gate signed inequalities built from bit‑vector addition, multiplication, division and negation, thus representing three possible bound violations. The instance features one forall–exists alternation, moderate term depth (≈17) and a mix of arithmetic and Boolean structure, typical of industrial BV verification problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_1.smt2",
    "description": "This instance encodes a redundancy‑check for a system of linear constraints (originating from a non‑convex polyhedron) as a quantified bit‑vector formula. It asserts that for every 32‑bit value λ there exists a λ′ satisfying a bounded range and a set of guarded linear inequalities involving the constants 30, 4100, 4500 and 4910 together with three Boolean control flags; the outer implication also contains a simple bound on a separate linear expression. The problem features a single ∀∃ quantifier block, a modest number of variables (five), but non‑trivial term depth (≈14) and mixed arithmetic/Boolean structure, making it a typical industrial benchmark for quantified BV reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_22.smt2",
    "description": "The instance encodes a redundancy‑detection problem for a system of linear constraints that arise in the representation of a non‑convex polyhedron.  After translating the integer inequalities to 32‑bit bit‑vector arithmetic, the formula asserts that for every value of a parameter λ, a complex Boolean combination of bounds (involving multiplications, additions and comparisons) holds; an inner existential quantifier introduces a witness λ′ to express the possible removal of a constraint.  The benchmark originates from the Scholl et al. “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints” paper, and it features a single quantified assertion with one ∀∃ alternation, deep term nesting (depth ≈ 25), and a dense mix of Boolean flags and bit‑vector arithmetic, making it a challenging industrial‑style BV quantifier‑reasoning task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_34.smt2",
    "description": "This instance encodes an industrial‑style verification problem for a set of linear inequalities derived from a non‑convex polyhedral model. The constraints are translated into 32‑bit bit‑vector arithmetic and guarded by a large collection of Boolean selector variables, with a universal quantifier over a parameter λ and a single existential quantifier over a second parameter λ′ to capture redundancy and range conditions (e.g., bounds on x4 + 20·λ, x3 – λ, and various linear combinations). The formula consists of a single massive conjunctive‑normal‑like assertion that intertwines many “and”/“not” combinations, yielding a deep term hierarchy (depth ≈ 138) and a heavy mix of Boolean logic and BV arithmetic, which makes the solving task challenging despite the modest number of declared constants.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_5.smt2",
    "description": "This instance encodes the “redundant linear‑constraint detection” problem from the Scholl et al. SMT‑08 paper, translated into 32‑bit bit‑vector arithmetic. It consists of a single quantified assertion with one universal (over λ) and one nested existential (over λ′) block, Boolean selector flags, and a conjunction of signed linear inequalities (addition, multiplication, and ≤/ < comparisons) that capture bounds such as ‑4100, ‑4500, ‑4910, 45, etc. The formula has a deep term structure (depth 22) and many conjuncts, making it a non‑trivial BV‑logic instance with quantifier alternation typical of industrial verification tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_51.smt2",
    "description": "This instance encodes a verification query about redundant linear constraints in a non‑convex polyhedral model.  The problem is expressed in 32‑bit bit‑vector arithmetic together with a large Boolean control structure and a single quantifier alternation (a universal λ followed by an existential λ′) that captures the condition “for every λ there exists a λ′ satisfying a set of linear‑inequality‑like bounds”.  The formula contains deep nested let‑expressions (depth ≈ 43), many Boolean combinations, and multiple arithmetic operations, making it a challenging industrial‑style SAT/UNSAT check for SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_8.smt2",
    "description": "This instance is a quantified bit‑vector satisfiability problem that encodes a feasibility check for a set of linear inequalities together with a few Boolean flags. It asks whether for every 32‑bit value λ there exists a 32‑bit value λ′ (with 0 ≤ λ′ ≤ λ) such that a collection of scaled sums and bounds (derived from the original linear constraints) hold, while a particular Boolean combination of flags must also be satisfied. The formula features a single ∀∃ quantifier alternation, deep nesting of arithmetic (multiplication by constants, division, addition) and many conjunctive/disjunctive Boolean conditions, making it a non‑trivial industrial benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_62.smt2",
    "description": "This instance is a bit‑vector encoding of the “redundant linear‑constraint detection” problem for non‑convex polyhedra (the industrial benchmark from Scholl et al., SMT‑08). It asserts a single quantified formula that combines an existential choice of a candidate parameter ( λ′ ) with a universal range for λ, together with a huge conjunction of linear arithmetic inequalities (scaled, divided and summed) guarded by many Boolean flags (bool.b17… bool.b24). The formula features one ∀ and one ∃ quantifier, deep nesting (term depth ≈ 96) and a massive number of logical connectives, making it a challenging BV‑solving case that tests quantifier handling and large conjunction/disjunction structures.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_53.smt2",
    "description": "The instance encodes a feasibility check for a highly intertwined system of signed 32‑bit linear constraints that originate from the “redundant linear constraints in non‑convex polyhedra” benchmark (Scholl et al., SMT‑08) and was translated to bit‑vectors by Preiner. It contains a single quantified formula with a universal quantifier over a variable λ and an inner existential quantifier over a second variable λ′, mixing numerous Boolean flags that enable or disable individual inequalities; the constraints are expressed via additions, multiplications, divisions and signed ≤/<? comparisons. The problem is industrial‑style, featuring deep term nesting (depth ≈ 49), many Boolean connectives (≈ 85 and, 73 not), and both quantifier alternations, making it a challenging quantified bit‑vector satisfiability instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_33.smt2",
    "description": "This benchmark encodes the detection of redundant linear constraints in a non‑convex polyhedron, translated to 32‑bit bit‑vector arithmetic. A single, highly nested assertion combines a universal quantifier over a “lambda” variable, an existential quantifier over a “lambdaprime” variable, and dozens of Boolean selector flags that gate a rich collection of bound checks (e.g., 0 ≤ lambda ≤ 30, various ≤ ‑4100, ‑4500, ‑4910 …) and linear combinations of the two main vectors x3, x4. The formula’s extreme term depth (108), massive conjunction/disjunction nesting, and quantifier alternation make it a demanding industrial‑style verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_24.smt2",
    "description": "The benchmark encodes a quantified bit‑vector verification task derived from the paper “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”.  It checks the satisfiability of a single, heavily nested formula that combines a universal quantifier over a 32‑bit variable with an inner existential quantifier, a large set of Boolean flag constants, and numerous linear‑arithmetic constraints (addition, multiplication, division and signed‑less‑than/equal) on 32‑bit vectors.  The presence of a forall‑exists alternation, deep term nesting (depth 22) and many Boolean control variables makes the instance a challenging industrial‑style case for solvers handling quantified bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_44.smt2",
    "description": "The benchmark encodes a single quantified constraint that models the redundancy‑removal problem for a non‑convex polyhedron: a universal 32‑bit variable and an existential 32‑bit variable are linked by a dense mixture of linear bit‑vector arithmetic (adds, multiplies, divisions, and signed inequalities) together with a large Boolean flag network representing the presence or absence of individual linear constraints. The SAT check asks whether there exists a value for the existential variable that satisfies all the arithmetic bounds while respecting the Boolean combination, i.e., whether the set of constraints is consistent after eliminating redundancies. The formula is industrial‑scale, featuring one alternation of quantifiers, deep term nesting (depth 23), and a heavy use of Boolean connectives (over 40 ‘and’/‘not’), which together make it a difficult BV‑logic instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_60.smt2",
    "description": "The instance encodes a feasibility check for a system of linear (inequality) constraints over 32‑bit variables, originally arising from the detection of redundant constraints in a non‑convex polyhedral representation. It is expressed in the BV logic as a single quantified formula that combines a universal quantifier over a parameter λ, an existential quantifier over a secondary parameter λ′, and a suite of Boolean flags that enable or disable individual constraints, all built from nested `bvadd`, `bvmul`, `bvsdiv` and `bvsle` terms. The problem is essentially an industrial‑style SMT‑BV verification/satisfiability query with a moderate number of variables, deep term nesting (depth 36), and one alternation of quantifiers, making it a challenging benchmark for solvers handling quantified bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_9.smt2",
    "description": "This instance encodes a redundancy‑checking problem for a set of linear constraints arising from non‑convex polyhedral representations (the benchmark comes from the SMT‑08 “Craig interpolation for redundant linear constraints” paper). It is a single quantified formula over 32‑bit bit‑vectors that combines a universal quantifier on a variable with an inner existential quantifier, a mixture of linear arithmetic (adds, multiplies by constants, signed ≤/ <) and a bundle of Boolean flags that model the presence or absence of individual constraints. The encoding features a deep (≈19) term nesting, alternating quantifiers, and many Boolean‑arithmetic interactions, making it a typical industrial BV benchmark that stresses quantifier handling and bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_28.smt2",
    "description": "This instance is an industrial‐style verification problem derived from the paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* (SMT‑08).  It encodes a set of signed 32‑bit linear constraints (bounds on two quantified variables and three parameters) together with a large Boolean control skeleton; the goal is to decide whether the quantified formula is satisfiable, i.e., whether a certain combination of constraints can be simultaneously satisfied.  The encoding features a single quantified (∀λ ∃λ′) formula with many nested Boolean combinations, several arithmetic operations (addition, multiplication by constants, negation) and a moderate term depth (≈20), making it a non‑trivial bit‑vector benchmark that tests quantifier handling and mixed Boolean‑arithmetic reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_6_true-unreach-call_true-no-overflow.i_432.smt2",
    "description": "This instance is an industrial software‑verification query generated by Ultimate Automizer from a SV‑COMP 2017 C benchmark (the “jain_6” unreachability/overflow test). It encodes a safety property as a combination of a universal quantified clause (requiring either a specific bit‑vector sum to be zero or two arithmetic expressions to be distinct) together with the negation of another universal clause, thereby asking whether the asserted arithmetic relation among program variables and nondeterministic inputs can ever be violated. The problem is a modest‑size BV formula (32‑bit vectors, many multiplications by large constants) that involves only a single quantifier block but heavy use of quantified bit‑vector arithmetic, which makes it a typical – and challenging – quantified BV verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_4_true-unreach-call_true-no-overflow.i_462.smt2",
    "description": "This instance encodes a software‑verification safety check generated by Ultimate Automizer for an SV‑COMP 2017 benchmark (industrial category). The goal is to prove that, for all possible 32‑bit nondeterministic inputs, a certain linear combination of the program’s variables (involving multiplications by small constants and additions) can never equal another combination—i.e., a reachability/overflow property is violated. The formula uses several universally quantified bit‑vector variables, constant multipliers (4 and 8), and a handful of deep arithmetic terms, making it a modestly sized but quantifier‑rich BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_4_true-unreach-call_true-no-overflow.i_433.smt2",
    "description": "This instance is a software‑verification problem generated by Ultimate Automizer from an SV‑COMP 2017 benchmark. It encodes, using 32‑bit bit‑vector arithmetic, the safety condition that a certain call is unreachable (no overflow) by asserting a universally quantified arithmetic relation over nondeterministic inputs and then negating a similar universal formula to search for a counterexample. The formula contains only linear combinations with constant factors (4 and 8), a few quantified variables, modest term depth (10) and no quantifier alternation, making it a relatively small but non‑trivial bit‑vector verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_240.smt2",
    "description": "This instance encodes a safety‑property verification condition generated by Ultimate Automizer from an SV‑COMP 2017 benchmark. It asserts that a linear combination of three program variables (32‑bit bitvectors) and several nondeterministic inputs is always distinct from another linear combination, and then checks the negation of this property. The formula is a quantified bit‑vector problem (three universal quantifier blocks, no alternation) with moderate term depth (≈8) and many linear bvmul/bvadd terms, typical of automated software model‑checking tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_4_true-unreach-call_true-no-overflow.i_230.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector verification condition generated by Ultimate Automizer from an SV‑COMP 2017 industrial C program (the “true‑unreach‑call”/“no‑overflow” property). It asserts, via two quantified formulas, that no combination of nondeterministic inputs can satisfy a specific linear arithmetic relation that would correspond to an error‑state (e.g., an overflow or prohibited function call). The instance features a small set of quantified variables, moderate term depth (10), and only basic BV operations (addition, multiplication, negation), typical of automated software‑model‑checking tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/verisec_sendmail__tTflag_arr_one_loop_false-unreach-call.i_2400.smt2",
    "description": "This instance is a bit‑vector verification problem generated by Ultimate Automizer from the SV‑COMP 2017 “verisec_sendmail” benchmark (a false‑unreach‑call check).  It encodes a loop that processes decimal characters (values 48–57) using quantified invariants over 8‑bit values and a 32‑bit loop counter i, with the transition i′ = i − 1 expressed via a wrap‑around addition.  The solver must refute a universally quantified safety property, which leads to a single existential check; the formula is moderate in size but contains many zero‑/sign‑extensions, nested arithmetic, and six universal quantifiers, making it a typical industrial BV‑logic verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_6_true-unreach-call_true-no-overflow.i_225.smt2",
    "description": "This instance encodes a software‑verification safety check generated by the Ultimate Automizer tool for an SV‑COMP 2017 benchmark. It works over 32‑bit bit‑vectors and asserts a universally quantified linear relation among program variables and nondeterministic inputs, then negates a conjunction of two such quantified clauses to express a potential violation (e.g., an unreachable call or overflow). The problem is a pure BV verification query with only universal quantifiers, moderate term depth (8) and a handful of arithmetic operations, making it a typical industrial‑style safety‑property instance rather than a synthesis or scheduling problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_253.smt2",
    "description": "This instance encodes a safety‑verification problem for a small numeric program generated by Ultimate Automizer: three 32‑bit variables (x, y, z) are updated in one step by adding large, nondeterministic multiples, and a quantified arithmetic invariant is asserted to be preserved across the step.  The formula consists of three universally‑quantified constraints describing the invariant before the update and a final negated universal clause that asks whether the invariant can be violated after the update, i.e., it checks the unreachability of a bad state.  The problem is in the BV logic, uses only one quantifier block (no alternations) but many quantified variables and multiplications by large constants, giving moderate term depth (≈7) and a typical difficulty for industrial software‑verification benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_70.smt2",
    "description": "This instance is a bit‑vector safety‑verification problem generated by the Ultimate Automizer tool from an SV‑COMP 2017 benchmark. It encodes a single program step where three 32‑bit variables are updated with nondeterministic inputs via linear arithmetic, and then asserts that a certain linear combination of the pre‑state and post‑state variables must stay distinct (i.e., a safety invariant). The query is a negated ∀‑formula over the nondeterministic inputs, so the solver must show that the invariant cannot be violated; the problem involves only nine bit‑vector constants, a handful of quantified variables, and shallow term depth, making it a modest‑size, quantifier‑rich BV verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_6_true-unreach-call_true-no-overflow.i_459.smt2",
    "description": "This instance is a safety‑verification query generated by Ultimate Automizer for an SV‑COMP 2017 benchmark (the “jain_6” program). It asks whether, for all possible 32‑bit nondeterministic inputs, a certain linear combination of the program’s variables can ever equal another combination that would correspond to an error‑call; the formula is expressed with several universally quantified bit‑vector equalities and distinctness constraints using wrapping multiplication by constants close to 2³². The problem is chiefly challenging because it requires reasoning over many quantified bit‑vector terms (34 multiplications, depth 8) rather than sheer variable count.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_1_true-unreach-call_true-no-overflow.i_408.smt2",
    "description": "This instance is a software‑verification query generated by the Ultimate Automizer tool for an SV‑COMP 2017 benchmark (category “industrial”). It encodes a non‑reachability property as a pair of quantified 32‑bit‑vector constraints: one universally quantified invariant stating that a certain linear combination of variables is never zero, and a negated universal (i.e., existential) assertion that would falsify that invariant. The problem involves only a handful of bit‑vector variables and shallow terms (depth ≤ 6) but requires solving quantified BV arithmetic, which is the main source of difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_307.smt2",
    "description": "This instance is a bit‑vector safety‑verification query generated by the Ultimate Automizer tool from an SV‑COMP 2017 benchmark (category “industrial”). It encodes a universal property over several nondeterministic 32‑bit inputs—expressed as distinctness of large‑constant linear combinations of program variables—and then asserts the negation of that property to check for a reachable counter‑example. The formula contains only universal quantifiers (effectively an ∃‑counterexample) with moderate term depth (7), a handful of quantified variables and many 32‑bit multiplications, making it a typical quantified BV verification problem of moderate size.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_469.smt2",
    "description": "This SMT‑LIB file is an industrial software‑verification query generated by the Ultimate Automizer tool from an SV‑COMP 2017 C benchmark. It encodes an unreachability/overflow safety property as a set of universally quantified constraints over 32‑bit bit‑vectors, asserting that two linear expressions involving constant values and nondeterministic inputs can never be equal. The problem involves a few quantified variables, modest term depth (≤ 9), and only basic bit‑vector operations (addition, multiplication by 2, negation), reflecting the typical difficulty of quantifier reasoning in automated verification of bit‑vector programs.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/gcd_3_true-unreach-call_true-no-overflow.i_1105.smt2",
    "description": "This instance encodes a safety‑verification condition for a Euclidean‑algorithm implementation of the GCD function, generated by Ultimate Automizer from an SV‑COMP 2017 benchmark.  In 8‑bit bit‑vector arithmetic it asserts that for a positive input *a* the remainder computed by the loop respects the expected invariants (non‑negativity, divisibility) and then negates this property, turning the query into a “no‑error reachable?” check.  The problem involves a single quantified variable, many sign‑extensions and remainder operations, and a moderate term depth, making it a typical BV‑focused verification task from the industrial benchmark suite.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/sum02_true-unreach-call_true-no-overflow.i_415.smt2",
    "description": "This instance is a software‑verification benchmark generated by Ultimate Automizer for an SV‑COMP 2017 program that computes the triangular sum (∑_{k=0}^{n} k).  The formula is encoded as a loop invariant relating the loop counter i, the bound n, the accumulated sum sn and the closed‑form “Gauss” expression, with several quantified constraints and a final check that sn′ (the sum after one more iteration) can never violate the invariant (i.e., be neither zero nor equal to the Gauss value).  The problem is a quantified bit‑vector safety check (BV logic) with moderate term depth (≈9) and a handful of variables, typical of industrial verification tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_476.smt2",
    "description": "This instance is a quantified bit‑vector safety check generated by the Ultimate Automizer tool from an SV‑COMP 2017 industrial benchmark. It encodes two universally quantified constraints over several 32‑bit program variables and nondeterministic inputs, asserting that two large linear combinations of these values are distinct (i.e., a certain unsafe condition cannot occur) and then negating a similar property to look for a counterexample. The formula involves many constant‑multiplied terms, several quantified variables, and a modest term depth (7), making it a typical quantified BV verification problem with moderate size and arithmetic complexity.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_341.smt2",
    "description": "This SMT‑LIB file is a BV‑logic safety‑verification query generated by Ultimate Automizer from the SV‑COMP 2017 “jain_2” benchmark (category industrial). It encodes a reachability/overflow check for a program fragment: universally quantified nondeterministic 32‑bit inputs are combined with the program’s constants using additions, multiplications by 2 and a negation, and the formula asserts that a particular linear equality can never be satisfied (or, equivalently, that a counter‑example exists). The instance is small (2 declared constants, 2 quantified assertions) but features quantifier alternation and a moderate term depth (9), making it a concise yet quantifier‑rich bit‑vector verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_228.smt2",
    "description": "This instance is a safety‑verification query generated by Ultimate Automizer from an SV‑COMP 2017 benchmark. It encodes, with 32‑bit bit‑vectors, a universally‑quantified arithmetic invariant that must hold for all nondeterministic inputs; the script then asserts the negation of that invariant to ask whether a counterexample exists (i.e., whether a call‑reachability or overflow violation is possible). The problem involves only a handful of quantified variables, linear BV operations (addition, multiplication by 2, negation) and modest term depth, making it a typical bounded‑model‑checking style BV verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_475.smt2",
    "description": "This instance is a bit‑vector safety verification condition generated by Ultimate Automizer for an industrial C benchmark (SV‑COMP 2017, “jain_7”), encoding the unreachability of a particular call. It contains two universally quantified formulas over nondeterministic 32‑bit inputs that relate linear combinations of program variables (via several bvmul and bvadd terms with large constants) and a final negated universal to express the required invariant; the solver must decide whether the conjunction is satisfiable. The problem is modest in size (≈3 KB, term depth 6) but features multiple quantified bit‑vector arithmetic constraints, which can be difficult for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_6_true-unreach-call_true-no-overflow.i_387.smt2",
    "description": "This instance is a bit‑vector software‑verification query generated by the Ultimate Automizer tool from an SV‑COMP 2017 benchmark (category “industrial”). It encodes a safety property of a C program as a set of universally quantified linear equalities/inequalities over three 32‑bit variables and several nondeterministic inputs; the final assertion negates the property, so the solver must determine whether a reachable state can make the two linear expressions equal. The formula contains only a few constants but uses multiple nested `forall` quantifiers and moderate term depth (≈7), making it a quantified BV verification problem rather than a plain SAT/SMT instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_436.smt2",
    "description": "This instance is a software‑verification query generated by the Ultimate Automizer tool from an SV‑COMP 2017 benchmark. It encodes a safety (unreachability) property over 32‑bit arithmetic: the formula asserts that for all choices of auxiliary variables and two nondeterministic inputs a certain linear combination of the program’s global variables cannot equal a specific constant, and then checks the negation of this condition. The problem is a bit‑vector SAT check with two universally quantified blocks and modest term depth (≈10), typical of bounded‑model‑checking style verification tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_464.smt2",
    "description": "This instance is a software‑verification condition produced by Ultimate Automizer for a SV‑COMP “true‑unreach‑call” benchmark. It encodes, with 32‑bit bit‑vectors, the relationship between two program constants and two nondeterministic inputs, asserting that a certain equality (which would correspond to reaching an error state) cannot hold; the overall formula is a conjunction of universally quantified constraints whose negation is checked for unsatisfiability. The problem features only universal quantifiers, moderate term depth (≈11), and a high density of linear bit‑vector operations (adds, multiplies by 2, negations), making it a typical quantifier‑heavy BV verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_1_true-unreach-call_true-no-overflow.i_407.smt2",
    "description": "This instance is a bit‑vector safety‑verification problem generated by Ultimate Automizer from an SV‑COMP 2017 benchmark. It encodes a property that a constant added to twice a nondeterministic 32‑bit value can never become zero, and then asks whether there exists a combination of three such values that violates this condition (the outer `not forall` turns the check into an existential counter‑example search). The formula is small (one declared constant, two quantified assertions, term depth ≤ 7) but contains universally quantified bit‑vector arithmetic, making it a quantified BV‑logic verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_1_true-unreach-call_true-no-overflow.i_409.smt2",
    "description": "This instance is a BV‑logic safety‑verification query generated by Ultimate Automizer from the SV‑COMP 2017 “jain_1” benchmark. It encodes a reachability/overflow property of a 32‑bit program as two quantified assertions about linear combinations of a constant and nondeterministic 32‑bit values, with the overall formula being the negation of a universally‑quantified condition. The problem involves a single bit‑vector constant, a handful of quantified variables, shallow term depth (≤7), but features a quantifier alternation (a negated ∀) that typically makes solving harder for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_6_true-unreach-call_true-no-overflow.i_200.smt2",
    "description": "This instance encodes a safety‑verification condition for a C benchmark from SV‑COMP 2017, generated by the Ultimate Automizer tool. It checks, using 32‑bit bit‑vector arithmetic, that a certain linear invariant (involving the program’s variables and several nondeterministic inputs) never leads to a forbidden state; the property is expressed with a universal quantifier over substitution variables and a negated disjunction that represents the unsafe condition. The formula is modest in size (≈3000 characters, ~20 multiplications, depth 7) but contains quantified bit‑vector arithmetic, which makes it a typical BV‑logic verification task rather than a plain quantifier‑free problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_435.smt2",
    "description": "This instance is a safety‑verification query generated by Ultimate Automizer from an SV‑COMP 2017 benchmark. It works in the 32‑bit bit‑vector logic and asks whether a certain linear arithmetic equality—built from program variables, constant values and two nondeterministic inputs—can ever hold; the formula first asserts the universal property and then asserts its negation, so the solver must show the set of constraints unsatisfiable. The problem features two quantified blocks with moderate term depth (≈10) and only a handful of arithmetic operations, but the combination of universal quantifiers and bit‑vector arithmetic makes it a typical, non‑trivial verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_4_true-unreach-call_true-no-overflow.i_200.smt2",
    "description": "This instance is a bit‑vector safety verification condition produced by Ultimate Automizer for a SV‑COMP 2017 benchmark (the “jain_4” true‑unreach‑call, no‑overflow case). It encodes a Hoare‑style invariant as a universally‑quantified linear arithmetic formula over three 32‑bit program variables and several nondeterministic inputs, and then asserts the negation of the property that the error location (an overflow/invalid call) is unreachable. The check therefore tests whether the quantified invariant guarantees that a specific summed expression can never become zero, involving only a handful of variables but moderate term depth and quantifier nesting.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_4_true-unreach-call_true-no-overflow.i_266.smt2",
    "description": "This instance encodes a safety‑verification problem generated by Ultimate Automizer for the SV‑COMP “jain_4” benchmark. It asks whether, for all 32‑bit nondeterministic inputs, a certain linear combination of the program’s integer variables (involving additions, constant multiplications and a subtraction) can ever satisfy a forbidden equality—essentially checking that an error state (or overflow) is unreachable. The formula uses quantified bit‑vector arithmetic with a moderate term depth (≈10) and a few universal quantifiers, making it a typical industrial‑scale BV verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_4_true-unreach-call_true-no-overflow.i_435.smt2",
    "description": "This instance encodes a safety‑verification problem for a small C benchmark (SV‑COMP 2017) using the Ultimate Automizer tool. The goal is to prove that a certain relation among three 32‑bit program variables (and several nondeterministic inputs) always holds, i.e. that a potential error call is unreachable and no integer overflow can occur. The model consists of two universally‑quantified bit‑vector assertions (one asserted and its negation asserted) over a handful of variables, with moderate term depth (≈10) and no deep quantifier alternations, making it a typical industrial BV‑logic verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/MultCommutative_true-unreach-call_true-no-overflow_true-termination.c_3235.smt2",
    "description": "This instance is a bit‑vector verification problem generated by Ultimate Automizer from an SV‑COMP 2017 benchmark that checks a safety/property of a C program involving multiplication (the “MultCommutative” test). The single assertion encodes that, given a zero input, the computed result must also be zero and enforces a quantified relation expressing the commutativity/consistency of a 2‑times multiplication across function‑call boundaries, while ruling out overflow. Although the formula is small (only two bit‑vector constants and shallow terms), the presence of nested ∀/∃ quantifiers makes it a non‑trivial case for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_433.smt2",
    "description": "This instance is a safety‑verification problem generated by Ultimate Automizer from an SV‑COMP benchmark. It encodes a reachability/overflow check on a small 32‑bit integer program, using two global constants and several quantified nondeterministic variables. The core property asserts that a certain linear combination of the constants and nondeterministic inputs can never be equal; the final negated universal quantifier asks the solver to find a concrete assignment that violates this invariant. The formula lies in the BV logic, features two nested universal quantifiers, a modest number of bit‑vector terms (depth ≤ 10) and moderate arithmetic, making it a typical industrial BV‑verification task with quantifier reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_1_true-unreach-call_true-no-overflow.i_214.smt2",
    "description": "This instance is a bit‑vector safety checking problem generated by the Ultimate Automizer tool for an SV‑COMP 2017 benchmark. It models a simple arithmetic transition (the “primed” variable is set to y + 2·nondet) and adds a universally‑quantified condition that the resulting sum can never equal zero (or, equivalently, that a potential overflow/unreachable state does not occur). The formula contains only three bit‑vector constants, a single forall‑quantifier, and shallow terms (depth ≤ 6), making it a compact but non‑trivial BV‑logic verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_4_true-unreach-call_true-no-overflow.i_342.smt2",
    "description": "The file contains a safety‑verification condition produced by Ultimate Automizer for an SV‑COMP benchmark. It encodes, with 32‑bit bit‑vectors, a universally quantified linear relation (using only addition, multiplication by the constants 4 and 8, and a constant 1) that must hold for all nondeterministic inputs; the script asserts the negation of this property to be unsatisfiable. Thus the instance is a BV‑logic software‑verification task (reachability/ assertion checking) featuring a single forall‑quantifier block and modest term depth, typical of linear arithmetic verification problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_223.smt2",
    "description": "This instance is a software‑verification condition generated by Ultimate Automizer from an SV‑COMP 2017 benchmark; it encodes the absence of a reachable error (or overflow) as a universally quantified bit‑vector formula over two program variables and nondeterministic inputs. The SMT problem asserts that a certain linear combination of these variables can never equal another expression, and then negates this property (combined with a derived substitution rule) to ask whether a counterexample exists. The formula is pure BV, contains only universal quantifiers (turned existential by the outer negation), has modest size (≈2 kB, term depth 11) but non‑trivial arithmetic, making it a typical quantified BV verification query.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/MultCommutative_true-unreach-call_true-no-overflow_true-termination.c_2674.smt2",
    "description": "This instance is a verification query (SV‑COMP 2017 benchmark) generated by Ultimate Automizer for a small C program that checks the commutativity of multiplication (no overflow, termination). It encodes the safety property as a single quantified bit‑vector formula over 32‑bit words, with a mix of universal and existential quantifiers that relate doubled values via multiplication and addition, and asserts a concrete input (zero). The problem is a BV‑logic safety check with modest term depth (8) but non‑trivial quantifier alternation, typical of automated software model‑checking tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_6_true-unreach-call_true-no-overflow.i_433.smt2",
    "description": "This instance is a safety‑verification query generated by Ultimate Automizer for an SV‑COMP 2017 benchmark (the “true‑unreach‑call / true‑no‑overflow” category). It encodes a universal property over several 32‑bit bit‑vectors representing program variables and nondeterministic inputs, and then asserts the negation of that property, so the solver must prove unsatisfiability to show the original safety condition holds. The formula is a quantified BV problem with linear arithmetic expressed via many multiplications and additions (depth 7, a single ∀‑quantifier followed by a negated ∀), making it a typical industrial bit‑vector verification task that can be challenging for solvers due to the combination of quantifiers and extensive arithmetic terms.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/sum02_false-unreach-call_true-no-overflow.c_415.smt2",
    "description": "This instance encodes the verification condition for a simple integer‑summation loop (computing the sum 1 + … n). It asserts the usual loop invariant (the running sum either equals 0 or equals n·(n+1)/2) and the transition relation sn′ = sn + i under the guard i ≤ n, then checks that after one iteration the invariant cannot be violated. The formula contains a single quantified clause over a 32‑bit bit‑vector and several nonlinear arithmetic operations (multiplication and unsigned division), making it a small but non‑trivial BV verification problem generated by Ultimate Automizer from an SV‑COMP benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_61.smt2",
    "description": "This instance encodes a safety‑property verification task generated by Ultimate Automizer from an SV‑COMP 2017 benchmark. It asks whether, for all 32‑bit nondeterministic inputs, a certain linear combination of program variables can ever equal another linear combination; the formula is negated so that the solver must prove the conjunction is unsatisfiable. The problem involves quantified bit‑vector arithmetic with a handful of variables, moderate term depth (≈ 7) and large constant coefficients, making it a typical quantified‑BV verification challenge.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_6_true-unreach-call_true-no-overflow.i_431.smt2",
    "description": "This instance is a safety‑verification query generated by the Ultimate Automizer tool from an SV‑COMP 2017 benchmark.  After translating a C program into 32‑bit bit‑vector arithmetic, the model contains a few global variables and several nondeterministic inputs, and it asks whether a certain linear combination of these values can ever equal a designated “error” term (expressed via a negated universal property).  The problem is thus a true‑unreachability check (no overflow) encoded with two quantified formulas over shallow arithmetic, typical of industrial software‑model‑checking tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_4_true-unreach-call_true-no-overflow.i_461.smt2",
    "description": "This instance is a safety‑verification query for a small C program, generated by Ultimate Automizer from an SV‑COMP 2017 benchmark. It encodes, with 32‑bit bit‑vectors, that a certain arithmetic relation involving the program’s variables **x**, **y**, **z** and three nondeterministic inputs can never hold; the property is expressed as a conjunction of universally‑quantified equalities/inequalities over additions and constant‑factor multiplications (by 4 and 8), finally negated to enforce unreachability. The formula contains a moderate number of quantified variables, depth‑11 terms, and only a few top‑level asserts, representing a typical industrial bit‑vector reachability/overflow check.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_6_true-unreach-call_true-no-overflow.i_340.smt2",
    "description": "This instance encodes a safety‑verification query for a small C benchmark (the “jain_6” program) generated by Ultimate Automizer and taken from the 2017 SV‑COMP industrial category.  It asks whether a universally quantified “distinct” relation between two linear bit‑vector expressions—built from a few 32‑bit variables and large constant multiplications—holds for all nondeterministic inputs; the negated universal quantifier is used to search for a counterexample, i.e., the standard reachability‑/unreach‑call check.  The formula contains only three declared constants but two nested `forall` quantifiers, several `bvmul` with near‑2³² constants, and a modest term depth (6), making it a typical quantifier‑instantiation challenge in the BV logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_4_true-unreach-call_true-no-overflow.i_198.smt2",
    "description": "This instance encodes a safety‑verification query for a small C program, generated by Ultimate Automizer from the SV‑COMP 2017 benchmark suite. The goal is to prove that a certain arithmetic relation among three 32‑bit variables (and three nondeterministic inputs) never leads to a violating condition; this is expressed as a universally quantified bit‑vector formula together with its negation, so the solver must show the property holds for all possible inputs (i.e., the program’s “unreach‑call”/no‑overflow condition). The benchmark features a modest number of constants (three) but employs quantifiers, nested bvadd/bvmul operations with constants 4 and 8, and a term depth of nine, making it a typical quantified BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_342.smt2",
    "description": "This instance encodes a safety‐verification query for a small SV‑COMP benchmark, generated by Ultimate Automizer.  The model consists of a handful of 32‑bit bit‑vector variables (two global constants and several quantified nondeterministic inputs) and asserts, via two universal quantifiers, that a certain affine equality involving only additions, multiplications by the constant 2 and a negation can never hold; the final check‑sat is posed as the negation of this universally quantified condition.  Thus the problem is a quantified BV verification task with modest term depth and a small number of variables, typical of industrial software‑model‑checking benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_383.smt2",
    "description": "This instance is an industrial software‑verification problem generated by Ultimate Automizer from an SV‑COMP 2017 benchmark. It encodes a safety property on 32‑bit variables as two universally quantified formulas that assert the inequality (via `distinct`) of two large linear combinations of program variables and nondeterministic inputs; the second formula is negated to check for a counterexample. The encoding uses only bit‑vector arithmetic (multiplication by constant coefficients and addition), has a shallow term depth (6) and a modest number of quantified variables, but the presence of large constants and quantified `distinct` predicates makes it a non‑trivial BV‑logic verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_250.smt2",
    "description": "This instance is a safety‑verification problem generated by Ultimate Automizer from an SV‑COMP 2017 industrial benchmark (a “true‑unreach‑call, true‑no‑overflow” case). It encodes the transition of three 32‑bit variables (x, y, z) updated by large constant multiples of nondeterministic inputs and then asks whether a universally quantified inequality between two linear bit‑vector expressions (pre‑ and post‑state) can ever be violated – the final `not (forall …)` asserts the negation of the safety property. The formula contains a handful of quantified variables, nested bit‑vector multiplications/additions with large coefficients, and a modest term depth (7), making it a typical quantified bit‑vector verification task with moderate size (≈4 k characters) and no explicit loops or recursion.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/sum02_false-unreach-call_true-no-overflow.i_336.smt2",
    "description": "This BV instance is a safety‑verification condition produced by Ultimate Automizer for an SV‑COMP 2017 industrial benchmark (a “false‑unreach‑call, true‑no‑overflow” task). It encodes arithmetic relations among three 32‑bit constants that correspond to a triangular‑number formula, together with several universally‑quantified constraints over a nondeterministic n, and finally asserts the negation of the intended property. Although the model uses only three concrete bit‑vector variables, the presence of universal quantifiers and nonlinear bit‑vector operations (addition, multiplication, division) makes the formula a non‑trivial quantifier‑instantiation challenge for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_6_true-unreach-call_true-no-overflow.i_434.smt2",
    "description": "This is a software‑verification benchmark automatically generated by Ultimate Automizer from an SV‑COMP 2017 C program.  The query asks whether a certain unsafe state (represented by a linear arithmetic relation over 32‑bit variables x, y, z and several nondeterministic inputs) can be reached; the formula is encoded as a universally quantified safety condition whose negation is asserted.  The problem lives in the BV logic, uses only constant‑multiplied bit‑vector terms (no deep nesting) and a small number of quantified variables, making it a typical industrial unreachability/overflow check with modest size but with quantifier reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_6_true-unreach-call_true-no-overflow.i_58.smt2",
    "description": "This instance encodes a safety‑verification condition for a small C‑style program generated by Ultimate Automizer from the SV‑COMP 2017 benchmark suite.  The model uses 32‑bit bit‑vectors, three nondeterministic inputs and a single transition that linearly updates three state variables; the property to be proved is expressed as a universally quantified “distinct” (inequality) constraint on a linear combination of the pre‑state, and its negation is asserted for the post‑state.  The formula therefore tests whether the transition can violate the invariant, featuring only a handful of variables and modest term depth but requiring quantifier reasoning over bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_4_true-unreach-call_true-no-overflow.i_225.smt2",
    "description": "This instance is a safety‑verification problem generated by the Ultimate Automizer tool from an SV‑COMP 2017 benchmark. It encodes, in 32‑bit bit‑vector arithmetic, a universally quantified relational property over three program variables and several nondeterministic inputs; the property asserts that a certain linear combination of these values can never equal a specific constant (expressed with a wrap‑around addition of 0xFFFFFFFF). The script then negates this universal condition and asks the solver to prove unsatisfiability, thereby proving the absence of the undesired overflow/reachability condition. The formula contains only a single quantifier block, moderate term depth (11), and a handful of arithmetic operations, making it a typical industrial verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/verisec_sendmail__tTflag_arr_one_loop_false-unreach-call.i_1353.smt2",
    "description": "This instance is a bit‑vector safety verification condition generated by the Ultimate Automizer tool from an SV‑COMP 2017 benchmark (the *sendmail* program, false‑unreachability of a call). It encodes the program’s transition (the loop counter is decremented by one) together with quantified arithmetic constraints over 8‑bit “character’’ variables that must stay within the ASCII range 48–57 and satisfy a linear inequality involving repeated multiplication by 10. The solver is asked to refute the negation of the universal condition, i.e., to prove that the unsafe state is unreachable; the problem features several nested `forall` quantifiers, many sign/zero extensions, and moderate term depth (≈14).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_461.smt2",
    "description": "This instance is a safety‑verification problem generated by the Ultimate Automizer tool for a C benchmark from the SV‑COMP 2017 industrial suite. It encodes the unreachability of a program assertion as a universally‑quantified bit‑vector formula over 32‑bit integers, asserting that a certain linear equality (involving additions, multiplications by 2, and a negation) can never hold for any nondeterministic inputs. The model contains only two global constants, a handful of quantified clauses (no quantifier alternation), moderate term depth (≈11) and a modest size, but the presence of several nested universal quantifiers over bit‑vectors makes it a non‑trivial case for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_382.smt2",
    "description": "This instance is a bit‑vector safety‑verification query generated by Ultimate Automizer from an SV‑COMP 2017 benchmark. It encodes, with two quantified formulas, a distinctness condition between two linear combinations of three program variables (treated as 32‑bit bit‑vectors) and several nondeterministic inputs; the final check asks whether the negation of a universal invariant is unsatisfiable, i.e., whether the invariant holds for all possible inputs. The problem features only a handful of variables but includes quantified arithmetic with large constant coefficients, making it a modest‑size but non‑trivial BV‑logic verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/MultCommutative_true-unreach-call_true-no-overflow_true-termination.c_3226.smt2",
    "description": "This industrial BV verification instance was generated by Ultimate Automizer from an SV‑COMP 2017 C benchmark that checks the commutativity (and absence of overflow) of a 32‑bit multiplication routine. The script encodes the functional specification of the multiplication function with a mixture of universal and existential quantifiers, equality and distinct constraints, and a final assertion that the result must be zero under certain input conditions, aiming to prove the property by showing the formula is unsatisfiable. The problem features a modest size (5 bit‑vector constants, a handful of quantified variables) but includes several quantifier alternations and nested arithmetic expressions, giving it a moderate term‑depth and a typical difficulty level for automated BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/gcd_2_true-unreach-call_true-no-overflow.i_921.smt2",
    "description": "The script encodes a safety‑verification problem for a tiny Euclidean‑algorithm implementation of the greatest common divisor.  Using 8‑bit signed bit‑vectors, it describes the loop’s transition (replacing the larger operand by the remainder of the division) and asserts that an error state (where the second argument becomes negative or zero while the input b is still positive) is unreachable.  The instance comes from the SV‑COMP 2017 benchmark suite and was generated by Ultimate Automizer; it features a handful of quantified constraints, sign‑extensions, and remainder/extract operations, giving a modestly deep term structure but only a small number of variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_434.smt2",
    "description": "This instance encodes a safety‑verification task generated by Ultimate Automizer for a C benchmark from SV‑COMP 2017. The goal is to prove that a certain arithmetic condition over 32‑bit integers (expressed with additions, multiplications by 2 and a negation) never holds, which is modeled as a universally‑quantified bit‑vector formula together with its negated counterpart to test for a counterexample. The problem features a modest number of quantified variables and moderate term depth (≈9) but requires reasoning about quantified bit‑vector arithmetic, making it a typical quantified BV verification query.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_259.smt2",
    "description": "This instance is a safety‑verification query generated by the Ultimate Automizer tool for a C benchmark from SV‑COMP 2017. It encodes a reachability/overflow property of a program using 32‑bit bit‑vector arithmetic: three program variables are related by a universally‑quantified linear equation (modeling nondeterministic inputs) and the final assertion states that a certain affine combination of these variables must never be zero. The problem consists of a few quantified constraints with moderate term depth (≤ 8) and a handful of bit‑vector operations, making it a typical industrial bit‑vector verification case.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_230.smt2",
    "description": "The file is a bit‑vector safety‑verification condition produced by Ultimate Automizer for an SV‑COMP benchmark. It encodes that, for all possible 32‑bit nondeterministic inputs, a certain arithmetic relation between two program variables (represented by constant bit‑vectors) cannot hold; the second, negated universal clause asserts the existence of a counter‑example that would violate this relation or cause an overflow, i.e., it checks the unreachability of an error state and the absence of overflow. The query is a BV‑SAT problem with a few quantified variables (two universal quantifiers and a negated universal) and shallow term depth, characteristic of automated software model‑checking instances.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_4_true-unreach-call_true-no-overflow.i_436.smt2",
    "description": "This SMT‑LIB file is a safety‑verification query generated by Ultimate Automizer from an SV‑COMP benchmark. It models a 32‑bit program fragment with three integer variables and several nondeterministic inputs, encoding a candidate invariant as a universally‑quantified bit‑vector equality that relates linear combinations of the variables (multiplications by the constants 4 and 8). The final assertion negates the disjunction “the simple sum of the three variables equals ‑1 or the invariant holds for all substitutions”, so the solver must show the formula is unsatisfiable, i.e., that the program cannot reach the error state. The instance is moderate in size (≈3 KB), uses only one block of universal quantifiers, and has a maximum term depth of 10.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_6_true-unreach-call_true-no-overflow.i_460.smt2",
    "description": "This instance is a BV‑based software verification query generated by Ultimate Automizer from an SV‑COMP 2017 benchmark, checking that a certain program location (an error call) is unreachable and that no arithmetic overflow can occur. The formula consists of several universally quantified arithmetic equalities/inequalities over 32‑bit bit‑vectors, with many nondeterministic variables and constant multiplications, and the final check asserts the negation of a conjunction of such quantified constraints. The presence of multiple quantifier alternations, a moderate term depth (8), and a dense use of bit‑vector multiplications makes the instance a non‑trivial quantified‑BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_1_true-unreach-call_true-no-overflow.i_435.smt2",
    "description": "This is a software‑verification instance generated by Ultimate Automizer from an SV‑COMP 2017 benchmark.  It checks that a linear bit‑vector expression (a constant plus twice a nondeterministic input, possibly summed with other similar terms) can never evaluate to zero – i.e. that a potential overflow or unsafe call is unreachable.  The property is encoded with several universal quantifiers over 32‑bit vectors and the solver is asked to refute the negation, so the problem hinges on quantified BV arithmetic rather than sheer size.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_431.smt2",
    "description": "This instance is an industrial software‑verification query generated by Ultimate Automizer from an SV‑COMP 2017 benchmark. It encodes a reachability proof for a C program: three 32‑bit program variables are related by linear bit‑vector equations with nondeterministic inputs, and the final assertion negates a disjunction stating that a particular linear combination equals zero or that another universally quantified distinctness condition holds. The solver must show the formula is unsatisfiable, i.e., the error state is unreachable. The problem features only a handful of bit‑vector variables but uses many large constants and nested multiplications, giving a moderate term depth (7) and a non‑trivial arithmetic core.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_306.smt2",
    "description": "This instance encodes a safety‑verification check generated by Ultimate Automizer for a SV‑COMP 2017 benchmark. It asks whether a program’s `__VERIFIER_assert` can ever be violated by modeling the program’s integer variables as 32‑bit bit‑vectors and expressing the assertion and the program’s transition relation with a handful of universally quantified constraints over nondeterministic inputs. The formula contains only linear‑arithmetic‐like bit‑vector operations (adds, constant multiplications) and a few quantifiers, making it a typical industrial “true‑unreach‑call” verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsge_bvurem1_32bit.smt2",
    "description": "This instance is a handcrafted quantified bit‑vector verification problem from the Preiner CAV 2018 benchmark suite. It encodes an invertibility condition for the signed‑greater‑or‑equal relation combined with a totalised unsigned remainder: a Boolean predicate **SC(s,t)** is asserted to be equivalent to the existence of a 32‑bit value **x** such that the “safe” remainder of **s** by **x** is signed‑greater‑or‑equal to **t**. The formula negates this bi‑implication and asks the solver to prove unsatisfiability, involving two 32‑bit variables, three auxiliary definitions (totalised division/remainder and min/max constants), and a single existential quantifier, with modest term depth (7) and no quantifier alternation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvuge_bvconcat0_2_64bit.smt2",
    "description": "This crafted BV instance encodes a verification condition for an “invertibility condition” on bit‑vectors: a Boolean predicate SC relates a 2‑bit flag tx to an unsigned comparison between two 64‑bit values s and ts, and the goal is to prove that SC is exactly equivalent to the existence of a 2‑bit prefix x such that the 66‑bit concatenations x‖s and tx‖ts satisfy a unsigned‑greater‑or‑equal (bvuge) test. The single assertion negates this equivalence, turning the problem into checking the unsatisfiability of a quantified formula with two existential quantifiers, concatenation, and bvuge. The benchmark is small (three constants, term depth 7) but features quantifier reasoning over bit‑vectors, which is characteristic of the invertibility‑condition verification study cited in CAV 2018.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_eq_bvmul_64bit.smt2",
    "description": "This instance checks a quantified invertibility condition for 64‑bit multiplication: it defines a bit‑vector predicate SC(s,t) and asserts that the predicate is logically equivalent to the existence of a multiplier x with x · s = t. The task is a verification problem over the BV logic, containing two uninterpreted constants, a few auxiliary total‑division functions (unused), and a single existential quantifier that appears within two implications, giving a modest term depth (7) but requiring quantified reasoning on 64‑bit bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvuge_bvlshr1_64bit.smt2",
    "description": "The file encodes a verification condition on 64‑bit unsigned bit‑vectors: it asks whether the predicate “\\(s \\geq_u t\\)” is equivalent to the existence of a shift amount \\(x\\) such that the logical right‑shift of \\(s\\) by \\(x\\) still satisfies \\( (s \\!\\operatorname{>>}_u\\! x) \\geq_u t\\).  This is expressed as a single quantified assertion with one existentially‑bound 64‑bit variable, together with auxiliary total‑division/remainder definitions and min/max constants.  The benchmark is a handcrafted instance from the CAV 2018 paper on invertibility conditions, featuring a shallow term depth (7) and a modest number of symbols, intended to test BV solvers’ handling of quantified bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvadd_64bit.smt2",
    "description": "This instance encodes a verification condition for an invertibility rule on 64‑bit signed‐less‑than after addition: it asserts that the predicate “t is not the most‑negative value” is equivalent to the existence of an integer x such that x + s is signed‑less‑than t. The formula is a quantified bit‑vector problem (BV logic) with a single existential quantifier, a few auxiliary totalizing definitions, and a shallow term depth (≤ 7). It is a crafted benchmark from the CAV‑2018 paper on quantified bit‑vectors, intended to test solvers’ handling of quantified BV reasoning and edge‑case constants.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvult_bvadd_32bit.smt2",
    "description": "This instance encodes a quantified verification condition over 32‑bit bit‑vectors: it checks whether the simple side‑condition “ t ≠ 0 ” is logically equivalent to the existence of a value x such that x + s < t (unsigned). The formula asserts the negation of the bi‑implication and therefore asks the solver to find a counterexample, exercising both forward and backward implications of an existential quantifier. The problem is crafted for the CAV‑2018 benchmark on invertibility conditions, contains a handful of definitions (total division/reminder, min/max) that are unused, and features only two uninterpreted constants but non‑trivial quantifier reasoning with bit‑vector arithmetic, making it a lightweight yet non‑trivial quantified BV verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvmul_32bit.smt2",
    "description": "This crafted 32‑bit bit‑vector instance encodes a verification condition for an invertibility lemma: it asserts that a signed‑less‑than predicate on two variables \\(s\\) and \\(t\\) is logically equivalent to the existence of a multiplier \\(x\\) such that the signed product \\(x·s\\) exceeds \\(t\\). The formula contains a single quantified existential sub‑formula, several total‑ity definitions for division/remainder, and a mixture of arithmetic and bitwise operations (addition, subtraction, negation, OR, shift). It is a small‑scale BV verification problem (2 constants, depth 7) taken from the CAV‑2018 paper on quantified bit‑vectors, targeting solvers such as Boolector, CVC4, and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_eq_bvshl0_64bit.smt2",
    "description": "The instance encodes a verification task for an invertibility condition of the 64‑bit left‑shift operator: it checks whether the property “shifting a value right by s and then left by s yields the original value” is equivalent to the existence of a pre‑image x such that shifting x left by s produces the target t. This is expressed as a pair of implications involving a single existential quantifier, with a few auxiliary total‑division helpers that are not otherwise used. The problem belongs to the BV logic, is handcrafted (small size, term depth 7), and is intended to be solved by solvers supporting quantified bit‑vectors (e.g., Boolector, CVC4, Z3).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_ne_bvurem1_32bit.smt2",
    "description": "This instance encodes a verification condition for an invertibility property of the 32‑bit unsigned remainder operator (urem).  It asserts that the “non‑zero‑or‑non‑zero” predicate on the two inputs ( SC ) is logically equivalent to the existence of a divisor x such that the totalized remainder of s by x differs from t; the formula is negated to check for a counter‑example.  The benchmark, originating from the CAV‑2018 paper on quantified bit‑vector solving, features a single existential quantifier, a few totalized definitions for division/remainder, and a modest term depth (≤ 7) with only two free bit‑vector variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_ne_bvurem0_32bit.smt2",
    "description": "This instance is a crafted BV‑verification benchmark that checks the correctness of an invertibility condition for the unsigned remainder operation. It introduces totalized versions of division and remainder (guarded by ite to handle divisor 0) and asserts that the simple condition “ s ≠ 1 or t ≠ 0 ” is logically equivalent to the existence of a value x with (uremtotal x s) ≠ t. The formula contains a single existential quantifier, a few ite‑expressions, and moderate term depth, making it a typical quantified bit‑vector problem from the Preiner‑CAV18 suite.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvand_64bit.smt2",
    "description": "This instance is a crafted quantified bit‑vector verification problem that tests an invertibility condition from the CAV‑2018 paper “Solving Quantified Bit‑Vectors using Invertibility Conditions”. It asserts the logical equivalence between a simple signed‑less‑than predicate on two 64‑bit variables and the existence of a 64‑bit witness x such that the signed‑greater‑than of the bitwise‑and `(x & s)` and t holds, i.e., it checks both directions of an implication involving an existential quantifier. The formula contains only two declared constants, a handful of auxiliary definitions, and shallow terms (max depth 7), but the presence of existential quantifiers over bit‑vectors makes it a non‑trivial case for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvuge_bvshl1_32bit.smt2",
    "description": "This instance is a crafted quantified bit‑vector verification problem that checks an invertibility condition for left‑shifts. It defines a predicate SC that is true exactly when shifting a 32‑bit word s by any amount from 0 up to 32 (inclusive) yields a value unsigned‑greater‑or‑equal to a target t, and then asserts the negation of the logical equivalence between SC and the existence of a single shift amount x for which s << x ≥ t. The benchmark contains two free 32‑bit variables, a big disjunction of 33 shift tests, and two quantified existential formulas, making it a modest‑size (≈2 kB) BV problem with moderate term depth and quantifier alternations aimed at testing solvers’ handling of quantified bit‑vector constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_eq_bvneg_32bit.smt2",
    "description": "This crafted BV instance comes from the CAV‑2018 benchmark suite on “invertibility conditions” for quantified bit‑vectors. It encodes a simple verification condition stating that the predicate SC (trivially true) is equivalent to the existence of a 32‑bit value whose two’s‑complement negation equals t, and then asserts the negation of that equivalence, yielding an unsatisfiable formula. The problem features only two 32‑bit constants, a handful of total‑division helper definitions, and a single existential quantifier, resulting in a shallow term depth (≤ 7) but still exercising quantified reasoning in the BV logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvult_bvudiv0_64bit.smt2",
    "description": "This instance is a crafted BV‑logic verification query taken from the CAV‑2018 paper on “invertibility conditions” for bit‑vector operators. It checks the equivalence between the positivity of two 64‑bit operands ( s > 0 ∧ t > 0 ) and the existence of a 64‑bit value x such that the totalised unsigned division udivtotal(x,s) is strictly less than t, encoding the division‑by‑zero case with conditional ITEs. The formula contains a single existential quantifier, a handful of arithmetic operations (including bvudiv), and moderate term depth, making it a small but non‑trivial quantified bit‑vector verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvmul_32bit.smt2",
    "description": "This instance encodes a verification condition for a 32‑bit bit‑vector multiplication: it asserts that a simple predicate on two unsigned numbers `s` and `t` (stating that `t` is smaller than `~s | s`) is equivalent to the existence of a multiplier `x` such that `x * s` is unsigned‑greater‑than `t`. The formula is a crafted, quantified BV problem containing two implications linked by a single existential quantifier, with modest term depth (7) and only two free constants. It is intended to test solvers’ ability to handle quantified bit‑vector reasoning arising from invertibility‑condition generation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvurem1_32bit.smt2",
    "description": "This instance encodes a verification condition for the invertibility of the unsigned remainder operation on 32‑bit bit‑vectors. It defines total‑behaviour versions of division and remainder (guarding against division‑by‑zero), introduces a simple arithmetic predicate SC on two variables s and t, and asserts (negated) the equivalence between SC(s,t) and the existence of a witness x such that the guarded remainder of s by x is signed‑less‑or‑equal to t. The formula is quantifier‑rich (two existential quantifiers) but otherwise small (three definitions, depth 7), targeting standard BV solvers (Boolector, CVC4, Z3) as part of the CAV‑2018 study on quantified bit‑vector invertibility conditions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_eq_bvudiv1_64bit.smt2",
    "description": "This instance encodes a verification task for an invertibility condition of unsigned 64‑bit division: it defines totalised versions of bvudiv (and bvurem) that return a distinguished value on division‑by‑zero, then asserts that the property “\\(s / (s / t) = t\\)” is logically equivalent to the existence of an \\(x\\) satisfying \\(s / x = t\\). The solver is asked to refute the negation of this bi‑implication, i.e., to prove the condition holds for all bit‑vectors \\(s\\) and \\(t\\). The benchmark is a small, crafted BV problem (two 64‑bit constants, a few definitions, one existential quantifier) used in the CAV‑2018 study on quantified bit‑vector invertibility.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvuge_bvurem0_32bit.smt2",
    "description": "This instance is a crafted quantified bit‑vector verification problem originating from the study of invertibility conditions for unsigned remainder ( bvurem ) and division. It asserts that a simple predicate relating two 32‑bit variables—“the unsigned‑greater‑equal of the bitwise‑negated s and t”—is equivalent to the existence of a 32‑bit witness x such that the (totalized) remainder of x by s is also unsigned‑greater‑equal to t; the equivalence is negated to ask for a counterexample. The encoding uses a few auxiliary total functions to avoid division‑by‑zero, contains a single existential quantifier, modest term depth (≤ 7), and targets BV solvers (Boolector, CVC4, Z3).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsge_bvurem0_32bit.smt2",
    "description": "This instance encodes a quantified bit‑vector verification task taken from the “invertibility‑conditions” benchmark suite used in the CAV‑2018 paper on solving quantified bit‑vectors.  It checks that a signed relationship between two 32‑bit variables (the predicate SC) is equivalent to the existence of a witness x such that the signed‑greater‑or‑equal comparison holds between t and the (totalized) unsigned remainder of x modulo s, with special handling of division‑by‑zero.  The formula contains two existential quantifiers, several total‑function definitions for udiv and urem, and a modest term depth, making it a crafted, quantifier‑heavy BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_ne_bvudiv0_32bit.smt2",
    "description": "This instance is a crafted BV‑logic verification query taken from the CAV‑2018 paper on invertibility conditions for quantified bit‑vector operators.  It defines total‑behaviour versions of unsigned division and remainder (guarding against division‑by‑zero) and asserts the negation of the equivalence between a simple side‑condition on the divisor and dividend ( s ≠ 0 ∨ t ≠ −1 ) and the existence of an x such that x ÷ s ≠ t.  In other words, it checks whether the proposed invertibility condition for unsigned division holds for all 32‑bit values.  The problem features only two free constants, one existential quantifier, shallow term depth (≤7), but includes ite‑based total functions, making it a small yet non‑trivial quantified bit‑vector verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvlshr0_64bit.smt2",
    "description": "The instance encodes a verification condition for an invertibility property of the signed right‑shift on 64‑bit bit‑vectors: it states that a simple relation between two variables s and t is equivalent to the existence of a value x whose signed right‑shift by s is bounded by t, and then asserts the negation of this equivalence. The formula uses totalised division/remainder, signed comparisons, and a single existential quantifier in each implication, giving a modest term depth (≈7) but requiring solvers to reason about quantified bit‑vector arithmetic. It is a crafted BV benchmark aimed at testing solvers such as Boolector, CVC4, and Z3 on quantified invertibility conditions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvmul_64bit.smt2",
    "description": "This instance encodes a **verification condition for a quantified bit‑vector property** taken from the “invertibility conditions” benchmark suite (CAV 2018). It defines a predicate SC(s,t) that relates two 64‑bit signed values through a non‑linear expression, and then asserts the negation of the bidirectional implication between SC(s,t) and the existence of a 64‑bit multiplier x such that the signed product x·s exceeds t. The solver must decide whether the equivalence holds for all 64‑bit values of s and t, which involves a single existential quantifier, total‑division helpers, and non‑linear multiplication, making it a challenging quantified‑BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvurem1_32bit.smt2",
    "description": "The instance encodes a verification condition for an invertibility rule over 32‑bit unsigned bit‑vectors: it asserts that the ordering predicate “ t < s ” is equivalent to the existence of a divisor x such that the totalized remainder of s mod x exceeds t.  The formula uses totalized versions of unsigned division and remainder (guarded by ite to handle division‑by‑zero), a single existential quantifier, and simple arithmetic/comparison operators.  It is a crafted quantified‑BV benchmark (BV logic, 32‑bit words) with modest term depth (≤ 7) but requires reasoning about quantified arithmetic and ite‑based total functions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvurem0_64bit.smt2",
    "description": "This instance is a **verification** benchmark for an invertibility condition of the unsigned remainder operation on 64‑bit bit‑vectors. It encodes, with totalized division/remainder functions, the logical equivalence between a simple signed‑less‑than predicate on the operands (the “SC” condition) and the existence of a witness x such that `urem_total(x, s) < t`. The formula contains a single existential quantifier, a few ite‑based totalizations, and a modest term depth (≈7), but the quantifier‑alternation and bit‑vector arithmetic make it a non‑trivial case for solvers like Boolector, CVC4, and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvmul_64bit.smt2",
    "description": "This instance is a crafted BV‑logic verification problem from the CAV‑2018 paper on invertibility conditions for quantified bit‑vectors. It tests whether a specific unsigned‑inequality condition on two 64‑bit variables exactly characterises the existence of a multiplier x such that x·s > t, by asserting the negation of the bi‑implication between the condition and the quantified existence statement. The formula contains only two quantified variables, shallow term depth (≤7), but uses full‑width (64‑bit) arithmetic and conditional definitions for total division/remainder, making it a focused benchmark for solvers’ handling of quantified bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsge_bvudiv1_64bit.smt2",
    "description": "This instance encodes a verification condition for an “invertibility condition” on 64‑bit signed‑greater‑or‑equal ( bvsge ) when the right‑hand side is expressed via unsigned division. It introduces total‑behaviour versions of division and remainder (guarding against division‑by‑zero), defines a predicate SC relating the sign of s to a comparison with t, and then asserts the negation of the equivalence between SC and the existence of an x making udivtotal(s,x) ≥ t. The problem is a crafted quantified BV test (one existential quantifier, two 64‑bit variables, moderate term depth) used to check the correctness of the generated invertibility condition.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvuge_bvconcat0_64_64bit.smt2",
    "description": "The instance encodes a verification condition for an invertibility rule on 64‑bit bit‑vectors involving unsigned concatenation and comparison. It asserts the negation of the equivalence between a simple guard (if tx is all‑ones then s ≥ ts) and the existence of a 64‑bit word x such that the concatenated 128‑bit value x‖s is unsigned‑greater‑or‑equal to tx‖ts. Thus the solver must find a counterexample to this equivalence, featuring only one existential quantifier, a few BV operations (concat, not, shift, uge) and modest term depth, making it a crafted quantified‑BV verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsge_bvmul_64bit.smt2",
    "description": "This instance encodes a verification condition for a signed‑multiplication invertibility property over 64‑bit vectors. It defines a predicate SC(s,t) that relates two bit‑vectors via a signed‑greater‑or‑equal test on a mask, and asserts the negation of the equivalence between SC(s,t) and the existence of an x such that bvmul x s ≥ t (signed). The formula contains a single existential quantifier, a few total‑division helper functions, and shallow term structure (depth 7), making it a crafted quantified‑BV test of a logical equivalence rather than a large‑scale search problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvconcat1_64_64bit.smt2",
    "description": "This instance encodes a tiny quantified bit‑vector verification problem. It defines three 64‑bit constants and a Boolean condition SC that relates them via an unsigned‑greater‑or‑equal test and a distinctness check. The sole assertion asks the solver to refute the equivalence between SC and the existence of a 64‑bit witness x such that the 128‑bit numbers formed by concatenating s with x and ts with tx are in a strict unsigned‑greater‑than relation. Thus the task is to check a quantified invertibility condition for concatenated bit‑vectors, involving only a few variables but featuring existential quantification, concatenation, and arithmetic comparisons over 64‑bit vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvlshr0_64bit.smt2",
    "description": "This instance is a crafted bit‑vector verification problem stemming from the “invertibility conditions” study [1] (CAV 2018). It checks the logical equivalence between a predicate that relates two 64‑bit variables using signed‑less‑than and a logical‑right shift, and the existence of a 64‑bit witness satisfying the same shifted inequality; the negated equivalence is asserted to see if a counter‑example exists. The formula involves a single existential quantifier, several total‑division helpers to avoid division‑by‑zero, and shallow terms (max depth 7), making it a modest‑size quantified BV benchmark that tests solvers’ handling of quantified shift operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvashr1_64bit.smt2",
    "description": "This instance encodes a crafted verification of an invertibility condition for 64‑bit bit‑vectors. It asserts that a predicate relating a signed‑less‑than test and an unsigned‑less‑than test on two variables is logically equivalent to the existence of a shift amount x such that an arithmetic right‑shift of one variable exceeds the other, and then checks the negation of that equivalence. The problem features quantified bit‑vectors (an existential quantifier), arithmetic‑right shift, mixed signed/unsigned comparisons, and a few auxiliary total‑division functions, resulting in a moderate term depth (7) but non‑trivial quantifier reasoning for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvshl1_64bit.smt2",
    "description": "This crafted 64‑bit bit‑vector instance encodes a verification condition from the “invertibility conditions” paper: it asserts that a simple arithmetic predicate (a shifted‑value bound expressed as `SC(s,t)`) is equivalent to the existence of a shift amount `x` satisfying the signed‑less‑than relation `(s << x) <_s t`. The formula negates the bidirectional implication, so the solver must refute the equivalence (or find a counterexample) using a single existential quantifier and basic BV operators (shifts, adds, comparisons). The problem is small (≈30 nodes, depth 7) but involves 64‑bit arithmetic, making it a typical benchmark for quantified BV reasoning in verification contexts.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvudiv0_32bit.smt2",
    "description": "The instance encodes a verification condition for an invertibility rule over 32‑bit unsigned division. It defines totalised versions of `bvudiv` and `bvurem` that return a default value when the divisor is zero, then checks that the predicate “the totalised division of all‑ones by s exceeds t” is equivalent to the existence of some x whose totalised division by s exceeds t. The formula contains a single quantified existential in each implication (no alternations) and is relatively small (depth 7), making it a crafted benchmark for quantifier‑handling in bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvult_bvadd_64bit.smt2",
    "description": "This crafted BV‑logic instance checks a quantified invertibility condition for 64‑bit unsigned addition: it asserts that a non‑zero right‑hand side `t` is equivalent to the existence of an `x` satisfying `x + s < t`. The formula is encoded with a single existential quantifier (no universal quantifiers) together with auxiliary total‑division and total‑remainder definitions that are not used in the core property. It originates from the CAV 2018 benchmark suite on quantified bit‑vectors, featuring modest term depth (7) and a small number of variables, but requires reasoning about unsigned overflow and the existence of solutions to a BV inequality.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvashr0_32bit.smt2",
    "description": "This instance encodes a verification condition for an “invertibility condition” on signed arithmetic right shift: it asks whether the predicate SC(s,t) (a signed‐greater‑or‑equal relation defined via the maximal signed value) is logically equivalent to the existence of a 32‑bit value x such that (bvashr x s) ≤ t. The formula consists of a single quantified existential (over x) inside two implications, with auxiliary total‑division/remainder and min/max definitions, all in quantifier‑free BV logic. It is a small, crafted benchmark (≈30 symbols, term depth 7) intended to test solvers’ handling of quantified bit‑vectors, signed comparisons, and arithmetic shifts.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvlshr0_4bit.smt2",
    "description": "This instance checks a quantified bit‑vector verification condition coming from the “invertibility‑conditions” study of CAV 2018. It asserts that a predicate over two 4‑bit variables (s and t) – expressing a signed‑less‑than relation between t and a shifted version of the maximum value – is logically equivalent to the existence of a 4‑bit witness x such that a signed‑greater‑than holds between the logical‑right‑shift of x by s and t. The formula negates this equivalence, so a solver must either find a counter‑example or prove none exists. The benchmark features a small, handcrafted BV problem with a single existential quantifier, a few total‑division helpers, and modest term depth (7), typical of verification of invertibility conditions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvurem0_32bit.smt2",
    "description": "This instance is a crafted BV‑logic verification query that checks the correctness of an invertibility condition for the unsigned remainder operator. It asserts, in negated form, that a Boolean predicate relating two 32‑bit variables is equivalent to the existence of a third variable making the totalized remainder (which returns the dividend when the divisor is zero) strictly less than the second variable. The problem involves only two universally unconstrained constants, a few auxiliary definitions, and two existential quantifiers, yielding a shallow term depth but requiring quantified bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvconcat1_34_32bit.smt2",
    "description": "This crafted BV instance checks a bidirectional implication between a side‑condition on two 32‑bit signed values and the existence of a 34‑bit witness that makes the signed‑greater‑than comparison of their concatenations hold.  It originates from the CAV‑2018 study on invertibility conditions for quantified bit‑vectors, and features existential quantifiers together with bit‑vector concatenation, signed comparisons, and simple arithmetic/bitwise operators.  The formula is small (three constants, two quantified sub‑formulas) but requires reasoning about mixed‑width concatenations and signed ordering, making it a targeted benchmark for solvers handling quantified bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_ne_bvudiv1_64bit.smt2",
    "description": "This instance encodes a verification condition for the invertibility condition of unsigned 64‑bit division, using a totalised division operator that returns the maximal bit‑vector when the divisor is zero.  The formula asserts (and then negates) that a trivially true predicate on two bit‑vectors is equivalent to the existence of a divisor x for which the totalised division of s by x differs from a given target t, introducing a single existential quantifier over a 64‑bit variable.  It is a small, crafted BV benchmark (≈1 KB, depth 7) meant to test solvers’ handling of quantified bit‑vector arithmetic and division‑by‑zero specialisation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvshl1_32bit.smt2",
    "description": "This instance is a quantified bit‑vector verification problem that checks an invertibility condition for the signed‑less‑than (`bvslt`) relation combined with a left shift (`bvshl`). It asserts the negation of the equivalence between a simple arithmetic condition on the operands (involving the minimum 32‑bit value) and the existence of a shift amount that makes the shifted term signed‑less‑than the second operand. Generated for the CAV‑2018 paper on solving quantified bit‑vectors, the formula uses only 32‑bit vectors, a handful of definitions (total division/remainder, min/max), and two existential quantifiers, yielding a modest term depth (7) but requiring solvers to reason about combined arithmetic, shifts, and quantified existence.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsge_bvudiv0_32bit.smt2",
    "description": "This instance encodes a verification task for an “invertibility condition” on 32‑bit bit‑vectors: it checks whether a simple syntactic condition (SC) on two vectors s and t is equivalent to the quantified statement that there exists an x such that the totalised unsigned division of x by s is signed‑greater‑or‑equal to t. The model uses totalised definitions of division and remainder (guarding against division‑by‑zero) and quantifies only existentially, so the difficulty stems from reasoning about quantified bit‑vector arithmetic with division. The benchmark is a crafted example from the CAV‑2018 paper on solving quantified bit‑vectors via invertibility conditions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_eq_bvlshr0_64bit.smt2",
    "description": "The instance encodes a verification condition for an invertibility property of the 64‑bit logical right‑shift operation. It defines a predicate SC that holds when shifting a value t left by s and then right by s reproduces t, and it asserts that this predicate is not equivalent to the existence of a 64‑bit word x whose logical right‑shift by s equals t. Solving requires checking the (in)equivalence of a quantified bit‑vector formula (a single existential quantifier) against a concrete shift‑based condition, involving only modest term depth but large 64‑bit bit‑vector operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvmul_32bit.smt2",
    "description": "This crafted BV instance encodes a verification condition for an invertibility lemma involving 32‑bit signed multiplication. It asserts that a simple predicate on the operands (¬(s = 0 ∧ t < s)) is equivalent to the existence of a 32‑bit multiplier x satisfying bvmul x s ≤ t, and asks the solver to refute the equivalence. The problem features only two quantified variables, a handful of auxiliary total‑division/‑remainder definitions, and modest term depth (≤7), but requires reasoning about quantified bit‑vectors, signed comparisons, and the edge case of division‑by‑zero.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_eq_bvadd_32bit.smt2",
    "description": "This instance encodes a tiny verification task for the invertibility condition of 32‑bit unsigned addition: it asserts that a (trivially true) predicate SC on two bit‑vectors s and t is equivalent to the existence of an x with x + s = t, and then checks the negation of that equivalence. The formula contains a single existential quantifier (no alternation) and a handful of auxiliary total‑division/remainder definitions that are irrelevant to the core check, resulting in a shallow term depth (≤ 7) and a very small, crafted benchmark aimed at quantifier‑handling in BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvudiv0_32bit.smt2",
    "description": "This instance encodes a verification condition for an “invertibility” rule involving signed‑less‑than (`bvslt`) and unsigned division with a totalised definition that returns a default value on division‑by‑zero.  A predicate **SC** states that for any signed non‑positive bound `t* the division of the minimum signed 32‑bit value by an arbitrary divisor *s* is strictly less than *t*.  The formula asserts the negation of the equivalence between this predicate and the existence of some divisor *x* such that `udivtotal x s` is also strictly less than *t*.  Thus the solver must decide whether the quantified equivalence holds, making the problem a crafted quantified bit‑vector verification case with a few constants, two quantified exists‑bindings, and total‑function handling of division‑by‑zero.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvshl1_64bit.smt2",
    "description": "This instance encodes a quantified bit‑vector verification condition taken from the CAV‑2018 paper on invertibility conditions for quantified BV formulas. It asserts the equivalence between a simple relational predicate on two 64‑bit vectors (expressed via a logical shift‑right bound) and the existence of a 64‑bit shift‑left multiplier that makes the signed‑less‑or‑equal comparison hold, using auxiliary total‑division/remainder definitions to avoid undefined‑behaviour on zero. The problem features a handful of constants and two quantified existential sub‑formulas over 64‑bit bit‑vectors, yielding a modest term depth but requiring solvers to reason about quantified shifts and signed comparisons.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvult_bvurem1_64bit.smt2",
    "description": "This crafted BV instance checks the correctness of an invertibility condition for the unsigned remainder operation on 64‑bit bit‑vectors.  It defines totalized versions of division and remainder (handling division‑by‑zero) and asserts the negation of a bidirectional implication: the condition “t ≠ 0” should be equivalent to the existence of an x such that uremtotal(s,x) < t.  The problem is a quantified‑BV verification task (single existential quantifier, shallow term depth) aimed at proving whether the equivalence holds, and is targeted at solvers like Boolector, CVC4, and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvudiv1_64bit.smt2",
    "description": "This instance encodes a verification condition for an “invertibility condition” on unsigned 64‑bit division: it asserts that the predicate “t is strictly below the maximal unsigned value” is equivalent to the existence of a divisor x making the totalized division of s by x exceed t. The formula contains a single existential quantifier (nested inside two implications) and uses totalized versions of bvudiv/bvurem to avoid division‑by‑zero, with a modest term depth (≤ 7) and only two bit‑vector variables. It is a crafted BV benchmark from the CAV‑2018 paper on quantified bit‑vectors, meant to test solvers’ handling of quantified arithmetic and invertibility reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvashr0_4bit.smt2",
    "description": "This instance encodes a tiny quantified bit‑vector verification problem derived from the “invertibility conditions” study of the paper cited in the metadata.  It works over 4‑bit vectors s and t and asserts that a simple condition on t (being strictly less than the all‑ones value) is equivalent to the existence of an x such that an arithmetic right‑shift of x by s exceeds t; the formula negates the conjunction of the two implication directions, so the solver must show the conjunction is unsatisfiable.  The benchmark is handcrafted, contains only two free constants plus one existential quantifier, a modest term depth (7), and a few auxiliary total‑division definitions that are not otherwise used, making it a small but non‑trivial quantified BV test for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_eq_bvneg_64bit.smt2",
    "description": "This BV‑logic benchmark encodes a verification condition for the invertibility of the 64‑bit bit‑vector negation operator: it asserts that the always‑true invertibility condition (SC) is equivalent to the existence of a value x such that bvneg x equals a given term t, and then checks the negation of this equivalence. The instance, taken from the CAV 2018 paper on quantified bit‑vectors, contains a handful of constants, three auxiliary total‑division/remainder definitions, and a single quantified formula, yielding a very shallow term depth (7) and modest size. It serves as a crafted test of solvers’ ability to handle quantified bit‑vector reasoning (existential quantifiers and simple arithmetic) in the context of invertibility‑condition verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvashr0_64bit.smt2",
    "description": "This crafted BV instance checks an invertibility condition for the arithmetic right‑shift operator combined with an unsigned‑greater‑than test: it asserts that a simple bound on the shift‑target `t` is logically equivalent to the existence of a 64‑bit word `x` such that `(bvashr x s) > t`. The formula contains two uninterpreted 64‑bit constants and a single existential quantifier (no universal quantifiers), with a modest term depth (≤ 7) and a handful of auxiliary total‑division definitions that are not otherwise used. It originates from the CAV‑2018 paper on quantified bit‑vectors and serves as a small but non‑trivial verification benchmark for solvers handling quantified bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvconcat0_64_64bit.smt2",
    "description": "This instance encodes a small verification condition for a quantified bit‑vector invertibility rule: it asserts that a simple Boolean premise ( SC ) is logically equivalent to the existence of a 64‑bit word x that makes the unsigned‑greater‑than comparison of two 128‑bit concatenations true. The formula contains two forward‑and‑backward implications, each guarded by a single existential quantifier over a 64‑bit variable, and the surrounding negation forces the solver to find a counterexample to the equivalence. It is a handcrafted BV‑logic benchmark (64‑bit vectors, moderate term depth 7, only three constants) used for evaluating solvers on quantified bit‑vector reasoning and invertibility‑condition checking.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvudiv1_64bit.smt2",
    "description": "This instance encodes a verification condition for an invertibility rule on 64‑bit bit‑vectors: it asserts that a signed “sign‑check’’ predicate on two variables is equivalent to the existence of a divisor x such that a totalised unsigned division of s by x is signed‑less‑or‑equal to t. The formula is expressed in the BV logic, uses a handful of auxiliary definitions (totalised division/remainder, min/max constants), and contains two existential quantifiers inside implications, yielding a modest term depth (7) but requiring solvers to handle quantified bit‑vector reasoning with division‑by‑zero handling. The benchmark was generated for the CAV‑2018 study on quantified bit‑vectors and targets provers such as Boolector, CVC4, and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_eq_bvudiv0_64bit.smt2",
    "description": "This instance encodes a verification condition for an *invertibility condition* of unsigned division over 64‑bit bit‑vectors. It defines a “total” division that returns a default value on divisor = 0, states the property that multiplying a dividend by its divisor and then dividing yields the original multiplier, and checks whether this property is equivalent to the existence of a value whose total division by the divisor equals the given quotient. The problem is a small, crafted BV query containing a couple of existential quantifiers inside implications and a few ite‑expressions, leading to modest term depth but requiring a solver that can handle quantified bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsge_bvudiv0_64bit.smt2",
    "description": "This instance is a crafted verification problem for quantified bit‑vector arithmetic, originating from the study of invertibility conditions for unsigned division. It encodes a bidirectional implication between a concrete “safe‑division” predicate (involving a totalized division that returns a sentinel value on divisor 0) and the existence of a witness x that makes the same division exceed a bound, using a single existential quantifier and several auxiliary definitions. The formula is small (two 64‑bit variables, a handful of defined functions, term depth 7) but contains quantifier reasoning over bit‑vectors, which challenges solvers’ handling of totalized division and inequality.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsge_bvurem0_64bit.smt2",
    "description": "This instance encodes a verification task for an invertibility condition on 64‑bit signed remainder: it asserts that a simple signed‑range predicate on the divisor `s` is equivalent to the existence of a witness `x` whose (total) unsigned remainder modulo `s` is signed‑greater‑or‑equal to a target `t`. The model uses custom “total” definitions for division and remainder that treat division‑by‑zero specially, and it combines these with an existential quantifier, a few ite‑expressions, and signed/unsigned comparisons. The problem is a crafted BV benchmark with modest term depth (7) but quantifier reasoning, designed to test solvers’ handling of quantified bit‑vector invariants.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvult_bvashr1_64bit.smt2",
    "description": "This crafted BV‑logic instance encodes a verification condition for an invertibility property of the 64‑bit arithmetic right‑shift operator: it asserts that a predicate SC(s,t) (which rules out division‑by‑zero‑like edge cases for s and t) is equivalent to the existence of a shift amount x such that (bvashr s x) is unsigned‑less‑than t. The formula contains two 64‑bit constants, a few total‑division helpers, and a single existential quantifier, yielding a moderate term depth (7) and a typical difficulty for solvers handling quantified bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvurem1_4bit.smt2",
    "description": "This crafted BV‑logic benchmark encodes a verification condition for an invertibility rule: a signed‑greater‑than predicate `SC(s,t)` should be equivalent to the existence of a 4‑bit value `x` for which the totalized unsigned remainder of `s` by `x` is strictly greater than `t`. The instance defines totalized `udiv`/`urem` (handling division‑by‑zero), declares two 4‑bit variables, and asserts the negation of the bi‑implication between `SC(s,t)` and the existential remainder property, thus asking the solver to prove (or refute) this equivalence. It features a single existential quantifier, modest term depth (7), and a small number of variables, making it a concise test of quantified bit‑vector reasoning in solvers such as Boolector, CVC4, and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvudiv1_32bit.smt2",
    "description": "This crafted BV‑logic benchmark checks a quantified invertibility condition taken from the CAV‑2018 paper on solving quantified bit‑vectors. It defines totalized unsigned division (guarding against division‑by‑zero) and asserts the negation of a bidirectional implication that a simple bound on t ( t < 2³²‑1 ) is equivalent to the existence of an x making s ÷ x > t; the goal is to verify that the bound is both necessary and sufficient. The instance contains two free 32‑bit variables, a single existential quantifier, shallow term depth (≤ 7) and no quantifier alternation, making it a lightweight verification query for solvers such as Boolector, CVC4, or Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvlshr0_4bit.smt2",
    "description": "This crafted BV instance encodes a verification condition for an invertibility property of the signed right‑shift operator. It asserts that a simple signed‑greater‑or‑equal relation between two 4‑bit vectors is logically equivalent to the existence of a witness vector satisfying a corresponding shift‑based inequality, and asks the solver to refute the negation of that equivalence. The problem features a few quantified (existential) variables, small‑width bit‑vectors, and modest term depth, but includes conditional total‑division definitions and several ite‑expressions that make the quantified reasoning non‑trivial for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvlshr1_32bit.smt2",
    "description": "This instance encodes a verification condition for an invertibility rule over 32‑bit signed vectors: it asserts that a predicate relating two bit‑vectors `s` and `t` (based on the sign of `s` and a signed‑greater‑than comparison after a logical right shift) is equivalent to the existence of a shift amount `x` that makes `bvlshr(s,x)` strictly greater than `t`. The model checks the negated equivalence, using a single existential quantifier, a few auxiliary total‑division functions and simple Boolean connectives. It is a crafted BV benchmark (≈30 bit‑vector operations, term depth 7) generated for the CAV‑2018 paper on quantified bit‑vector invertibility conditions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvshl0_64bit.smt2",
    "description": "This instance encodes a quantified bit‑vector verification problem taken from the CAV‑2018 paper on invertibility conditions for bit‑vector operators. It asks whether a certain signed‑less‑than condition on two 64‑bit variables is exactly equivalent to the existence of a 64‑bit witness x such that the signed‑greater‑than result of left‑shifting x by s exceeds t. The formula contains a single existential quantifier, a few arithmetic/shift operations, and modest term depth (≈7), making it a crafted benchmark for checking that solvers can handle the subtle interaction between shift‑left and signed comparison.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvshl1_64bit.smt2",
    "description": "This instance is a crafted 64‑bit bit‑vector verification problem that checks an invertibility condition for the unsigned‑greater‑than relation after a left‑shift. It asserts the equivalence between an explicit disjunction of 64 shifted‑by‑constant comparisons (`SC`) and the existence of a shift amount `x` such that `s << x` exceeds `t`. The formula contains two existential quantifiers, a large number of `bvshl`/`bvugt` atoms, and only modest term depth, making it a moderate‑size quantified BV benchmark aimed at solvers like Boolector, CVC4 and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsge_bvashr0_4bit.smt2",
    "description": "This crafted BV‑logic instance encodes a verification condition for an invertibility rule from the CAV‑2018 paper on quantified bit‑vectors: it asserts that a simple predicate built from a logical shift of the maximal 4‑bit value is equivalent to the existence of a 4‑bit witness x satisfying a signed‑greater‑or‑equal relationship after an arithmetic right shift. The formula contains a single existential quantifier, a handful of bit‑vector operations (shifts, signed comparisons, and auxiliary total‑division definitions) and has modest term depth (7) with only two 4‑bit variables, making it a small yet non‑trivial benchmark for solvers handling quantified bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvuge_bvconcat0_34_32bit.smt2",
    "description": "This benchmark encodes a verification condition on quantified bit‑vectors: it asserts that a specific constant‑based ordering condition (SC) is logically equivalent to the existence of a 34‑bit value x such that the concatenation `(concat x s)` is unsigned‑greater‑or‑equal to the concatenation `(concat tx ts)`. The problem tests whether this bi‑implication holds, using a few bit‑vector constants (32‑ and 34‑bit) and simple operators (`bvnot`, `bvlshr`, `bvuge`, `concat`) together with two existential quantifiers. It is a crafted, moderate‑size instance (≈1 KB, depth 7) intended to stress quantified‑BV reasoning in solvers such as Boolector, CVC4, and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvudiv1_64bit.smt2",
    "description": "This instance is a crafted quantified‑bit‑vector verification problem that checks an invertibility condition for unsigned division (with a totalised definition handling division‑by‑zero). It asserts the negation of a bi‑implication between a simple signed‑order predicate on two 64‑bit variables and the existence of a divisor making the totalised division result signed‑less‑than a given bound. The formula contains only two free bit‑vector constants, a single existential quantifier, and shallow term nesting (depth ≤ 7), making it a focused test of solver support for quantified BV reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvashr1_32bit.smt2",
    "description": "This crafted 32‑bit bit‑vector benchmark encodes a verification condition for an “invertibility condition” from the CAV‑2018 paper on quantified bit‑vectors. It asserts the bidirectional implication between a simple signed‑comparison predicate on `s` and `t` and the existence of a witness `x` such that the arithmetic right‑shift of `s` by `x` is signed‑less‑or‑equal to `t`. The instance features totalized division/ remainder helpers, a handful of quantified formulas, and mixed signed/unsigned operations, making it a small but non‑trivial test of quantifier handling in BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_eq_bvurem1_64bit.smt2",
    "description": "The benchmark checks the correctness of an invertibility condition for the unsigned remainder operation on 64‑bit bit‑vectors. It asserts that a specific bit‑vector predicate (relating s and t) is equivalent to the existence of a divisor x such that the totalized bvurem of s by x yields t, and then negates this equivalence. The problem involves quantified bit‑vectors, ite‑defined total functions for division‑by‑zero, and modest term depth, making it a crafted verification task for solvers handling quantified BV reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_eq_bvshl0_32bit.smt2",
    "description": "The benchmark encodes a verification condition for the invertibility of the 32‑bit left‑shift operator. It defines a structural predicate `SC` (shifting right by `s` and then left by `s` recovers `t`) and asserts that `SC(s,t)` is equivalent to the existence of a value `x` with `x << s = t`; the assertion negates this equivalence so that a solver must find a counter‑example. The instance features quantified bit‑vectors (an existential quantifier) and shallow bit‑vector arithmetic (shifts, logical operators), typical of the CAV‑2018 “invertibility conditions” benchmarks and targeted at solvers such as Boolector, CVC4, and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvurem1_32bit.smt2",
    "description": "This instance is a crafted BV‑logic verification query taken from the “invertibility‑conditions” benchmark suite.  It declares two 32‑bit variables `s` and `t` and defines totalised unsigned division/remainder operators that avoid division‑by‑zero.  The single asserted formula negates an equivalence between a sign‑related predicate on `s` and `t` and the existence of a 32‑bit witness `x` such that the totalised remainder of `s` by `x` is signed‑greater‑than `t`.  Hence the solver must decide a quantified bit‑vector property (one existential quantifier inside implications), a typical test of quantifier handling and invertibility reasoning in BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvlshr0_64bit.smt2",
    "description": "This instance encodes a quantified verification condition over 64‑bit bit‑vectors: it asserts that a predicate SC(s,t) (a signed‑less‑than test involving a left‑shift of the maximum value) is equivalent to the existence of a witness x such that the logical‑right shift of x by s is signed‑greater‑than t. The formula is the negation of the conjunction of the two implication directions, so the solver must show whether a counterexample to this equivalence exists. The benchmark is a crafted BV problem (≈30 terms, depth 7) stemming from the “invertibility conditions” study in CAV 2018, featuring a single existential quantifier and a few auxiliary total‑division definitions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_ne_bvudiv0_64bit.smt2",
    "description": "This instance is a crafted quantified bit‑vector verification problem that tests the correctness of an invertibility condition for unsigned 64‑bit division (with a total‑function definition that safely handles division‑by‑zero). It asserts the negation of a bidirectional implication linking a simple side‑condition on the divisor and dividend to the existence of a numerator producing a result different from a given target, thereby searching for a counterexample to the condition. The formula contains two 64‑bit constants, three auxiliary functions, and two existential quantifiers, with a modest term depth (7) and a total of 1314 characters, making it a typical small‑scale benchmark for solvers such as Boolector, CVC4, and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvurem1_64bit.smt2",
    "description": "This instance is a quantified bit‑vector verification problem that checks the equivalence between a signed‑comparison predicate on two 64‑bit variables and the existence of a divisor making the (totalised) unsigned remainder larger than a given bound. It encodes the condition using helper definitions for total division/remainder, min/max constants, and a small quantified formula (one existential over a 64‑bit variable) and then asserts the negation of the two‑way implication, asking the solver to prove it unsatisfiable. The crafted benchmark contains only two free bit‑vector constants, a handful of definitions, and modest term depth, targeting solvers such as Boolector, CVC4, and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvule_bvashr1_64bit.smt2",
    "description": "This instance is a crafted quantified bit‑vector verification problem (64‑bit) that checks the equivalence between a simple range condition on two variables and the existence of an arithmetic‑right‑shift amount making the shifted value bounded by the second variable.  The formula asserts the negation of “(SC s t) ⇔ ∃x·(s >> x) ≤ t”, where **SC** is defined using the minimum and maximum 64‑bit values, and totalised division/remainder functions are provided for completeness.  It contains only two universally free variables, a single existential quantifier, shallow term depth (≤7), and a handful of bit‑vector operations, making it a lightweight benchmark for solvers’ handling of quantified BV invertibility conditions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvconcat1_64_64bit.smt2",
    "description": "This instance is a crafted BV‑logic verification query that checks an invertibility condition for the signed‑greater‑than relation on 128‑bit numbers built by concatenating two 64‑bit vectors. It asserts that a simple signed comparison between the high parts (`s` and `ts`) together with a side‑condition on the low parts (`tx`) is equivalent to the existence of a low‑part witness `x` making the full concatenated values satisfy `(bvsgt (concat s x) (concat ts tx))`. The problem involves quantified bit‑vectors (two existential quantifiers), concatenation, and signed comparisons, but remains small (three 64‑bit constants, depth 7) and is intended to benchmark solvers on the invertibility‑condition technique.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvlshr0_32bit.smt2",
    "description": "This instance encodes a quantified bit‑vector verification problem extracted from the “invertibility conditions” benchmarks of the CAV‑2018 paper by Niemetz et al. It checks, for all 32‑bit words s and t, whether a simple arithmetic condition (t ≥ t >>> s using signed comparison) is logically equivalent to the existence of a 32‑bit witness x such that the signed‑less‑equal relation holds between (x >>> s) and t. The formula is the negation of this equivalence, so the solver must either find a counterexample or prove unsatisfiability. The benchmark features a small, handcrafted model (two free constants, two existential quantifiers, shallow terms of depth 7) but exercises quantified reasoning over signed shifts and comparisons, which can be challenging for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvlshr1_64bit.smt2",
    "description": "This benchmark encodes a verification condition for an invertibility rule of the 64‑bit logical‑right‑shift operator combined with signed greater‑than. It asserts the negation of the equivalence between a sign‑based case analysis on two 64‑bit variables *s* and *t* (the predicate **SC**) and the existence of a shift amount *x* such that *(s >> x) >ₛ t*. The formula uses a single existential quantifier over a 64‑bit bit‑vector, modest term depth (7), and a handful of auxiliary total‑division functions, making it a crafted quantified‑BV instance that tests solvers’ ability to reason about quantified shifts and signed comparisons.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvlshr1_32bit.smt2",
    "description": "This instance encodes a verification condition for an “invertibility condition” of a signed‑less‑or‑equal test involving a logical right shift on 32‑bit vectors. It asserts that a simple predicate on the two free variables (essentially `t` is either below a small constant or not smaller than `s`) is equivalent to the existence of a shift amount `x` making `bvlshr(s,x)` signed‑less‑or‑equal to `t`, and then checks the negation of that equivalence. The benchmark is a crafted quantified BV problem (one existential quantifier, shallow term depth, a few auxiliary total‑division definitions) used for evaluating BV solvers on the invertibility‑condition technique from CAV 2018.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvlshr1_64bit.smt2",
    "description": "This is a crafted BV‑logic verification instance checking an invertibility condition for the logical right‑shift operator. It asserts that the relation “t < s” is equivalent to the existence of a 64‑bit shift amount x such that shifting s right by x yields a value strictly greater than t, and then negates this equivalence to test its validity. The formula contains two 64‑bit constants, a single quantified existential sub‑formula (no universal quantifiers beyond the implicit ones on s and t), and a handful of auxiliary total‑division definitions that are unused, resulting in a shallow term depth (≤ 7) but requiring a solver to handle quantified bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsge_bvashr0_64bit.smt2",
    "description": "The instance encodes a quantified bit‑vector verification problem for 64‑bit signed arithmetic: it defines a predicate SC(s,t) that relates s and t via a signed‑greater‑or‑equal test after a logical right‑shift of the maximal unsigned value, and checks whether this predicate is equivalent to the existence of a value x such that an arithmetic right‑shift of x by s is signed‑greater‑or‑equal to t. The single assertion negates the bidirectional implication, so the solver must prove (or refute) that the invertibility condition for the arithmetic right‑shift holds for all s and t. The problem features a small number of variables but includes an existential quantifier, several defined auxiliary functions, and nested ite and shift operations, making it a crafted benchmark for quantified bit‑vector reasoning as described in the CAV‑2018 paper.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvuge_bvurem1_64bit.smt2",
    "description": "This instance encodes a quantified bit‑vector verification problem from the CAV‑2018 paper on invertibility conditions. It asserts that a handcrafted condition SC(s,t) (involving 64‑bit arithmetic, shifts, and comparisons) is logically equivalent to the existence of a 64‑bit value x such that the total remainder `uremtotal(s,x)` is unsigned‑greater‑or‑equal to t; the formula is negated so the solver must show unsatisfiability to prove the equivalence. The benchmark contains only two free 64‑bit variables, one existentially quantified variable, a handful of defined functions, and a modest term depth (≤7), making it a small but non‑trivial quantified BV benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsge_bvmul_32bit.smt2",
    "description": "This instance is a crafted BV‑logic verification condition that tests the invertibility condition for signed multiplication with respect to signed‑greater‑or‑equal on 32‑bit bit‑vectors. It defines a predicate **SC** using bit‑wise operations and the 32‑bit min/max constants, then asserts the negation of the equivalence between **SC(s,t)** and the existence of a value **x** such that **x · s ≥ₛ t**; thus the solver must find a counterexample to that equivalence. The formula contains a single existential quantifier embedded in arithmetic/bit‑wise expressions (no quantifier alternation) and was generated for the CAV‑2018 “invertibility conditions” benchmark, making it a moderate‑difficulty BV problem that mixes multiplication, signed comparison, and totalized division/remainder definitions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvlshr1_64bit.smt2",
    "description": "The instance encodes a quantified verification condition for 64‑bit bit‑vectors: it asserts that a particular relationship between two variables (a “shift‑compare” condition) is equivalent to the existence of a shift amount x such that a signed‑less‑equal between `s` logically‑right‑shifted by x and `t` holds.  The formula contains two `exists` quantifiers, total‑definition helpers for division/remainder to avoid undefinedness, and a handful of arithmetic and logical operators (shift, signed/unsigned comparisons, ite).  It is a crafted benchmark from the CAV‑2018 paper on invertibility conditions, with modest size (2 constants, depth 7) but the presence of quantified bit‑vectors makes it non‑trivial for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvashr0_64bit.smt2",
    "description": "This instance is a quantified bit‑vector verification problem that checks an invertibility condition for the signed arithmetic‑right‑shift (`bvashr`). It asserts that a simple predicate on two 64‑bit variables `s` and `t` (whether the shift of a constant is signed‑less‑than `t`) is equivalent to the existence of some 64‑bit `x` making the shifted value of `x` signed‑less‑than `t`; the formula is negated, so the solver must either find a counterexample or prove the equivalence holds. The benchmark features only a few variables but includes existential quantification, signed comparisons, and shift/bitwise operations, making it a crafted test of quantifier reasoning in the BV logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_eq_bvmul_32bit.smt2",
    "description": "This instance is a crafted quantified bit‑vector verification problem (BV, 32‑bit) that checks an invertibility condition for multiplication. It encodes a logical equivalence between a structural condition on two 32‑bit words `s` and `t` and the existence of a word `x` such that `x * s = t`. The formula asserts the negation of this equivalence, so the solver must determine whether a counterexample exists. The benchmark contains only two constants, a handful of defined helper functions, and a single existential quantifier, giving a modest term depth (≤7) but still exercising quantifier reasoning over bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvashr1_64bit.smt2",
    "description": "This instance is a crafted 64‑bit bit‑vector verification problem that tests an invertibility condition for the arithmetic right‑shift operation. It asserts that a simple signed‑order predicate between two variables is equivalent to the existence of a shift amount that makes the shifted value satisfy the same predicate, and checks the negation of this equivalence. The benchmark contains only two free constants, a single existential quantifier, and a few auxiliary total‑division definitions, making it a small but non‑trivial quantified BV query aimed at evaluating solvers’ handling of quantified arithmetic reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvand_32bit.smt2",
    "description": "This instance encodes a quantified verification condition for 32‑bit bit‑vectors: it defines a predicate **SC** that relates two constants s and t, and asks whether **SC(s,t)** is logically equivalent to the existence of a bit‑vector x such that the signed‑greater‑than comparison `(x & s) > t` holds. The formula asserts the negation of the bi‑implication, so the solver must decide whether the equivalence is true (unsat) or a counterexample exists (sat). It is a crafted benchmark from the CAV‑2018 paper on invertibility conditions, featuring a single existential quantifier, a handful of bit‑vector operations (and, shift, not) and shallow term depth, but still challenging for BV solvers because of the quantified signed‑comparison.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvconcat0_2_64bit.smt2",
    "description": "The instance is a crafted BV‑logic verification problem that tests an equivalence between a concrete condition on two 64‑bit vectors and an existential “invertibility” condition involving a 2‑bit prefix concatenated to them. It encodes a bidirectional implication (↔) between a simple unsigned‑greater check on s and ts (guarded by a 2‑bit flag tx) and the existence of a 2‑bit vector x that makes the concatenated 66‑bit numbers satisfy the same unsigned‑greater relation. The formula contains only three declared constants and two existential quantifiers, with shallow term depth (≤ 7), but the presence of quantified bit‑vectors, concatenation, and unsigned‑greater predicates makes it a non‑trivial benchmark for solvers handling quantified BV constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvule_bvashr1_32bit.smt2",
    "description": "This BV‑logic instance encodes a verification condition for an invertibility property of the arithmetic right‑shift operator under unsigned ≤. It asserts that a simple range predicate on two 32‑bit variables \\(s\\) and \\(t\\) is equivalent to the existence of a 32‑bit shift amount \\(x\\) such that \\(\\text{bvashr}(s,x) \\le_u t\\). The formula contains a single existential quantifier, a handful of auxiliary total‑division/remainder functions and min/max constants, and has modest term depth (7) but exercises quantified bit‑vector reasoning that challenges solvers like Boolector, CVC4 and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_ne_bvurem0_64bit.smt2",
    "description": "This instance encodes a verification condition for an invertibility property of the unsigned remainder operation on 64‑bit bit‑vectors. It asserts that a simple safety predicate on two free bit‑vectors \\(s\\) and \\(t\\) is equivalent to the existence of a witness \\(x\\) such that the totalized remainder of \\(x\\) by \\(s\\) differs from \\(t\\); the formula is negated to ask the solver to find a counter‑example. The problem involves a single existential quantifier, a few ite‑based total‑functions (to handle division‑by‑zero), and modest term depth, making it a small but non‑trivial quantified BV verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsge_bvshl0_32bit.smt2",
    "description": "This instance is a crafted quantified‑bit‑vector verification problem taken from the CAV‑2018 study on invertibility conditions for bit‑vector operators. It encodes a bidirectional implication between a syntactic sufficient condition (involving a signed‑greater‑or‑equal test on a left‑shifted maximal value) and the existence of a 32‑bit value x that makes the same signed greater‑or‑equal shift‑left inequality hold, then asserts the negation of that equivalence. The formula features a small number of constants and variables but includes two existential quantifiers, signed comparisons, shifts, and totalised division/remainder definitions, giving solvers a modest‑depth (7) quantified BV challenge.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvuge_bvshl1_64bit.smt2",
    "description": "This instance encodes a verification condition for the invertibility of the left‑shift operation under unsigned‑greater‑or‑equal: it defines a predicate that is true iff *some* concrete shift amount (0…64) makes `s << k` ≥ `t`, and checks that this predicate is equivalent to the existential statement “there exists a bit‑vector x such that `s << x` ≥ `t`”. The problem is a single quantified (`exists`) bit‑vector formula over 64‑bit variables, featuring a huge disjunction of 67 shifted terms, and thus belongs to the crafted quantified‑BV verification category.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvconcat1_62_4bit.smt2",
    "description": "This instance is a crafted quantified‑BV verification problem taken from the “invertibility‑condition” benchmarks used in the CAV‑2018 paper on solving quantified bit‑vectors. It asks whether a small signed‑comparison condition on two 4‑bit vectors (together with a side‑condition on a 62‑bit constant) is exactly equivalent to the existence of a 62‑bit suffix that makes the signed‑greater‑than comparison of the two 66‑bit concatenations hold. The formula contains only existential quantifiers (no alternation), uses concat, signed comparisons, and a few bit‑wise operations, making it a compact but non‑trivial test of solvers’ handling of quantified bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvurem0_4bit.smt2",
    "description": "This crafted BV instance originates from the CAV‑2018 paper on invertibility conditions for quantified bit‑vectors. It verifies that a derived condition SC(s,t) exactly characterises the existence of an x such that the totalised unsigned remainder of x by s is signed‑less‑than t, using a 4‑bit arithmetic model with explicit handling of division‑by‑zero. The query contains a single existential quantifier, several ite‑based totalizations, and moderate term depth, providing a small but non‑trivial benchmark for solvers handling quantified bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvurem0_32bit.smt2",
    "description": "This instance encodes a small verification condition over 32‑bit bit‑vectors. It defines totalised unsigned‑division and remainder operators (guarding against division‑by‑zero) and a predicate **SC** that relates two bit‑vectors *s* and *t* through signed‑greater/less comparisons and a few constant bounds. The single asserted formula checks the logical equivalence between **SC(s,t)** and the existence of a witness *x* such that the totalised remainder of *x* by *s* is signed‑greater than *t*; the outer negation asks the solver to find a counter‑example. The problem is a crafted BV verification benchmark (from the CAV‑2018 paper on invertibility conditions) featuring a modest term depth (7) and two existential quantifiers but no universal quantifiers, making it a focused yet non‑trivial test for quantified‑BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvudiv0_64bit.smt2",
    "description": "This instance encodes a verification condition for an “invertibility” property of unsigned division on 64‑bit bit‑vectors.  A totalized division is defined (returning a special value when the divisor is zero) and a predicate SC (s,t) states that this division of the maximal value by s exceeds t; the formula checks that SC (s,t) is equivalent to the existence of some x with the same property, i.e., it asserts the correctness of the invertibility condition.  The problem is a crafted quantified bit‑vector verification task involving a few existential quantifiers over 64‑bit terms, moderate term depth (7) and a small number of variables, intended to test solvers’ handling of quantified BV reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvmul_32bit.smt2",
    "description": "This crafted BV benchmark encodes a verification condition from the “invertibility‑conditions” framework: it asserts that a specialised signed‑less‑than predicate SC(s,t) is equivalent to the existence of a 32‑bit value x satisfying bvmul x s < t. The formula contains a single existential quantifier over a bit‑vector and several arithmetic/bitwise operations (signed multiplication, signed comparison, and a total‑division/‑remainder definition), making it a quantified bit‑vector verification problem designed to stress solvers’ handling of quantified arithmetic and invertibility reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvmul_64bit.smt2",
    "description": "This instance encodes a crafted verification condition for a 64‑bit signed multiplication inequality. It defines a predicate SC(s,t) that is true unless both s is zero and t is strictly less than s, and then asserts that SC(s,t) is logically equivalent to the existence of a 64‑bit value x satisfying bvmul x s ≤ t. The single top‑level assertion negates this equivalence, so the solver must prove the formula unsatisfiable. The problem features quantified bit‑vectors with multiplication and signed comparisons, a modest term depth (7) and only two free variables, making it a typical benchmark for invertibility‑condition reasoning in quantified BV logics.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvadd_32bit.smt2",
    "description": "This crafted BV instance encodes a verification condition for an invertibility rule: it checks whether the predicate “ t is not the minimum signed 32‑bit value ” (the definition of SC) is logically equivalent to the existence of a signed 32‑bit x satisfying (bvadd x s) <ₛ t. The formula negates the bi‑implication of the two implications, so the solver must determine if the equivalence holds for all 32‑bit values of s and t. The problem involves only two universally quantified constants, a single existential quantifier, a few auxiliary total‑division/‑remainder definitions, and modest term depth (≤ 7), making it a focused quantified‑bit‑vector verification task derived from the CAV 2018 study on invertibility conditions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvurem1_64bit.smt2",
    "description": "This crafted BV instance encodes a verification condition from the “invertibility‑conditions” study (CAV 2018). It checks whether a simple signed‑less‑than predicate on two 64‑bit variables is equivalent to the existence of a witness‑value x such that the (totalised) unsigned remainder of the first variable by x is signed‑less‑than the second variable. The formula involves a single quantified existential sub‑term, a handful of bit‑vector operations (division, remainder, shifts) and a modest term depth, making it a small yet non‑trivial quantified‑BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvult_bvashr0_32bit.smt2",
    "description": "This instance encodes a *verification* problem for a quantified bit‑vector property: it checks whether the condition “the bound t is non‑zero” is equivalent to the existence of a 32‑bit value x whose arithmetic right‑shift by s is unsigned‑less‑than t. The formula asserts the negation of this equivalence, thus asking the solver to find a counterexample. It involves a single existential quantifier over a 32‑bit vector, arithmetic‑right‑shift and unsigned‑less‑than, with a modest term depth (≈7) and a few auxiliary total‑division definitions that are not otherwise used.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvconcat0_62_4bit.smt2",
    "description": "This instance is a crafted BV‑logic verification problem taken from the “invertibility conditions” study (CAV 2018). It checks the equivalence between a simple Boolean condition on two 4‑bit vectors (and a 62‑bit “all‑ones” vector) and the existence of a 62‑bit witness that makes the concatenation of that witness with a 4‑bit vector larger (unsigned) than the concatenation of a fixed 62‑bit constant with another 4‑bit vector. The formula contains a single existential quantifier, bit‑vector concatenations, and unsigned‑greater‑than comparisons, aiming to confirm that the derived invertibility condition is both necessary and sufficient.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/AR-fixpoint-4.smt2",
    "description": "This instance encodes a hardware fix‑point verification problem as a quantified bit‑vector formula: a five‑step sequence of state updates (variables a and b) is universally quantified, while an existentially quantified copy of the same sequence represents a candidate loop‑invariant state. The formula asserts that, starting from the concrete initial values (a = 1, b = 0) and applying the guarded addition updates, the fifth state must coincide with one of the earlier existential states, i.e., a fix‑point is reached. It originates from the VCEGAR benchmark suite (Wintersteiger et al. 2013) and features a large 2501‑bit width, ten universal and eight existential quantifiers, and deep ite‑nested terms (depth 26), making it a challenging industrial benchmark for quantified BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/small-equiv-fixpoint-4.smt2",
    "description": "This instance encodes an industrial hardware‑verification problem: it asserts a fixpoint/equivalence property of a pipelined division‑remainder circuit over 8‑bit bit‑vectors. The formula quantifies universally over five consecutive pipeline states and existentially over a possible later state, then checks that the final stage’s remainder and quotient either match one of the earlier stages after an extra iteration of the same arithmetic (remainder = a mod b, quotient = a – (b·(a / b))). The benchmark features deep (depth ≈ 44) nested quantifiers (20 ∀, 16 ∃) and many arithmetic operations, making it a demanding quantified‑BV fixpoint‑checking instance from the Wintersteiger/VCEGAR hardware suite.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/small-pipeline-fixpoint-6.smt2",
    "description": "This instance encodes an industrial hardware‑verification problem from the VCEGAR benchmark suite: a small six‑stage pipeline is modelled as a sequence of 32‑bit registers (data, stage values, temporaries) with a Boolean reset signal, and the formula asks whether the system can reach a fixpoint where the state after the sixth step repeats any earlier state.  The property is expressed with a deep alternation of 59 universal quantifiers (one for each step of the pipeline) followed by 50 existential quantifiers for a candidate “loop” state, using arithmetic (bvadd), bitwise (bvand) and conditional (ite) operations, resulting in a term depth of 116 and nearly 100 bit‑vector variables.  Such a heavily quantified, high‑depth BV formula is characteristic of the fixpoint checks studied in Wintersteiger et al.’s 2013 work on efficiently solving quantified bit‑vector formulas.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/AR-fixpoint-9.smt2",
    "description": "This benchmark is an industrial hardware‑fixpoint verification problem taken from the VCEGAR suite (Wintersteiger et al., FMSD 2013). It encodes a nine‑step loop that updates two 2501‑bit counters with a conditional “add‑until‑100” rule, and asserts that after the ninth iteration the universal state must coincide with one of a set of existentially guessed earlier states. The formula features a single ∀∃ quantifier alternation (20 universally‑quantified and 18 existentially‑quantified bit‑vectors), deep nesting of ite, bvadd and bvult terms (max depth ≈ 46), and an exceptionally large bit‑vector size, all of which contribute to its solving difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/small-equiv-fixpoint-10.smt2",
    "description": "This instance encodes an industrial hardware‑verification fixpoint check for an 8‑bit division/modulus circuit. It asserts that for every possible sequence of 11 clock‑cycle states (captured by a block of 44 universally‑quantified variables) the circuit’s arithmetic relations hold, and then asks whether there exists a previously‑seen state (the 40 existential variables) such that the 10‑th state is identical to one of the earlier states—i.e., a loop or fixpoint exists. The formula features deep (≈92) terms, many quantified bit‑vectors (84), and a large alternation of ∀…∃ quantifiers, making it a challenging quantified‑BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/itc-b13-fixpoint-6.smt2",
    "description": "This benchmark is a **hardware fix‑point verification** problem taken from the VCEGAR suite (Wintersteiger et al., FMSD 2013).  The formula encodes a sequential Verilog model of a serial‑interface controller over seven pipeline stages (indexed 0…6); a universal quantifier enumerates the whole state‑transition chain while an existential block pins the initial round‑0 variables, and the final assertion requires the round‑6 state to be identical to the round‑0 state (a classic fix‑point/induction check).  The instance lives in the BV logic, features a very deep term nesting (depth ≈ 364), thousands of ite‑ and =‑terms and dozens of quantified Boolean and bit‑vector variables, making it a heavyweight industrial case that stresses solvers’ handling of large quantified bit‑vector formulas and deep symbolic unfolding.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/small-equiv-fixpoint-7.smt2",
    "description": "This benchmark encodes a hardware fix‑point verification problem in the bit‑vector logic: a simple divider circuit (computing a mod b and the corresponding subtraction) is instantiated for eight successive clock cycles, and the formula asserts that the state reached after the 8th cycle must coincide with at least one of the states from the first seven cycles.  The property is expressed as a deep quantified formula with 32 universal variables (the concrete states of the eight cycles) followed by 28 existential variables (a candidate repeating state), yielding a single large conjunctive constraint with many nested ∀/∃ alternations and a term depth of 68.  The instance therefore tests a solver’s ability to handle quantified bit‑vector arithmetic, especially remainder/division operations, in an industrial‑scale fix‑point setting.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/small-pipeline-fixpoint-8.smt2",
    "description": "This benchmark encodes a hardware fix‑point check: an 8‑stage pipeline is modelled with 32‑bit registers (`stageOne`, `stageTwo`, `dataOut`, temporary copies) and a reset flag, and the SMT‑LIB formula asserts that for **all** possible sequences of inputs, constants and resets over eight clock cycles there must exist a state after the eighth cycle that repeats one of the previous seven states (i.e., the pipeline reaches a loop).  It is a quantified bit‑vector verification problem taken from the Wintersteiger/HC‑VCEGAR suite, featuring a deep term structure (depth ≈ 152) and a large alternation of quantifiers (≈ 77 ∀ and 68 ∃) over more than a hundred bit‑vector variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/itc-b13-fixpoint-8.smt2",
    "description": "This benchmark encodes a hardware fix‑point verification problem taken from a Verilog‑style interface (the “itfc” module).  The formula quantifies universally over the entire state vector (≈ 370 Boolean and bit‑vector signals for nine pipeline stages) and then existentially instantiates an initial configuration; the body forces the next‑state transition function (expressed as a massive nest of `ite`‑terms) to hold for each cycle and finally asserts that after nine steps the system returns to the same state, i.e. an inductive invariant/fix‑point condition.  The instance is industrial‑scale, with many quantified variables, deep term nesting (depth ≈ 470) and alternating `forall`/`exists`, making it a difficult case for quantified‑BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/ethernet-fixpoint-3.smt2",
    "description": "This instance encodes an industrial‑grade hardware fixpoint verification problem (the “ethernet‑fixpoint‑3” benchmark from the Wintersteiger/VCEGAR suite).  It checks that a detailed Ethernet‑style protocol model—comprising request/acknowledge logic, frame‑receiver (FR0/FR1), back‑off timers (FT0/FT1), bit‑transfer modules (BT0/BT1), and channel signals—satisfies its safety/invariant properties across multiple time steps, using a single ∀‑quantified assertion that quantifies over all Boolean and bit‑vector state variables.  The formula is a huge quantified BV problem (≈ 435 k characters, 1034 term depth) with many nested ite/zero‑extend expressions, hundreds of quantified variables and alternating ∀/∃ blocks, making it a challenging case for solvers handling deep quantifier alternations and large bit‑vector arithmetics.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/sdlx-fixpoint-10.smt2",
    "description": "This benchmark encodes a hardware fix‑point verification problem for a Verilog pipeline.  The SMT‑LIB file contains a single quantified assertion that universally quantifies over a 10‑step execution trace (states, control signals, and monitor flags), defines the transition relation with massive nested ite and extract operations, and finally asserts the existence of a concrete initial configuration that violates the intended invariant.  The instance is industrial‑scale, featuring thousands of quantified Boolean and bit‑vector terms, deep nesting (term depth ≈ 688) and many alternating forall/exists quantifiers, making it a hard quantified‑BV verification challenge.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/cache-coherence-2-fixpoint-6.smt2",
    "description": "This instance encodes an industrial hardware‑verification task: a fixpoint proof for a two‑cache coherence protocol (including a bus arbiter) taken from the VCEGAR benchmark suite used in Wintersteiger et al.’s study of quantified bit‑vector solving. The formula is a single universally‑quantified block over all input signals followed by an existential block for the next‑state variables, and asserts that the transition relation preserves a set of integrity invariants (e.g., coherence, sharers tracking, and memory‑service conditions). Solving is made difficult by the massive quantifier alternation (≈ 714 ∀, 612 ∃), a deep term nesting depth of 1344, and a huge number of ite, bit‑vector extracts, and concatenations (over 4 × 10⁵ symbols), which together create a highly complex quantified BV problem.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/small-pipeline-fixpoint-9.smt2",
    "description": "This benchmark encodes a hardware‑pipeline fixpoint verification problem taken from the VCEGAR suite (Wintersteiger et al., FMSD 2013).  It asserts that, for every possible execution of a 10‑stage pipeline described with 32‑bit registers, additions, bitwise‑ands and resets, there exists a later (39‑step) state that repeats one of the earlier pipeline states – i.e., the system reaches a loop.  The formula is heavily quantified (86 universal and 77 existential quantifiers), involves over a hundred bit‑vector variables, and features deep term nesting (depth ≈ 170), making it a challenging instance for quantified BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/sdlx-fixpoint-6.smt2",
    "description": "This benchmark encodes a hardware fix‑point verification problem for a small MIPS‑style processor pipeline (states, control signals, register‑file and ALU logic).  The SMT‑LIB file consists of a massive universally‑quantified transition relation (six unfolding steps of the pipeline) followed by an existential block that fixes the initial state to all‑zero values and asserts that the resulting reachable state satisfies a safety condition.  The formula is pure bit‑vector with many extracts, ite‑terms and deep nesting (max term depth ≈ 432) and a long alternation of ∀/∃ quantifiers, making it a challenging industrial‑scale verification instance.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/AR-fixpoint-10.smt2",
    "description": "This benchmark encodes a hardware fix‑point verification problem: a pair of 2501‑bit registers a and b evolve through ten deterministic update steps, and the formula asserts that the 10‑th state must coincide with one of the possible “next‑state’’ candidates introduced by existentially quantified copies of the same transition. The property is expressed with a deep alternating ∀‑∃ quantifier pattern (22 universal and 20 existential variables), many ite, bvadd and bvult terms, and a term‑depth of 50, placing it among the challenging quantified‑BV instances from the Wintersteiger/FMSD13 industrial suite.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/small-pipeline-fixpoint-5.smt2",
    "description": "This benchmark encodes a hardware fix‑point verification problem taken from the VCEGAR suite (Wintersteiger et al., 2013). It models a 5‑cycle pipeline of 32‑bit registers (stageOne, stageTwo, temporaries, dataIn/Out, reset, constants) and asserts that for every possible execution trace there exists a later state that repeats one of the previous five states, i.e., the pipeline reaches a fixpoint/loop. The formula is a heavily quantified BV problem (≈50 nested ∀‑quantifiers followed by ≈41 ∃‑quantifiers), with 82 distinct 32‑bit variables, deep term nesting (depth ≈ 98) and a large number of bit‑vector operations, making it a challenging industrial verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/AR-fixpoint-7.smt2",
    "description": "The file encodes a hardware fix‑point verification task: a sequence of eight state updates on a 2501‑bit vector is described using a deterministic recurrence (add the previous “b” to “a” while “a” < 100, otherwise keep “a”), starting from the concrete initial values a = 1, b = 0. The formula universally quantifies over the eight forward states and existentially quantifies over a second copy of the same eight‑step trace, then asserts that the final state of the first trace must coincide with *some* earlier state of the second trace (i.e., a fix‑point/repetition is reached).\n\nThe benchmark comes from the Wintersteiger hardware‑model suite (VCEGAR) and is an industrial quantified‑BV instance featuring a very large bit‑width, deep term nesting (depth ≈ 38) and a long alternation of 16 universal and 14 existential quantifiers, making it a challenging case for solvers that handle quantified bit‑vector formulas.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/small-equiv-fixpoint-9.smt2",
    "description": "This benchmark encodes a hardware fix‑point verification problem: a 8‑bit division/remainder circuit is unrolled for ten steps and the formula requires that the state after the ninth step repeats one of the earlier states (captured by an existential “loop‑back” clause).  It is expressed in pure bit‑vector logic with a deep term structure (max depth 84) and a heavy quantifier alternation pattern (40 universal and 36 existential quantifiers over 76 BV variables).  Consequently it represents a challenging industrial fix‑point equivalence check for quantifier‑heavy BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/itc-b13-fixpoint-7.smt2",
    "description": "This benchmark is an industrial hardware‑verification problem (Wintersteiger et al., FMSD 13) expressed as a quantified bit‑vector formula in the BV logic. It models the step‑wise behaviour of a Verilog serial‑interface controller (send en, tx end, registers, state‑machine bits, etc.) over eight clock cycles and asks whether, for **all** possible initial valuations of the controller’s signals, there **exists** a sequence of transitions that leads back to the reset state (all control flags false and registers zero). The instance features deep term nesting (≈ 400 levels) and a heavy alternation of ∀/∃ quantifiers together with thousands of ite‑expressions, making it a challenging fixpoint/reachability check for SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/small-equiv-fixpoint-6.smt2",
    "description": "This instance encodes a hardware fix‑point/equivalence check: a 8‑bit datapath is iterated seven times (states 0…6) using the same arithmetic transition (remainder, division, multiplication and subtraction), and the formula asserts that the sixth state must be identical to at least one of the earlier five states.  The property is expressed as a single quantified bit‑vector formula with a long quantifier prefix (28 universal variables for the concrete steps followed by 24 existential “candidate” variables) and a deep term structure (depth ≈ 60).  Consequently the benchmark tests solvers on a dense, industrial‑style BV problem with many variables, multiple quantifier alternations, and non‑linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/usb-phy-fixpoint-4.smt2",
    "description": "This benchmark encodes a **hardware fix‑point verification** problem taken from the USB‑PHY model used in the Wintersteiger et al. evaluation (the VCEGAR suite).  It asserts, with a huge nested universal quantifier, that the transmitter and receiver state‑machines of a USB PHY preserve their intended functional invariants (reset handling, state‑transition logic, bit‑stuffing, NRZI encoding, etc.) over several clock cycles, and then looks for a violating assignment via an inner existential block.  The instance is a pure BV formula (logic BV) with very deep quantifier alternation (≈530 ∀, ≈424 ∃), a maximal term depth of 972 and more than 1 700 equalities/ite’s, making it a challenging industrial case for quantified‑bit‑vector solvers.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/cache-coherence-3-fixpoint-3.smt2",
    "description": "This benchmark is a quantified‑BV verification problem taken from the Wintersteiger et al. hardware fix‑point suite (VCEGAR cache‑coherence models). It encodes a three‑cache‑coherence protocol plus a bus arbiter as a set of Boolean and 3‑bit/2‑bit state variables over several time steps, and asserts that a certain safety/inductive invariant holds (the sole top‑level formula is an ∀…⇒∃… implication). The instance features a massive quantifier alternation (≈ 600 ∀ and 440 ∃), very deep terms (depth > 1000), and thousands of Boolean/bit‑vector operations, making it a challenging industrial‑scale fix‑point/verification case.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/small-equiv-fixpoint-5.smt2",
    "description": "This instance is a quantified bit‑vector verification problem from the VCEGAR hardware benchmark suite (Wintersteiger et al., 2013). It encodes a fix‑point / equivalence check for a small division circuit: each of six pipeline stages (indexed 0…5) must satisfy the arithmetic relationship “remainder = dividend % divisor” and “quotient·divisor + remainder = dividend”. The formula universally quantifies all stage variables, then existentially quantifies a later iteration (index 39) and asserts that the state at stage 5 coincides with one of the earlier stages, i.e. the circuit reaches a recurrent state. The problem features a deep term structure (depth ≈ 52), 44 bit‑vector variables, and a long quantifier prefix (24 ∀ followed by 20 ∃), making it a challenging industrial fix‑point check for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/AR-fixpoint-8.smt2",
    "description": "The benchmark encodes a hardware fix‑point verification problem: a deterministic 2501‑bit vector transition system (incrementing a counter while accumulating a sum until a 100‑limit is reached) is unrolled for nine steps and the formula asserts that for every possible initial state the reachable 9‑step state must coincide with one of the earlier reachable states (i.e., a loop exists). This is expressed with a deep alternation of universal and existential quantifiers (18 ∀, 16 ∃) over large bit‑vectors, using many nested ite, bvadd and bvult terms (term depth ≈ 42), making it a challenging quantified‑BV fix‑point check from the VCEGAR hardware suite.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/AR-fixpoint-3.smt2",
    "description": "This benchmark encodes a hardware “fix‑point” verification task: starting from a concrete initial state (a = 1, b = 0) a 4‑step transition defined by a ← if a < 100 then a + b else a, b ← a is unrolled, and a second copy of the same transition (primed variables) is existentially quantified. The formula asserts that after the fourth step the original state must coincide with one of the three intermediate primed states, i.e., that a loop (fixpoint) exists. It is a quantified bit‑vector problem (2501‑bit words) with eight universal and six existential quantifiers and a moderate term depth (22), making quantifier‑alternation handling the main difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/itc-b13-fixpoint-9.smt2",
    "description": "This instance is a **hardware verification** problem that checks a fix‑point (invariant/reachability) property of a VCEGAR benchmark model. It comes from the Wintersteiger et al. “Efficiently solving quantified bit‑vector formulas” suite (category industrial, family wintersteiger) and is encoded in the BV logic with a massive quantified formula: a ∀‑block over ~260 Boolean and small bit‑vector state variables for ten pipeline stages, followed by an ∃‑block encoding the next‑state constraints and an implication that the system remains in the same state (the fix‑point condition).  \n\nThe formula is unusually hard: it contains 267 universal and 240 existential quantifiers, a term‑depth of 526, over 2 600 ite‑expressions and more than 2 500 equalities, and uses several bit‑vector sizes (8, 10, 4). The sheer number of quantifier alternations, deep nested ite choices and large symbolic state space make it a challenging benchmark for quantified‑BV solvers.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/ethernet-fixpoint-4.smt2",
    "description": "This benchmark encodes an industrial‑scale verification of an Ethernet CSMA/CD controller as a quantified bit‑vector fixpoint problem: a large ∀…∃ formula models several protocol stages (requests, acknowledgments, back‑off counters, carrier‑sense, collision detection, frame handling, etc.) over multiple time‑frames and checks that a safety invariant (e.g., absence of simultaneous transmissions) holds. The instance contains thousands of Boolean and BitVec variables, deep nesting of ite and zero‑extend expressions, a term depth of over 1300, and a quantifier alternation pattern typical of fixpoint/induction checks, making it a demanding test for BV‑solvers.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/kmdf_osrusbfx2_exe_testapp.c.smt2",
    "description": "This benchmark encodes a ranking‑function synthesis task for a loop expressed in 32‑bit bit‑vector arithmetic. It asks whether a single integer coefficient (the existential variable) can be chosen so that, for all possible loop‑iteration states satisfying a simple predecessor relation and a non‑zero‑mod‑4 guard, a linear combination of the loop counter strictly decreases (captured by a signed‑less‑than comparison after sign‑extension and multiplication). The formula features one outer existential quantifier followed by three universals, modest term depth (10) and only a handful of bit‑vector variables, representing an industrial‑scale termination‑proof query from the wintersteiger benchmark suite.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/mmedia_gsm610_gsm610.c.smt2",
    "description": "This instance encodes a termination‑proof problem for a piece of software: it asks whether there exists a 32‑bit constant C such that, for every program state satisfying the given pre‑condition (a value n bounded by 8 and incremented by 1), the signed product C·n is strictly smaller than C·n₀ (the previous value). In other words, it is a ranking‑function synthesis query expressed as a quantified bit‑vector formula. The benchmark is small (four bit‑vector variables, three nested universal quantifiers and one existential quantifier) but features mixed sign‑ and zero‑extensions and multiplication, making it a typical industrial case from the wintersteiger ranking‑function suite.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/kernel_uagp35_gart.c.smt2",
    "description": "The benchmark asks whether a single 32‑bit constant can serve as a linear ranking function for a loop in the program *gart.c*: it must make the product of the constant with the current loop index strictly smaller than the product with the previous index, for every reachable iteration.  This is encoded as a quantified bit‑vector formula with one existential quantifier followed by six universal quantifiers, using 32‑bit arithmetic, sign‑ and zero‑extensions, multiplication, addition and ordering.  It is an industrial‑style ranking‑function synthesis instance from the Wintersteiger benchmark suite, relatively small (≈1.6 KB, depth 12) but requiring quantified reasoning over BV multiplications.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/AVStream_hwsim.cpp.smt2",
    "description": "This benchmark encodes a termination‑proof problem for a C++ routine that manipulates scatter‑gather buffers. The existentially quantified bit‑vectors represent the coefficients of a linear ranking function, while the universally quantified variables stand for the loop’s pre‑state; the single assertion requires that, under the loop guard (positive queue sizes and remaining buffer), the ranking expression strictly decreases (a signed‑less‑than comparison on a weighted sum of products). Consequently the instance is a quantified bit‑vector formula with three outer existentials and fourteen inner universals, deep term nesting (depth 26) and many sign‑extensions and multiplications, characteristic of the industrial ranking‑function synthesis benchmarks from the Wintersteiger et al. series.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/audio_sysfx_swap.cpp.smt2",
    "description": "This benchmark encodes a ranking‑function synthesis task for a loop extracted from the C source *audio_sysfx_swap.cpp*: it asks whether there exists a 32‑bit coefficient C such that, under the loop’s transition relation (decrement of a counter and a non‑zero guard), the linear expression C·new < C·old holds. The formula is a single quantified assertion in the BV logic with an ∃ ∀∗ quantifier prefix (one existential followed by four universal quantifiers) and uses arithmetic operators (bvsub, bvmul, sign/zero extensions) to express the decrease condition. It originates from the Wintersteiger “ranking function synthesis” suite, representing an industrial‑style termination‑proving problem that is challenging mainly because of the quantifier alternation rather than sheer size.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/audio_ddksynth_voice.cpp.smt2",
    "description": "The instance encodes a termination‑proof problem for a C++ loop (audio_ddksynth_voice.cpp) as a quantified bit‑vector formula. It asks whether there exist two 32‑bit coefficients (the “ranking function” constants) such that, for every possible pre‑state and nondeterministic update of the loop variables, the affine ranking expression strictly decreases while the loop guard remains true. The formula features a modest number of variables but a deep nesting of two existential and eight universal quantifiers together with sign‑ and zero‑extensions, multiplications and arithmetic comparisons, making it a typical industrial benchmark for quantified‑BV synthesis/verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/kmdf_pcidrv_sys_hw_nic_init.c.smt2",
    "description": "This benchmark encodes a termination‑proof query for a NIC‑initialisation loop: it asks whether there exists a 32‑bit constant (the proposed ranking function coefficient) such that, for all admissible loop states satisfying the pre‑condition and the loop transition (increment by 2 while the counter stays below 6), the product of the constant with the next state is strictly smaller (signed) than its product with the current state. The formula is a quantified bit‑vector problem (∃·∀³) with simple arithmetic (addition, signed multiplication, sign‑extension), typical of the “ranking‑function synthesis” suite from the Wintersteiger industrial benchmark collection.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/network_usbnwifi_mp_util.c.smt2",
    "description": "This benchmark encodes a termination‑proof obligation for a piece of C software (the `mp_util` routine of the USB‑N‑Wi‑Fi driver).  It asks whether there exist three 32‑bit “ranking‑function” constants such that, for every possible pre‑state of the program variables, the constructed linear combination of signed and unsigned bit‑vector multiplications strictly decreases (a signed‑less‑than check).  The formula is a quantified bit‑vector problem with three outer existential quantifiers followed by a block of ten universal quantifiers, uses many sign‑ and zero‑extensions, and has a moderate term depth (23) and 14 bit‑vector variables, reflecting the typical difficulty of industrial ranking‑function synthesis instances.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/input_pnpi8042_moudep.c.smt2",
    "description": "The benchmark encodes a termination‑proof (ranking‑function synthesis) query for a small C loop: it asks whether there exists a 32‑bit coefficient C such that, for every possible pre‑state, nondeterministic value and loop counter, the linear expression C·i strictly decreases after one iteration while the loop guard holds.  The formula is a single quantified bit‑vector assertion in the BV logic, featuring one existential quantifier over C followed by five universal quantifiers, a handful of arithmetic operations (addition, multiplication, sign/zero‑extension) and a simple inequality.  With only seven bit‑vector variables and modest term depth (12) the instance is representative of the “wintersteiger” industrial suite that challenges quantified‑BV solvers on termination‑related synthesis problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/1394diag_isochapi.c.smt2",
    "description": "This benchmark encodes a termination‑proof problem for a loop extracted from the C source *isochapi.c*: it asks whether there exists a 32‑bit coefficient c such that the linear ranking expression c·i strictly decreases on each iteration (i → i+1) while the loop guard holds (i < nDescriptors) and all nondeterministic variables are forced to 0. The formula is a quantified bit‑vector constraint in the BV logic, featuring one outer existential quantifier followed by eight universal quantifiers over the loop index, the bound, and several auxiliary variables, and it relies on sign‑ and zero‑extension together with multiplication to express the ranking condition. The instance is taken from the Wintersteiger “ranking function synthesis” suite (industrial category) and contains a moderate term depth (≈14) but a non‑trivial quantifier alternation pattern that makes it a typical challenge for QBV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/network_ndis_rtlnwifi_extsta_st_misc.c.smt2",
    "description": "This benchmark encodes a termination‑proof (ranking‑function synthesis) query for a C function that manipulates rate‑set arrays. It asks whether there exist three 32‑bit coefficients (the “ranking function”) such that, for all possible loop counters and input sizes satisfying the loop’s guard, the weighted sum of the counters strictly decreases (expressed by a signed‑less‑than comparison of extended bit‑vector arithmetic). The formula lives in the BV logic, contains three existential quantifiers followed by many universals, uses sign‑ and zero‑extensions to handle 64‑bit intermediate products, and has a moderate size (≈3 k characters, term depth 23), typical of the industrial ranking‑function benchmarks from the Wintersteiger et al. evaluation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/audio_ddksynth_csynth2.cpp.smt2",
    "description": "This benchmark encodes a termination‑ranking‑function synthesis problem for a small C program, taken from the Wintersteiger et al. collection of industrial BV benchmarks. The formula asks whether there exists a 16‑bit constant C such that, for every reachable state (given by several universally quantified 16‑ and 32‑bit variables) satisfying the loop’s guard and transition (including a decrement of the loop counter and a non‑zero nondeterministic value), the product C·n strictly decreases—expressed with sign‑extensions, multiplication, and signed comparisons. The instance features a quantifier prefix ∃∀∀∀∀∀ with moderate term depth (≈11) and a handful of bit‑vector variables, making it a typical yet non‑trivial quantified‑BV challenge for ranking‑function solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/kmdf_usbsamp_sys_queue.c.smt2",
    "description": "This instance is an industrial benchmark from the Wintersteiger ranking‑function suite, encoding the synthesis of a linear ranking function for a decrementing loop variable in a C program. It asks whether there exists a 32‑bit coefficient C such that, for all possible pre‑state values, nondeterministic choices, and loop indices, the signed product C·ix strictly decreases after the index is reduced by one, ensuring termination. The formula is a single quantified bit‑vector constraint with one existential and five universal quantifiers, a modest term depth (11) and six BV variables, typical of termination‑proving problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/input_mouser_cseries.c.smt2",
    "description": "The instance encodes a termination‑proof problem for a simple loop that repeatedly decrements a 32‑bit signed counter while it stays non‑negative. It asks for a constant coefficient (an existential 32‑bit bit‑vector) that makes the linear measure c · count strictly decrease on each iteration, expressed with a ∃ … ∀ … quantifier pattern over the pre‑state, current, and next counter values. This quantified bit‑vector formula, taken from the wintersteiger ranking‑function benchmark suite, features a single nested alternation of quantifiers and moderate term depth, making it a typical industrial‑style synthesis/verification query.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/audio_ac97_wavepcistream2.cpp.smt2",
    "description": "This benchmark encodes a termination‑proof obligation for a loop extracted from the audio_ac97 driver (file audio_ac97_wavepcistream2.cpp).  It asks whether there exists a 32‑bit ranking‑function coefficient such that, for every possible loop state (captured by several quantified bit‑vectors representing the loop counter and an index), the ranking expression strictly decreases (a signed‑multiplication and comparison after zero/sign extensions).  The formula is a quantified BV problem with a single ∃‑∀ alternation, moderate term depth (11) and a handful of variables, typical of industrial ranking‑function synthesis tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/network_ndis_rtlnwifi_extsta_st_aplst.c.smt2",
    "description": "This benchmark encodes a termination‑ranking‑function synthesis problem for a 32‑bit integer loop: it asks whether there exists a 32‑bit constant C such that, for every possible loop transition (captured by four universally quantified state variables and a pre‑state), the linear measure C·i strictly decreases while the loop guard (i < APCount + 2³²‑1) holds. The formula is expressed in the BV logic with a single existential quantifier over C followed by four universal quantifiers, uses signed and unsigned extensions together with multiplication, and contains a modest number of variables (5 bit‑vectors) but non‑trivial quantifier alternation and arithmetic that make it representative of the “ranking function synthesis” category of industrial benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/input_mouser_detect.c.smt2",
    "description": "This benchmark encodes a termination‑proof task for a small C program (the “detect” routine). It asks whether there exists a 32‑bit constant C that serves as a linear ranking function, i.e., such that for every reachable loop state the signed product C·i strictly decreases after the loop’s increment (expressed with sign‑extended multiplication and a signed‑less‑than test). The formula is a quantified bit‑vector problem (∃ C ∀ states) drawn from the Wintersteiger “ranking” collection, featuring nested quantifiers, sign‑extensions and multiplication, which makes it a non‑trivial industrial instance despite its modest size.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/audio_ac97_common.cpp.smt2",
    "description": "This instance encodes a termination‑proof (ranking‑function synthesis) problem for a loop extracted from the C file audio_ac97_common.cpp. It asks whether there exists a 32‑bit constant C such that, for every possible loop iteration (captured by a universally quantified pre‑state, a nondeterministic byte read, and the loop counter bounded by 100), the product C·counter strictly decreases after the counter is incremented—i.e., a linear ranking function exists. The formula is a single quantified bit‑vector constraint (∃ C ∀ … → …) with moderate term depth (14) and a handful of variables, typical of the industrial benchmarks used in Wintersteiger et al.’s evaluation of quantified BV solving.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/filesys_cdfs_allocsup.c.smt2",
    "description": "This benchmark encodes a termination‑proof problem for a loop in the C function *allocsup* (filesys_cdfs_allocsup.c).  The formula asks whether there exist 32‑ and 64‑bit bit‑vector constants that serve as a linear ranking function, such that for every possible loop iteration (described by universal variables and the loop’s transition relation) the ranking expression strictly decreases (signed‑less) while respecting the loop’s guard conditions (bounds and arithmetic on offsets and byte counts).  The instance originates from the wintersteiger “ranking function synthesis” suite and is challenging because it mixes several quantifier alternations (∃ followed by many ∀), deep arithmetic terms with many sign/zero extensions, and both signed and unsigned comparisons over 32‑ and 64‑bit vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/AVStream_image.cpp.smt2",
    "description": "This benchmark encodes a termination‑proof task for a C++ routine (AVStream_image.cpp) as a ranking‑function synthesis problem. It asks whether there exist 32‑bit values (the candidate ranking function’s parameters) such that for all possible pre‑state values and a nondeterministic step the loop transition respects a decreasing linear‑numeric measure—formalised with a quantified ∃∃∀… formula over bit‑vectors that uses multiplication, shifts and signed extensions. The instance is industrial‑scale, contains a moderate number of variables (≈9) but features a non‑linear ∃∀ quantifier alternation and term depth 16, making it a challenging quantified bit‑vector verification query.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/mmedia_gsm610_gsm6103.c.smt2",
    "description": "This benchmark is an industrial‑style quantified bit‑vector problem that asks for a 32‑bit coefficient witnessing a linear ranking function for a simple transition: a signed 32‑bit variable that is known to be greater than 0xC0000000 is left‑shifted by one (i.e., doubled), and the coefficient must make the product strictly decrease (signed) after the shift.  The formula contains a single existential quantifier over the coefficient followed by three nested universal quantifiers over the program variables, with shallow terms (depth 9) and only a handful of bit‑vector operations (shifts, signed comparisons and multiplications).  Hence the instance tests the ability of solvers to handle a small ∃‑∀‑∀‑∀ quantifier pattern in the BV logic, typical of ranking‑function synthesis for termination verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/general_pcidrv_sys_hw_eeprom.c.smt2",
    "description": "This benchmark encodes a termination‑proof problem for a small EEPROM‑related loop, asking whether there exist 16‑bit coefficients (the “ranking function”) that make a linear (signed) decrease relation hold for every reachable loop state. The formula combines existential quantification over the candidate coefficients with a deep universally quantified block over pre‑state variables, together with bit‑vector arithmetic, extensions, and a few bit‑wise constraints that model size limits and non‑zero low‑order bits. The instance is a typical industrial ranking‑function synthesis query: a single quantified assertion with two alternations (∃…∀…) and moderate term depth (≈18) but a rich mix of bit‑vector operations, which makes it challenging for solvers that handle quantified BV formulas.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/filesys_filter_namelookup.c.smt2",
    "description": "This benchmark encodes the synthesis of a linear ranking function for a 32‑bit integer loop (the *namelookup* routine) as a quantified bit‑vector formula. It asks whether there exists a coefficient C such that, for all possible loop variables satisfying the loop’s transition constraints, the product C·i strictly decreases (expressed with signed‑extended multiplication and a signed‑less‑than test). The instance features a single existential quantifier followed by five universal quantifiers, moderate term depth (≈11), and is taken from an industrial termination‑proving evaluation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/network_ndis_e100bex_5x_kd_mp_dbg.c.smt2",
    "description": "This benchmark encodes a termination‑proof task for a piece of software (the “mp_dbg” routine) as a ranking‑function synthesis problem in the quantifier‑rich bit‑vector logic. It asks whether there exist 32‑bit coefficients such that, for every reachable pre‑state satisfying the loop’s guard, a linear combination of the state variables strictly decreases (using signed‑less‑than after appropriate extensions) while respecting a lower bound (the “min 16” condition). The formula features nested ∃/∀ quantifiers, several sign‑ and zero‑extensions, and moderate term depth, making it a typical industrial‑scale verification instance from the Wintersteiger ranking‑function benchmark suite.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/hid_hclient_ecdisp.c.smt2",
    "description": "This benchmark encodes a termination‑proof (ranking‑function synthesis) problem for a C routine that iterates over an array of 32‑bit unsigned indices. The formula asks whether there exists a 32‑bit constant C such that, for every loop iteration and any admissible index, the product C·current index is strictly smaller than C·previous index, expressed with quantified bit‑vector arithmetic (one existential followed by four universal quantifiers). It originates from the Wintersteiger “efficiently solving quantified bit‑vector formulas” suite, features a modest number of variables (five bit‑vectors) and a term depth of 10, but the quantifier alternation makes it a non‑trivial industrial‑scale check‑satisfiability instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/audio_fmsynth_miniport.cpp.smt2",
    "description": "This instance encodes a termination‑proof problem for a small C audio‑synthesis routine: it asks whether there exists a 32‑bit constant (the candidate ranking function coefficient) such that, for every reachable program state satisfying a predecessor relation (including a lower bound of 1024 and a one‑bit right‑shift), the weighted product of the current pitch value is strictly smaller than the weighted product of the predecessor pitch. The formula is a quantified bit‑vector check (∃ 32‑bit ∧ ∀ 3 32‑bit) featuring sign‑ and zero‑extensions, a shift, and a multiplication, typical of the “ranking function synthesis” benchmarks derived from the Wintersteiger et al. evaluation. The problem is industrial‑style, with moderate term depth (9) but a non‑linear arithmetic fragment owing to the bvmul, making it a challenging case for QBV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/filesys_fastfat_cachesup.c.smt2",
    "description": "This benchmark encodes a termination‑proof (ranking‑function synthesis) task for a small fragment of the **filesys_fastfat** program. It asks for a 32‑bit coefficient c such that, for every loop iteration value i (restricted to 0 ≤ i < 4) and its successor i+1, the linear expression c·i is strictly smaller than c·i₀, where i₀ denotes the previous value of i. The formula thus contains a single ∃ c followed by three nested ∀‑quantifiers and uses bit‑vector multiplication with sign/zero extensions, making quantifier reasoning over arithmetic the main difficulty despite the modest term depth and variable count.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/network_ndis_rtlnwifi_hw_hw_ccmp.c.smt2",
    "description": "The instance is a quantified bit‑vector formula arising from the “ranking function synthesis” benchmark suite (Wintersteiger et al.). It asks whether there exists a 16‑bit coefficient c such that, for every possible pre‑state of a loop (represented by the variables i, i₀, aad_len, etc.) satisfying the loop’s guard and the update i = i₀ + 16, the signed product c·i is strictly larger than c·i₀. In other words, it encodes the search for a linear ranking function proving termination of a hardware CCMP routine. The problem features a single existential quantifier followed by four nested universal quantifiers, uses zero‑ and sign‑extensions, and combines arithmetic, comparison and bit‑mask operations, making it a non‑trivial quantified BV challenge.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/audio_gfxswap.xp_filter.cpp.smt2",
    "description": "The benchmark encodes a termination‑proof task for a C loop (the “audio_gfxswap” program). It asks for a 32‑bit coefficient (the existential variable) that serves as a ranking function: for every loop iteration the loop variable is decremented by 4 and the signed product of the coefficient with the loop variable must strictly decrease. Thus the formula is an ∃ ∀∧‑quantified bit‑vector constraint used for ranking‑function synthesis. The instance is small (four 32‑bit bit‑vectors, one quantifier alternation, max term depth 9) but involves sign‑extension and signed multiplication, typical of industrial termination‑proving benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/1394diag_ioctl.c.smt2",
    "description": "This instance is a quantified bit‑vector verification problem that asks whether a linear ranking function exists for a loop in the `ioctl` driver (the benchmark 1394diag_ioctl.c).  It encodes two existential parameters (the coefficients of the ranking function) and a chain of eleven universal variables representing the loop’s pre‑state, asserting that under the loop’s guard the candidate function strictly decreases (via a signed‑less‑than test) while respecting several size and buffer‑length constraints.  The formula features a deep quantifier alternation (∃∃∀…∀) with extended arithmetic (sign‑/zero‑extension, multiplication, addition) and a moderate term depth of 20, making it a challenging industrial‑style ranking‑function synthesis query.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_2_true-unreach-call_true-no-overflow_false-termination.i_11.smt2",
    "description": "This instance is a software‑verification condition generated by Ultimate Automizer for the SV‑COMP 2019 benchmark *jain_2*, encoding the simultaneous check that a designated error call is unreachable (true‑unreach‑call) and that the program does **not** terminate (false‑termination).  The formula works over 32‑bit bit‑vectors, uses several existentially quantified nondeterministic variables, and contains linear combinations of those variables multiplied by the constant 0xFFFFFFFE together with a final negated conjunction, yielding a quantifier‑rich but shallow (max depth 7) bit‑vector problem.  Its difficulty stems mainly from the multiple existential blocks and the frequent multiplications by large constants rather than deep term nesting.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/soft_float_4_true-unreach-call_true-no-overflow_true-termination.c.cil.c_5.smt2",
    "description": "This instance is a bounded‑bit‑vector verification problem generated by the Ultimate Automizer tool from an SV‑COMP 2019 benchmark that checks a soft‑float addition routine. The formula asserts that the program’s verification condition (a comparison of two masked 32‑bit values) must be true, while simultaneously proving that no choice of inputs and a “delta” value can make a certain masked addition equality hold – a typical safety‑property/overflow check. It features several existential quantifiers, bitwise masks, shifts and addition on 32‑bit words, moderate term depth (≤ 9) and a small but non‑trivial quantifier alternation, making it a typical industrial BV verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_4.smt2",
    "description": "This instance encodes a safety‑verification condition for a small C benchmark (the “jain_7” program) from the SV‑COMP 2019 suite, generated by the Ultimate Automizer tool.  The model uses 32‑bit bit‑vectors for three program variables and introduces several existentially quantified nondeterministic inputs; each branch asserts a linear equation (with constant multipliers) relating the inputs to the program variables.  The final query asserts the negation of a conjunction of three such existential constraints, turning the verification task into a SAT check for the inconsistency of these arithmetic conditions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/pals_lcr-var-start-time.6_true-unreach-call.ufo.UNBOUNDED.pals.c_1.smt2",
    "description": "This instance encodes a safety‑verification problem generated by Ultimate Automizer for an SV‑COMP 2019 benchmark. The model represents a set of 8‑bit state variables (and their “old” values) whose sign‑extended 32‑bit sums are required to stay ≤ 1 across program transitions; the constraints include a single universally quantified clause that forces each variable to be non‑zero unless the summed bound holds. The formula is a pure bit‑vector check (BV logic) with a modest number of constants, moderate term depth, and a handful of arithmetic and relational operators, and it is used to prove that the unsafe condition is unsatisfiable.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_6_true-unreach-call_true-no-overflow_false-termination.i_16.smt2",
    "description": "This instance is a 32‑bit bit‑vector verification task generated by Ultimate Automizer for an SV‑COMP 2019 benchmark, encoding the check that a certain program state (an \"unreach‑call\" condition) cannot be reached. The core constraint is a universally quantified disequality that is negated, turning the problem into an existential search for values of several nondeterministic variables and program constants that satisfy a linear equation involving multiple constant‑multiplied bit‑vector terms. Although the formula contains only a handful of variables and shallow term depth (max 7), it requires reasoning over quantified 32‑bit arithmetic, which is typical for safety/termination verification of industrial C programs.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_6_true-unreach-call_true-no-overflow_false-termination.i_6.smt2",
    "description": "This instance is a software‑verification condition generated by Ultimate Automizer for an SV‑COMP 2019 benchmark. It encodes, with 32‑bit bit‑vectors, a set of existential constraints over nondeterministic variables that capture the arithmetic relations of the program, and then asserts the negation of a conjunction of similar constraints to prove a safety/termination property. The formula contains only existential quantifiers (six separate blocks), moderate term depth (≤ 7) and several multiplications, making it a typical bit‑vector verification query rather than a synthesis or scheduling problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_6_true-unreach-call_true-no-overflow_false-termination.i_4.smt2",
    "description": "This instance is a software‑verification query generated by Ultimate Automizer from an SV‑COMP 2019 benchmark. It encodes, in 32‑bit bit‑vector arithmetic, three linear equalities that relate program variables x, y and z to nondeterministic values via constant multiplications (e.g., x = 2·nondet, y = 4·nondet, z = 8·nondet) and then asserts the negation of the conjunction of the three corresponding existential facts, i.e., it asks whether the program can reach a state where all three multiples hold simultaneously. The problem involves only a few quantified variables, shallow term depth (≤6), and many large‑constant multiplications, making it a modest‑size, quantifier‑based reachability/invariant check in the BV logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/soft_float_4_true-unreach-call_true-no-overflow_true-termination.c.cil.c_7.smt2",
    "description": "The script encodes a software‑verification condition for a C program that performs a floating‑point addition, modeled with 32‑bit bit‑vectors. It asserts that there exist bit‑vector values satisfying the arithmetic relationship defined by shifts, masks and addition, and then checks that no value can make a particular masked result equal to a stored constant—i.e., it verifies that a certain overflow/invalid‑state cannot be reached. The formula is a small BV benchmark (four assertions, two declared constants) with a shallow term depth but a quantifier alternation (∃ inside a ¬∃), typical of Ultimate Automizer’s SV‑COMP 2019 industrial verification instances.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_2_true-unreach-call_true-no-overflow_false-termination.i_14.smt2",
    "description": "This instance is an industrial software‑verification query generated by Ultimate Automizer for an SV‑COMP 2019 benchmark. It encodes a reachability/termination property of a C program as a quantified bit‑vector formula: the first universally quantified assertion states that a certain linear combination of program variables and nondeterministic inputs can never equal its negated counterpart, while the second universally quantified assertion (negated) forces the existence of a witness violating that relation. The problem is posed in the BV logic, contains a modest number of variables (two 32‑bit inputs and two globals), shallow term depth (≤ 8), and only two quantifier blocks, making it a relatively small but non‑trivial quantified verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_21.smt2",
    "description": "This instance encodes a software‑verification task generated by Ultimate Automizer for an SV‑COMP 2019 benchmark. The formula asserts that no assignment of the program’s 32‑bit variables (including pre‑call values of x, y, z and several nondeterministic inputs) can satisfy either a universally quantified invariant condition or an existential witness of a bad state; thus proving the original safety/termination claim reduces to showing the SMT‑LIB query unsatisfiable. The problem uses the bit‑vector theory, contains a single quantifier alternation (one ∀‑block followed by an ∃‑block), moderate term depth (≈11) and a modest number of arithmetic operations, making it a typical medium‑size industrial verification case.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/gcd_3_true-unreach-call_true-no-overflow.i_0.smt2",
    "description": "This instance is a software‑verification query generated by Ultimate Automizer for an SV‑COMP 2019 benchmark that tests a Euclidean‑algorithm (gcd) implementation. The formula, written in the BV logic, encodes the unreachability of a “bad” state by asserting that no combination of an 8‑bit input and an existentially‑quantified intermediate variable can satisfy a set of bit‑vector equalities and inequalities involving sign‑extension, remainder (bvsrem) and negation operations. It is a moderately sized industrial case (≈3 KB, depth 14) with nested let‑bindings and a single existential quantifier, typical of the hard bit‑vector verification problems posed to SMT‑COMP solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_13.smt2",
    "description": "This instance is a bounded‑integer (BV) verification problem generated by Ultimate Automizer from an SV‑COMP 2019 benchmark, encoding a safety check (unreachability/absence of overflow) for a C program. The formula consists of a universally‑quantified transition‐relation over a handful of 32‑bit variables together with a negated universal encoding the negation of the safety property, forcing the solver to show unsatisfiability to prove the property. The problem is modest in size (three declared constants, two quantified assertions, max term depth 10) but features mixed multiplication and addition of large bit‑vector constants, which can be challenging for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_2_true-unreach-call_true-no-overflow_false-termination.i_19.smt2",
    "description": "This instance is a software‑verification safety check generated by Ultimate Automizer from an SV‑COMP 2019 C benchmark. It encodes, as a combination of a universally‑quantified inequality and a negated disjunction, that a certain linear relation over two 32‑bit input variables and two nondeterministic choices can never hold, i.e., that a bad error state is unreachable. The formula consists of a few quantified bit‑vector variables, shallow arithmetic (multiplication by 2, addition, negation) and no deep term nesting, so the main challenge for the solver is handling the quantifiers rather than large‑scale combinatorial explosion.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/soft_float_4_true-unreach-call_true-no-overflow_true-termination.c.cil.c_3.smt2",
    "description": "This instance is a BV‑based verification condition generated by Ultimate Automizer for a C benchmark from SV‑COMP 2019. It encodes the correctness of a software implementation of floating‑point addition: the first assertion defines the mantissa and exponent extraction of the two operands, and the second (negated existential) asserts that there exists a choice of inputs violating the expected relationship between the extracted fields and the rounded sum. The problem is a safety check (no‑error reachable) expressed with a single existential quantifier (turned universal by the outer negation), involving only six 32‑bit variables, shallow terms (max depth 9) and basic bit‑wise, shift and addition operations, making it a modest‑size, quantifier‑light BV verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_2_true-unreach-call_true-no-overflow_false-termination.i_9.smt2",
    "description": "This instance is a software‑verification query produced by Ultimate Automizer from the SV‑COMP 2019 “jain_2” benchmark. It encodes a safety/termination property as a 32‑bit bit‑vector formula that uses only existential quantifiers for nondeterministic inputs and linear equations involving multiplication by the constant 4294967294 (≡ −2 mod 2³²) together with constant additions. The solver must prove that the negated conjunction of these existential constraints is unsatisfiable, i.e., that the property holds; the formula is shallow (max term depth 7) but contains several quantified variables and many duplicated bvmul terms, which can be challenging for solvers that are not specialised for quantified BV reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_15.smt2",
    "description": "This instance encodes a bit‑vector software‑verification query generated by Ultimate Automizer from an SV‑COMP 2019 benchmark that tests termination (the file name indicates “false‑termination” while “no‑overflow” holds). The formula consists of two universally quantified equalities over 32‑bit arithmetic expressions involving several nondeterministic inputs, and the final check asks whether the negation of one of these universal properties is satisfiable – i.e., whether a termination counter‑example exists. The problem is a moderate‑size BV verification task (≈3 kB, depth 10) with a handful of quantified variables and linear bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_6.smt2",
    "description": "This instance is a bit‑vector verification problem generated by Ultimate Automizer from an SV‑COMP 2019 benchmark. It encodes a set of linear arithmetic constraints over 32‑bit variables (coming from nondeterministic program values) and asks whether a simplified “single‑multiply” form of those constraints can be refuted – i.e., it checks that the more complex existential equations cannot simultaneously reduce to the simpler equalities, which corresponds to proving a safety/termination property of the original C program. The formula contains only existential quantifiers, modest term depth (≤6) and a small number of bit‑vector variables, making it a typical industrial‑scale reachability/overflow‑freedom check.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_6_true-unreach-call_true-no-overflow_false-termination.i_1.smt2",
    "description": "This instance is a bit‑vector safety verification problem generated by Ultimate Automizer from an SV‑COMP 2019 benchmark. It encodes a transition where three integer variables are incremented by nondeterministic multiples of 2, 4 and 8, respectively, and asserts that the variables always remain exact multiples of those coefficients; the final assertion negates this condition to ask whether a reachable state can break the invariant. The formula contains only existential quantifiers, a handful of variables and shallow term depth, making it a compact industrial‑scale check of a simple arithmetic invariant.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_18.smt2",
    "description": "This SMT‑LIB file is a safety‑verification query generated by Ultimate Automizer for a C benchmark from the SV‑COMP 2019 industrial suite.  It checks the unsatisfiability of a formula that combines a concrete 32‑bit equality with a universally‑quantified inequality over the program’s three main variables and several nondeterministic inputs, using only bit‑vector arithmetic (adds, multiplies by large constants, and negations).  The problem is a moderate‑size, quantified BV verification task (≈3 kB, depth 11, two forall quantifiers) aimed at proving that a certain error state (an unreachable call) cannot be reached.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_6_true-unreach-call_true-no-overflow_false-termination.i_8.smt2",
    "description": "This instance is a bit‑vector safety verification problem produced by Ultimate Automizer from an SV‑COMP 2019 benchmark (category “industrial”). It encodes a set of existentially quantified nondeterministic 32‑bit values that must satisfy simple multiplication constraints ( x = 2·v₀, y = 4·v₁, z = 8·v₂ ) and then asserts the negation of three additional linear arithmetic relations involving large constants, thereby checking that those relations hold for all possible nondet choices (i.e., proving a reachable‑state‑free condition such as absence of overflow or a termination invariant). The formula contains only Boolean combinations of a handful of quantified conjunctions, with modest term depth (≤ 7) and no quantifier alternations, making it a typical BV‑only verification query.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_19.smt2",
    "description": "This instance is a software‑verification query generated by Ultimate Automizer from the SV‑COMP 2019 benchmark “jain_7”. It asks whether a linear relation over 32‑bit variables (including three fixed constants and three nondeterministic inputs) can ever be satisfied; the formula is expressed with a universal quantifier over the program’s symbolic state and an existential quantifier for a witness, and the outer assertion negates the disjunction of the quantified condition and a concrete equality. Consequently the problem is a safety‑style reachability/overflow check encoded as a quantified bit‑vector formula with moderate term depth (≈11) and a handful of large constant multiplications, making it a non‑trivial QBV instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/soft_float_4_true-unreach-call_true-no-overflow_true-termination.c.cil.c_8.smt2",
    "description": "The script encodes a safety‑property check for a soft‑float addition routine extracted from an SV‑COMP 2019 C benchmark; it models the 32‑bit floating‑point mantissa extraction and a shift‑right operation with bit‑vector primitives and asks whether there exists any operands and a delta that make a certain transformed sum equal the original value.  The final `not (exists …)` asserts that such a combination must be impossible, i.e. that the error state (an overflow‑like violation) is unreachable.  The instance was generated by Ultimate Automizer, contains three existential quantifiers over a small set of bit‑vectors, and features shallow terms (max depth 9), making it a typical industrial verification problem in the BV logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_9.smt2",
    "description": "This instance is a bit‑vector verification condition generated by Ultimate Automizer for a SV‑COMP 2019 benchmark (file jain_7), encoding a termination check that is expected to be false. The formula consists of three independent linear equations over 32‑bit vectors, each relating a program output (c_main_x, c_main_y, c_main_z) to several existentially quantified “nondet” variables via constant multiplications and additions; the final assertion negates the conjunction of these equations, turning the problem into an unsatisfiability check. The model features only BV arithmetic (no quantifier alternation, depth ≤ 7) with a moderate number of bit‑vector operations, typical of industrial software‑verification tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/float_req_bl_0730b_true-unreach-call.c_31.smt2",
    "description": "This instance is a software‑verification condition generated by Ultimate Automizer from an SV‑COMP 2019 C benchmark that checks a property of a single‑precision IEEE‑754 square‑root routine. It encodes a universally quantified bit‑vector equation together with a concrete conjunctive assertion about two 32‑bit constants that represent internal constants of the sqrt implementation; the goal is to show that the conjunction is unreachable (i.e., the formula is unsatisfiable). The problem involves only a handful of bit‑vector variables but requires reasoning about quantified arithmetic (depth 10) over 32‑bit words, typical of verification tasks for floating‑point code.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_8.smt2",
    "description": "This instance is a bit‑vector verification condition generated by Ultimate Automizer for an SV‑COMP 2019 benchmark (the file name indicates a true‑unreach‑call / true‑no‑overflow / false‑termination case). It encodes three simple linear equalities over 32‑bit variables (each as an existential formula) and then asserts the negation of a conjunction of three analogous equalities that involve sums of three terms, thereby checking whether the larger system can be satisfied given the smaller ones. The problem involves only BV multiplication/addition, a modest number of variables, shallow term depth (≤ 7), but requires reasoning with multiple existential quantifier blocks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_6_true-unreach-call_true-no-overflow_false-termination.i_5.smt2",
    "description": "This instance is a BV‑logic verification query generated by Ultimate Automizer from an SV‑COMP 2019 benchmark. It encodes three independent linear Diophantine‑style constraints over 32‑bit unsigned integers (using constant multiplications like ‑2, ‑4, ‑8) and asks whether the conjunction of these existentially quantified equations can be falsified, which corresponds to checking a termination‑related safety property of the original C program. The formula is small (three constants, six existential quantifiers, depth ≤ 7) but features several quantified sub‑terms and bit‑vector multiplications, making it a typical arithmetic‑heavy, quantifier‑only verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/soft_float_4_true-unreach-call_true-no-overflow_true-termination.c.cil.c_2.smt2",
    "description": "This instance encodes a bounded‑model‑checking query for a floating‑point addition routine (the “soft_float_4” benchmark) from the SV‑COMP 2019 suite, generated by the Ultimate Automizer tool. The formula works over 32‑bit bit‑vectors, using existentially quantified intermediate variables to model the mantissa‑extraction and rounding steps, and asserts the negation of a safety property that the result’s exponent bit never becomes set after the addition. The problem is a pure BV verification task with a modest number of variables, shallow term depth (≤10) and only existential quantifiers, making it a typical industrial verification case for bit‑precise software analysis.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_6_true-unreach-call_true-no-overflow_false-termination.i_12.smt2",
    "description": "This instance is a bit‑vector safety verification problem produced by Ultimate Automizer from the SV‑COMP 2019 benchmark suite (the “jain_6” program). It encodes the unreachability of a bad state by asserting the existence of three nondeterministic 32‑bit values that satisfy linear equations involving the program’s inputs x, y, z, and then negating a similar conjunction with additional quantified variables; the goal is to prove that the conjunction cannot hold. Although the file is small (three bit‑vector constants and two quantified assertions), it contains multiple existential quantifier blocks and multiplications by large constants, which can make the bit‑vector solving non‑trivial.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_7.smt2",
    "description": "This benchmark is a safety‑style verification query generated by Ultimate Automizer from the SV‑COMP 2019 “jain_7” benchmark.  It encodes three 32‑bit variables as linear equations with large constant bit‑vector multiplications and asserts that a particular conjunction of such existentially‑quantified equations is impossible (i.e. the negated conjunction must be unsatisfiable).  The instance contains only existential quantifiers, a handful of bit‑vector multiplications/additions, and a modest term depth, representing a typical industrial BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_2_true-unreach-call_true-no-overflow_false-termination.i_1.smt2",
    "description": "This instance is a 32‑bit bit‑vector verification problem produced by Ultimate Automizer for an SV‑COMP 2019 benchmark.  It encodes the transition relation of a small C program with two nondeterministic 32‑bit inputs, relates pre‑ and post‑state variables by linear arithmetic, and checks a safety‑style property: a certain equality must never hold for any choice of the nondet values (expressed with a universal quantifier and its negation).  The formula contains only a handful of variables and shallow terms (max depth 8) but features a quantifier alternation (∀ … ¬…) that makes it a typical candidate for model‑checking‑style bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_2_true-unreach-call_true-no-overflow_false-termination.i_13.smt2",
    "description": "This instance is a bounded‑integer (BV) verification query generated by Ultimate Automizer for an SV‑COMP 2019 benchmark. It encodes a safety/termination property of a C program using two universally‑quantified nondeterministic 32‑bit inputs; the core check is whether a certain linear combination of these inputs can satisfy an equality involving the program’s variables. The formula consists of a few quantified bit‑vector equalities (with additions, multiplications by 2, and negation) and is presented without models or unsat‑cores, making it a typical industrial verification task with modest variable count but non‑trivial quantifier structure.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/float_req_bl_0730b_true-unreach-call.c_28.smt2",
    "description": "This instance is a verification query produced by Ultimate Automizer from an SV‑COMP 2019 C benchmark that models the IEEE‑754 square‑root routine with 32‑bit bit‑vectors. The single assertion universally quantifies over a 32‑bit input and requires that a particular linear combination of the input and two constant bit‑vectors (representing internal constants of the sqrt implementation) can never be zero, i.e., it encodes an unreachability/invariant property of the sqrt function. The problem is a quantifier‑heavy BV verification task with a shallow term depth (max 9) and only a few declared constants, making the logical difficulty moderate despite the presence of a forall.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/soft_float_4_true-unreach-call_true-no-overflow_true-termination.c.cil.c_0.smt2",
    "description": "This instance is a bit‑vector verification condition generated by Ultimate Automizer from an SV‑COMP 2019 C benchmark that implements IEEE‑754‑style floating‑point addition. The formula fixes the mantissa and exponent fields of two operand words, relates them to the expected result, and then asserts that no witness (a delta and a second operand) can satisfy a specific overflow‑related equality, thereby proving the addition cannot overflow. The problem is a small BV logic query (7 declared constants, shallow term depth) with a single existential quantifier, typical of automated software‑model‑checking tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_5.smt2",
    "description": "This instance encodes an industrial software‑verification task generated by Ultimate Automizer from an SV‑COMP 2019 benchmark. The formula asks whether the three 32‑bit program variables can satisfy a set of linear arithmetic relations over nondeterministic inputs, and then asserts the negation of a strengthened version of those relations; the solver therefore checks a safety (unreachability/termination) property. The problem is a bit‑vector verification query with several nested existential quantifiers, a moderate number of variables and multiplication constants, and a modest term depth, which makes it a typical quantifier‑heavy, arithmetic‑rich benchmark for BV‑solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_6_true-unreach-call_true-no-overflow_false-termination.i_17.smt2",
    "description": "This instance is a safety‑verification problem generated by Ultimate Automizer from an SV‑COMP 2019 benchmark (the “jain_6” C program). It encodes, in 32‑bit bit‑vector arithmetic, a universal property that a specific linear combination of the program’s input variables and nondeterministic choices can never equal another linear expression; the second assertion negates a similar universally quantified condition, effectively asking whether a violating assignment exists. The formula therefore consists of two quantified BV constraints (moderate term depth 7, a handful of variables) that a solver must decide for satisfiability, reflecting a reachability/overflow check on integer arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/float_req_bl_0730b_true-unreach-call.c_36.smt2",
    "description": "This instance comes from an SV‑COMP 2019 benchmark encoded by Ultimate Automizer and asks whether a certain error state in a C implementation of the IEEE‑754 single‑precision `sqrtf` function is reachable.  It is a bit‑vector verification problem (BV logic) that asserts a universally‑quantified arithmetic property about the function’s internal constants and then requires that a specific combination of these constants does **not** simultaneously hold.  The formula contains only a handful of 32‑bit bit‑vectors, a single quantifier, and shallow term depth, making it a small‑scale industrial software‑verification query.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/sum02_false-unreach-call_true-no-overflow.c_5.smt2",
    "description": "This instance is a BV‑based verification condition generated by Ultimate Automizer for the SV‑COMP 2019 benchmark *sum02_false‑unreach‑call_true‑no‑overflow.c*. It encodes the arithmetic invariant of the classic triangle‑number formula ( n·(n+1)/2 ) together with index i and accumulated sum sn, using several universally quantified clauses that capture the loop invariant and its progression; the final ¬∀ clause and an explicit inequality aim to falsify the invariant, i.e., to prove a reachability (or overflow) violation. The problem involves only three 32‑bit bit‑vector variables but combines nested arithmetic (addition, multiplication, unsigned division) with four quantified statements, making the main difficulty the handling of quantified bit‑vector arithmetic rather than sheer size.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_6_true-unreach-call_true-no-overflow_false-termination.i_10.smt2",
    "description": "This instance is a software‑verification condition produced by Ultimate Automizer from an SV‑COMP 2019 benchmark (the “jain_6” program). It encodes, in 32‑bit bit‑vector arithmetic, three linear equations over nondeterministic variables that must hold for the program’s variables x, y, z, and then asserts the negation of a strengthened version of the same constraints (with additional summed terms) to check an unreachability/termination property. The problem is a quantifier‑rich (existential) BV formula with shallow term depth, typical of automated safety‑property verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/float_req_bl_0730b_true-unreach-call.c_38.smt2",
    "description": "This instance is a software‑verification query generated by Ultimate Automizer from an SV‑COMP 2019 benchmark that models a C implementation of the IEEE‑754 `sqrtf` function. The problem asks whether a universally quantified bit‑vector relation—representing the arithmetic constraints of the sqrt routine—can hold together with a concrete assertion that a specific input variable equals zero, i.e., whether a “bad” state (an unreachable call) can be reached. The formula uses 32‑bit bit‑vector arithmetic (addition, multiplication, logical right shifts, negation) and a single quantifier, making it a small but non‑trivial bit‑vector verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/sum02_false-unreach-call_true-no-overflow.c_1.smt2",
    "description": "The instance is a bit‑vector verification query generated by Ultimate Automizer from the SV‑COMP 2019 benchmark *sum02_false‑unreach‑call_true‑no‑overflow.c*.  It encodes the arithmetic of the sum \\(n·(n+1)/2\\) together with loop‑invariant relations among the loop index \\(i\\), the partial sum \\(sn\\) and the bound \\(n\\), using several universally‑quantified constraints and a final negated universal to express the negation of the intended safety property.  The problem is modest in size (3 declared 32‑bit variables, 6 assertions, depth 9) but features mixed linear arithmetic, division and quantifier alternations that make it a typical industrial BV‑verification challenge.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_2_true-unreach-call_true-no-overflow_false-termination.i_15.smt2",
    "description": "This instance is a bit‑vector verification condition generated by Ultimate Automizer for an SV‑COMP 2019 benchmark (the “jain_2” program). It encodes a safety/termination property as a quantified arithmetic formula over 32‑bit words, consisting of a universally‑quantified equality combined with a negated universal clause, and is ultimately reduced to a plain SAT check. The problem features a modest number of variables and shallow terms (depth 8) but includes quantifier alternation, making it a typical industrial BV‑verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_2_true-unreach-call_true-no-overflow_false-termination.i_17.smt2",
    "description": "This instance is a bit‑vector verification condition generated by Ultimate Automizer for an SV‑COMP 2019 benchmark (the program “jain_2” checking a true unreachability‑call, true no‑overflow, and false termination property). It encodes two universally‑quantified arithmetic relations over 32‑bit integers that involve nondeterministic inputs, multiplications by 2, additions and negations; the outer negation forces the solver to prove the conjunction unsatisfiable in order to establish the program’s safety/invariant. The problem is relatively small (≈2 kB, 10 BV variables) but features quantified BV arithmetic with moderate term depth, typical for automated software model‑checking tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_6_true-unreach-call_true-no-overflow_false-termination.i_2.smt2",
    "description": "This instance is a bit‑vector safety verification problem generated by Ultimate Automizer from an SV‑COMP 2019 benchmark. It encodes a small fragment of a program with three nondeterministic 32‑bit inputs and three state variables (x, y, z) that are updated by simple linear “+= k·nondet” assignments; the query asks whether a universally quantified linear equality involving the pre‑ and post‑state variables can ever hold, i.e. whether a claimed invariant is violated. The formula contains only a few quantified variables and modest term depth, but the mix of quantifiers, large constants and multiplication makes the BV decision non‑trivial.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_10.smt2",
    "description": "This instance encodes a safety‑property verification task generated by Ultimate Automizer for an SV‑COMP 2019 benchmark. It asserts that for the three 32‑bit input variables there exist nondeterministic values satisfying three linear bit‑vector equations, and then it negates a similar conjunction (with additional nondet variables); the solver must show the negated conjunction is unsatisfiable, i.e., the original property holds (unreachability/termination). The formula involves only existential quantifiers, modest term depth (≤ 7), and a handful of large constant multiplications, making it a typical industrial bit‑vector verification problem without deep quantifier alternations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_6_true-unreach-call_true-no-overflow_false-termination.i_18.smt2",
    "description": "This instance is a software‑verification condition generated by Ultimate Automizer for an SV‑COMP 2019 benchmark (the “jain_6” program). It encodes the safety/overflow property of the original C code as quantified 32‑bit‑vector arithmetic: a universally quantified equality over several nondeterministic inputs must never hold, and a second universal condition is negated to form the final check. The formula contains two ∀‑quantifiers over nine bit‑vector variables and uses only shallow linear combinations of constants, so the difficulty stems mainly from the quantifier structure rather than from a large number of variables or deep term nesting.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_2_true-unreach-call_true-no-overflow_false-termination.i_2.smt2",
    "description": "The instance is a bit‑vector verification query generated by Ultimate Automizer from an SV‑COMP 2019 benchmark. It encodes a small arithmetic safety property over two 32‑bit program variables, using existential quantifiers to model nondeterministic inputs and asserting that a certain combination of linear equations cannot simultaneously hold (i.e., checking the unreachability of an error state). The formula contains only a handful of quantified variables, shallow term depth (≤7) and simple multiplications/additions, making it a concise BV‑logic reachability/termination check.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_2_true-unreach-call_true-no-overflow_false-termination.i_12.smt2",
    "description": "This SMT‑LIB file encodes a software‑verification condition generated by Ultimate Automizer for an SV‑COMP 2019 benchmark. The problem checks a safety/termination property by asserting that a certain linear bit‑vector relation between program constants and nondeterministic inputs can never hold; it is expressed with two universally quantified formulas (one wrapped in a negation) over 32‑bit vectors. The instance is small (only two declared constants and a handful of quantified variables) with modest term depth, but the presence of nested universal quantifiers makes it a typical quantifier‑heavy BV verification challenge.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/073.smt2",
    "description": "This instance encodes a **verification‑by‑weakest‑precondition** problem generated by the PSyCO tool for a compiler‑optimisation transformation.  Boolean variables model reads (`R_*`) and writes (`W_*`) of five program variables in two program states (S1, S2) and an expression `E1`; a large quantified formula describes the relational constraints (including increment operations on 32‑bit vectors) that must hold for the transformation to be semantics‑preserving.  The final assertions ask the solver to show that the required disjointness and ordering conditions are contradictory, i.e., the optimization is unsafe.  The benchmark is a moderate‑size, industrial BV/Bool formula with deep nesting, many `ite`/`let` expressions, and a single universal quantifier, making it a non‑trivial case for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/133.smt2",
    "description": "This instance encodes a weakest‑precondition‑based verification of a compiler optimisation (the PSyCO benchmark suite, derived from Lopes & Monteiro VMCAI‑’14).  It checks that a transformed program fragment (the “S1” version) is equivalent to the original fragment (the “E1”/“E2” versions) by asserting a single quantified formula over 32‑bit variables together with a large collection of Boolean read/write and disjointness flags.  The problem features one universal quantifier, deep nesting of ite expressions, many bit‑vector arithmetic constraints (add, neg, signed comparisons) and a dense Boolean structure, resulting in high term depth (≈56) and a substantial number of Boolean connectives, making it a challenging industrial verification/synthesis task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/026.smt2",
    "description": "This instance was produced by the PSyCO weakest‑precondition synthesis tool for compiler optimizations and translated to the BV logic. It encodes a verification condition that the weakest precondition of an optimized program (with Boolean flags for reads/writes to variables V1‑V5 and disjointness constraints) implies the weakest precondition of the original program, using a single universal quantifier over 32‑bit values together with many nested ite, bvadd, bvneg, and relational predicates. The formula contains deep term nesting (depth ≈ 83) and a large number of auxiliary Boolean variables, making it a typical industrial BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/121.smt2",
    "description": "The file is a verification benchmark generated by the PSyCO weakest‑precondition synthesis tool for compiler optimisations.  It encodes, in the BV‑logic, a relational invariant between an original program (variables E1, E2) and a transformed version (variables S1) using a single universally‑quantified block that contains many `ite`‑based assignments, equality, and signed‑order constraints on 32‑bit vectors, together with Boolean read/write flags and disjointness conditions (e.g. DISJ_W_S1_R_S1).  The final query asserts the negation of a disjointness property, so a solver must check whether the transformation can violate the required read/write separation; the instance is large (≈18 k characters), has deep nesting (term depth 312), and combines hundreds of Boolean lets with bit‑vector arithmetic, making it a demanding industrial‑style verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/099.smt2",
    "description": "This instance encodes a weakest‑precondition verification condition for a compiler optimisation, generated by the PSyCO tool and translated to bit‑vector logic.  The formula relates old and new values of several 32‑bit program variables (V1…V5) under a rich set of possible read/write events, using many `ite`‑based equality constraints together with disjointness conditions (the DISJ_* Boolean flags) to enforce consistency of the transformation.  Although it contains only a single universal quantifier, the problem features a large number of Boolean control variables, deep nested ite‑expressions and a dense web of conjunctions/or‑disjunctions, making the SAT/SMT search highly combinatorial.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/052.smt2",
    "description": "This instance encodes a verification problem that originates from the PSyCO weakest‑precondition synthesis benchmark for compiler optimisations (VMCAI ’14).  It models a small program’s reads and writes as Boolean flags (R_/W_…) together with a large quantified safety condition over several 32‑bit variables, and adds numerous “disjointness’’ and consistency constraints between those flags.  The query asks whether any combination of read/write choices can violate the weakest‑precondition property, which requires reasoning about a single quantified formula with deep nested ite‑expressions, many Boolean disjunctions, and a high term‑depth (≈205), making it a challenging bit‑vector verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/075.smt2",
    "description": "This instance is a weakest‑precondition verification condition generated by the PSyCO tool for a compiler‑optimisation example (VMCAI‑14) and translated into the BV logic.  It encodes a large set of read/write, disjointness and ordering constraints on several abstract memory locations (the R_/W_ and DISJ_ booleans) together with a quantified “memory‑model” formula that relates the values of many 32‑bit vectors through nested ite and arithmetic expressions; the aim is to show that the combination of those constraints is inconsistent (the final asserts negate certain conjunctions).  The problem is therefore an industrial‑style BV verification task with a single deep forall, dozens of Boolean flags, heavy use of let‑bindings and ite‑chains, leading to a high term‑depth (≈165) and a dense propositional core that makes solving challenging.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/045.smt2",
    "description": "This instance is a verification condition generated by the PSyCO weakest‑precondition synthesis tool for a compiler optimisation.  It encodes a memory‑model safety proof: Boolean variables represent reads, writes and disjointness of several program locations (V1‑V5) across three program points (E1, S1, S2), while a single quantified formula ties together the corresponding bit‑vector values with many conditional (ite) updates.  The final check consists of a set of negated conjunctions that assert the consistency of the read/write‑disjointness constraints; the problem is therefore a SAT/SMT consistency check with a deep term structure (≈170 nesting), a large number of Boolean/disjunction constraints and one forall‑quantifier over many 32‑bit vectors, making it a difficult industrial‑style verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/086.smt2",
    "description": "The file is a verification benchmark generated by the PSyCO weakest‑precondition synthesis tool for a compiler‑optimisation case study (VMCAI ’14) and translated to the BV logic.  It models three program states (E1, S1, S2) with Boolean read/write flags for five variables (V1‑V5) and 32‑bit data values, and encodes a large memory‑consistency predicate (the single universal quantifier) together with many disjointness constraints that prohibit overlapping reads and writes.  The final assertions negate various conjunctions of these flags, so the solver is asked to prove that no illegal combination of reads/writes can occur – i.e., to check the safety of the optimisation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/079.smt2",
    "description": "This instance encodes a verification condition generated by the PSyCO weakest‑precondition synthesis tool for a compiler‑optimization scenario.  The formula asserts that a complex set of read/write flag selections, ordering relations and disjointness axioms (captured by many Boolean constants such as R_…, W_…, DISJ_…) can be satisfied together with a quantified bit‑vector consistency constraint over 32‑bit variables, while the final assertions negate several conjunctions to look for a counter‑example.  It is an industrial‑style SAT/UNSAT check featuring a single ∀‑quantifier, deep nesting of `ite`/`let` terms (max depth ≈ 165) and a large Boolean combination, which makes solving difficult despite the modest number of variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/115.smt2",
    "description": "This instance is a verification condition generated by the PSyCO weakest‑precondition synthesis tool for a compiler‑optimisation example. It encodes, with a single quantified block, the relation between source and transformed program states using many Boolean mode flags (W / R / DISJ) and 32‑bit integer variables, together with arithmetic constraints (increments, ordering checks) that must hold for every possible input valuation. The final negated assertions test whether any inconsistent selection of flags (e.g., a write flag true while its corresponding disjointness predicate is false) can be satisfied, making the problem a quantifier‑heavy, deep‑term SAT/UNSAT check typical of industrial program‑verification workloads.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/078.smt2",
    "description": "This instance is a verification problem generated by the PSyCO weakest‑precondition synthesis tool for a compiler‑optimisation case study (VMCAI '14).  It encodes the correctness of a transformation by relating Boolean read/write flags ( R_…  and W_… ) and a series of “disjointness’’ constraints, together with a single ∀ quantifier over many 32‑bit variables that models the effect of the program on the variables via nested ite expressions and a handful of signed‑bit‑vector comparisons.  The solver must decide whether a set of read/write selections can satisfy all the pre‑ and post‑condition equalities, making the instance a heavily Boolean‑and‑BV‑heavy industrial verification task with deep term nesting and a large number of auxiliary let‑bindings.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/060.smt2",
    "description": "This instance encodes a verification condition for a compiler optimisation generated by the PSyCO weakest‑precondition synthesis tool.  It uses a single universally quantified block over 32‑bit variables together with Boolean “write” and “read” flags to model the transformation’s effect on program state; the constraints enforce equality of original and transformed values, prevent division‑by‑zero and signed‑overflow in multiplications, and require the write‑set and read‑set to be disjoint (the DISJ_W_S1_R_S1 condition).  The solver must decide whether the combined bit‑vector arithmetic and Boolean side‑conditions are satisfiable, essentially checking the safety of the optimisation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/074.smt2",
    "description": "This instance is a verification problem generated by the PSyCO weakest‑precondition synthesis tool for checking the correctness of a compiler optimization. It encodes, with 32 Boolean read/write flags and 32‑bit variables, a single universally quantified weakest‑precondition condition together with a large set of disjointness and consistency constraints (the DISJ_* predicates) that must hold for two program versions; the final assertions negate some of those constraints to test unsatisfiability. The formula features deep nesting of ite‑expressions (term depth 165), many let‑bindings, and a handful of bit‑vector arithmetic operations, making it a dense, industrial‑style BV verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/056.smt2",
    "description": "The instance encodes a weakest‑precondition verification condition generated by the PSyCO tool for a compiler optimization (see “Weakest Precondition Synthesis for Compiler Optimizations”).  It checks that a proposed program transformation preserves the semantics of several memory reads and writes, using Boolean flags (e.g., R_E1_V4, W_S2_V5) and a large set of disjointness constraints (DISJ_…) that capture read‑write and write‑write conflicts.  The core formula contains a single quantified block over many 32‑bit variables with deep nested ite terms (term depth ≈ 205) together with numerous Boolean combinations, making the problem a hard industrial verification instance with high Boolean‑logic complexity.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/034.smt2",
    "description": "This instance comes from the PSyCO weakest‑precondition synthesis benchmark for compiler optimisations (VMCAI ’14) and encodes a verification condition that checks whether a proposed program transformation respects all read/write‑conflict and disjointness requirements.  The model uses a large set of Boolean flags (R_/W_ for reads, writes and DISJ_ for various “no‑overlap” conditions) together with a single quantified block over many 32‑bit variables, consisting of heavily nested `ite`‑expressions and arithmetic on bit‑vectors; the final part asserts several contradictory combinations of those flags to force the solver to prove unsatisfiability.  Because of the universal quantifier, deep term depth (≈170) and the huge number of Boolean disjunctions/conjunctions, the problem is a challenging industrial‑style verification task in the BV logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/172.smt2",
    "description": "This instance encodes the verification of a weakest‑precondition transformation for a small compiler optimisation (generated by the PSyCO tool).  It asserts, via a single universally‑quantified formula over 32‑bit values, that the read/write footprints (the Booleans W_* and R_*) and the version‑selection predicates (the MW_* flags) of two statements S₁ and S₂ are mutually consistent and preserve the required ordering and equality relations on the corresponding bit‑vector variables.  The problem features a deep nesting of conditionals (≈ 80 ite‑terms), a mix of arithmetic (bvadd, bvneg, signed comparisons) and many Boolean disjointness constraints, making it a demanding quantified‑BV verification task typical of industrial weakest‑precondition synthesis benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/119.smt2",
    "description": "This instance encodes a verification condition generated by the PSyCO weakest‑precondition synthesis tool for a compiler‑optimisation example.  A single universally‑quantified formula over 32‑bit bit‑vectors describes the relational semantics of three program fragments (S1, E1, E2) together with many Boolean write‑/read‑set and disjointness flags (W_*, R_*, DISJ_*).  The surrounding Boolean constraints assert that the write sets must be compatible with the read sets and that the disjointness conditions hold, and the final two top‑level assertions check whether a particular combination of these flags leads to a contradiction – i.e., whether the optimisation preserves the intended memory‑access safety property.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/185.smt2",
    "description": "This instance encodes a weakest‑precondition synthesis task for a small compiler optimisation (generated by the PSyCO tool and translated to bit‑vectors).  Boolean flags model whether each program variable is read or written in two program fragments, and a single quantified block defines the “new” values of the variables with many ite‑expressions, relational (signed‑order) constraints and consistency equalities that together enforce that the two fragments preserve the same behaviour.  The check asks whether a consistent assignment to the read/write flags exists, resulting in a heavily quantified, deep‑term BV verification problem typical of industrial compiler‑verification benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/092.smt2",
    "description": "This instance is a **verification** problem generated by the PSyCO weakest‑precondition synthesis tool (used to prove that a compiler optimisation preserves program semantics). It encodes read/write flags for several program variables together with a single universally‑quantified weakest‑precondition formula over 32‑bit values, and a large collection of “disjointness” Boolean constraints (e.g., DISJ_W_S1_R_E1, DISJ_W_S1_W_S2) that must hold simultaneously. The benchmark is sizable (≈27 k characters, 32 Boolean constants) and features a deep term structure (max depth 480), many nested `let`/`ite` expressions, and a quantified block with many bit‑vector and Boolean arguments, making it a challenging industrial‑style BV verification case.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/081.smt2",
    "description": "The instance is a verification condition generated by the PSyCO weakest‑precondition synthesis tool for a compiler optimisation, translated into a bit‑vector/Boolean encoding. It models reads and writes of several program variables over three abstract states (S1, S2, E1) with Boolean flags (R_…, W_…) and a single universally‑quantified clause that enforces value equalities via nested *ite* expressions and 32‑bit arithmetic, while additional “DISJ_” constraints express required disjointness between the flags. The resulting formula is a large, deep BV/Bool problem (≈ 18 k symbols, term depth 165) typical of industrial verification tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/122.smt2",
    "description": "This instance is a verification problem generated by the PSyCO weakest‑precondition synthesis tool for a compiler optimization.  It encodes, with BV variables and a single ∀‑quantifier, the semantics of a small program (read/write flags R_/W_ and value relations) together with a “disjointness” condition (DISJ_W_S1_R_S1) that should hold for all reachable states; the solver is asked to refute that condition (by asserting its negation) and to check whether the remaining constraints are still satisfiable.  The formula features many Boolean control flags, nested ite/let constructions, and several bit‑vector ordering predicates, leading to a deep term structure (depth ≈ 65) but only one quantifier alternation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/027.smt2",
    "description": "This instance encodes a weakest‑precondition verification problem for a compiler optimization (generated by the PSyCO tool and translated to bit‑vectors).  It checks that a set of read/write flags for two program states (S1, S2) and an expression E1 can be assigned consistently while respecting a large collection of disjointness and “read‑only” constraints, expressed through a single quantified formula over 32‑bit values and many Boolean control variables.  The formula features deep nesting of ite/let terms (depth ≈ 77), a mix of arithmetic (bvadd, bvneg, signed comparisons) and Boolean logic, and several quantifier‑free Boolean clauses, making it a challenging industrial‑style verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/123.smt2",
    "description": "This instance encodes a weakest‑precondition verification condition for a compiler optimisation (generated by the PSyCO tool and translated to 32‑bit bit‑vectors).  The formula asserts a complex combination of read/write flags, disjointness predicates and arithmetic ordering constraints over several program variables, wrapped inside a single quantified block that uses many nested ite, bvadd/bvneg and signed‑order comparisons.  The problem asks whether a particular violation of a disjointness condition (together with a few concrete read/write assignments) is satisfiable, featuring a deep term structure (depth 65), numerous Boolean connectives and one quantifier over 12 bit‑vector arguments, making it a challenging industrial‑style verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/094.smt2",
    "description": "This instance encodes a verification condition for a compiler optimisation generated by the PSyCO tool (as described in “Weakest Precondition Synthesis for Compiler Optimizations” (VMCAI ’14)).  The formula checks that the weakest‑precondition of the original program fragment (variables E1, S1) and of its transformed version (variables S2) are equivalent under a large set of Boolean flags that model reads, writes and mutual‑exclusion of accesses; the core is a single universally‑quantified block over 32‑bit inputs with many nested ite and bit‑vector arithmetic constraints.  The problem is therefore a BV‑based verification/synthesis task with deep terms (depth ≈ 102), a handful of quantifier occurrences, and a dense network of Boolean disjointness and consistency constraints, making it a challenging industrial benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/137.smt2",
    "description": "This instance encodes a verification condition generated by the PSyCO weakest‑precondition synthesis tool for a compiler‑optimization benchmark (VMCAI’14).  It asserts that a complex set of memory‑access predicates (reads R\\_* and writes W\\_*) remain mutually exclusive after a program transformation; the property is expressed as a huge universally‑quantified formula over 32‑bit bit‑vectors together with many Boolean “write‑mask” flags and arithmetic constraints (bvadd, bvneg, bvsle/bvsge).  The solver is asked to check the negation of the disjointness clause, so the instance is an UNSAT‑core style safety verification problem that is difficult because of a single deep quantifier, extensive let‑nesting (over 1 000 lets), and a term‑depth exceeding 1 000.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/160.smt2",
    "description": "This instance encodes a verification condition produced by the PSyCO weakest‑precondition synthesis tool for a compiler optimisation.  It checks that a set of Boolean write/read flags (W_S1_Vi, R_S1_Vi) together with a “disjointness” constraint (DISJ_W_S1_R_S1) are compatible with a quantified transition relation over 32‑bit variables, where successive versions of the state are related by conditional ite‑updates and simple arithmetic (increments and decrements).  The single forall quantifier contains many nested ite‑expressions, deep term nesting (depth 66) and a large Boolean combination, making the problem a non‑trivial SAT/unsat check of an invariant‑preservation property in an industrial‑style BV encoding.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/055.smt2",
    "description": "This benchmark encodes a verification condition for a compiler optimization (weakest‑precondition synthesis). Boolean flags model whether each program variable is read or written, and 32‑bit bit‑vectors represent their values; the formula asserts that for all possible selections of the write‑mask flags the transformed program state satisfies a large collection of equality, ordering and disjointness constraints between the original and optimized versions. The final checks negate several conjunctive combinations of these constraints, so the solver must prove unsatisfiability; the instance contains a single universal quantifier, deep nested ite‑terms, and many Boolean disjunctions, making it a hard industrial BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/167.smt2",
    "description": "This instance encodes a safety‑verification problem for a compiler‑optimization transformation generated by the PSyCO weakest‑precondition synthesiser.  The formula models reads and writes of several program variables (as Boolean flags) together with a single universally‑quantified specification over 32‑bit integers that relates the original and optimized states via many conditional (ite) updates and simple arithmetic constraints; the final query asks whether the “disjointness” condition between a write set of the optimized program and a read set of the original program can be violated.  The problem is an industrial‑style BV verification task, featuring a single quantifier, a deep term structure (depth ≈ 138) and a dense combination of Boolean, ite, and bit‑vector arithmetic constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/048.smt2",
    "description": "This instance comes from the PSyCO weakest‑precondition synthesis benchmark for compiler optimizations (VMCAI '14) and encodes a correctness‑verification problem for a program transformation.  It models reads and writes of several variables (the R_/W_ flags) together with a single universally‑quantified 32‑bit state transition that relates original and optimized values via many *ite* and arithmetic constraints, while also enforcing a collection of disjointness conditions (the DISJ_… Boolean flags).  The formula is a deep, highly nested BV problem (max term depth ≈ 500) with dozens of Boolean variables, a large number of let‑bindings, and a single quantifier, making it a demanding industrial verification case.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/015.smt2",
    "description": "This instance encodes a weakest‑precondition verification condition generated by the PSyCO tool for a compiler optimisation.  The formula asserts, with a single quantified block over 32‑bit variables, that the read‑ and write‑flags of two program fragments (S1 and S2) and their associated value relations (including arithmetic constraints) can be satisfied without violating disjointness, ordering, or value‑equality requirements.  The problem is a BV‑logic industrial verification task that features many Boolean flags, nested ite’s, and a deep term structure (depth ≈ 75), making the single universal quantifier particularly demanding for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/084.smt2",
    "description": "The instance comes from the PSyCO weakest‑precondition synthesis benchmark for compiler optimizations (VMCAI’14) and is encoded in the BV logic. It encodes a verification problem for a program transformation: a large collection of Boolean read/write flags for variables V1–V5 in two program fragments (S1, S2) and an expression (E1) must satisfy a single universally‑quantified weakest‑precondition formula together with many mutual‑exclusion (DISJ_…) and data‑dependence constraints, modeled with nested ite‑expressions and bit‑vector equalities. The formula features a deep term structure (max depth ≈ 165), numerous let‑bindings, disjunctions and a single ∀‑quantifier, making it a demanding industrial‑style SAT/SMT instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/046.smt2",
    "description": "This instance encodes a weakest‑precondition‑based verification of a compiler optimisation: a single universally‑quantified formula describes the semantics of two program versions (reads R_…, writes W_…, and their possible interleavings) using 32‑bit variables, while a large collection of Boolean “disjointness” constraints (DISJ_…) forces the reads and writes to be non‑interfering.  The problem, generated by the PSyCO tool and translated to pure bit‑vector logic, features a deep term structure (depth ≈ 170), many ite‑chains, and a mix of quantifier, arithmetic and Boolean reasoning, making it a challenging industrial‑style SAT/SMT verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/008.smt2",
    "description": "The file encodes an **industrial verification** problem that checks a compiler optimisation generated by the PSyCO weakest‑precondition synthesis tool (see Lopes & Monteiro, VMCAI ’14).  The core of the instance is a single universally quantified transition relation that relates pre‑state and post‑state 32‑bit variables (the S1, S2 and E1 versions) using many `ite`, `bvadd`, `bvmul` and equality constraints, together with a large set of Boolean “read/write” flags and disjointness axioms (e.g. `DISJ_W_S1_R_S2`).  The solver must decide whether the conjunction of this quantified semantics, the disjointness/consistency clauses and a small additional safety clause is satisfiable.\n\nThe benchmark is large and deep: 37 Boolean constants, 56 bit‑vector constants, 548 `let` bindings, 188 top‑level disjunctions/equalities, and a maximum term depth of 517.  The mixture of quantifiers, nested ite‑expressions and many inter‑dependent Boolean constraints makes it a demanding BV‑logic verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/050.smt2",
    "description": "This industrial benchmark encodes a weakest‑precondition verification condition generated by the PSyCO tool for a compiler‑optimization correctness proof. The formula models a small concurrent program with reads (R_*) and writes (W_*) to several versioned variables, introduces Boolean “disjointness” flags (DISJ_*) to capture coherence and ordering constraints, and uses a single quantified block over 32‑bit variables together with many nested ite‑expressions to enforce the intended data‑flow semantics. The top‑level assertions negate crucial conjunctions of these flags, so the solver must decide whether any combination of read/write selections can violate the memory‑model/optimization invariant; the problem is thus a verification (unsat) check featuring a deep quantifier‑free core (≈ 75 Boolean connectives) and a deep term structure (max depth 205), which makes it challenging for BV‑solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/125.smt2",
    "description": "This instance encodes a weakest‑precondition verification problem for a compiler optimization (generated by the PSyCO tool, see Lopes & Monteiro VMCAI‑14) in the quantifier‑free bit‑vector logic.  The formula asserts that a set of Boolean “read” and “write” flags for several program variables must be pairwise disjoint (the DISJ_W_S1_R_* constraints), while a large quantified block describes the effect of the transformation on 32‑bit values using many ite, bvadd and signed‑comparison relations.  The benchmark therefore tests the solver’s ability to handle a single deep ∀‑quantifier over dozens of bit‑vectors together with a dense network of Boolean conditions and arithmetic constraints, leading to high term depth (≈ 464) and a substantial number of Boolean connectives.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/035.smt2",
    "description": "This instance encodes a verification task generated by the PSyCO weakest‑precondition synthesis framework for a compiler‑optimization benchmark (VMCAI ‘14).  The formula asserts the correctness of a transformation by modelling reads, writes and disjointness of memory locations with Boolean flags and a single quantified “pre‑condition” over 32‑bit values, then adds a suite of negated conjunctions that force unsatisfiability if the transformation respects all interference constraints.  The problem is therefore an industrial safety‑checking instance with a deep, highly nested term structure (max depth ≈ 170) and many Boolean/ite combinations, but only one quantifier, making the main difficulty the combinatorial explosion of the Boolean discharge rather than quantifier instantiation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/058.smt2",
    "description": "This instance encodes a verification condition for a compiler‑optimization proof generated by the PSyCO weakest‑precondition synthesis tool.  It models reads and writes to several memory locations across two statements (S1, S2) and an expression (E1) using Boolean flags (R_/W_) and Bit‑vector values, and asserts a large collection of alias‑disjointness, ordering and equality constraints (including a quantified “for all” over the possible write‑selection masks).  The solver is asked to show that the conjunction of these constraints is unsatisfiable, i.e., that no illegal read/write interleaving can occur; the problem is challenging because of the deep ite‑heavy term structure, many Boolean combinations, and a single forall quantifier over 32‑bit vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/148.smt2",
    "description": "This benchmark comes from the PSyCO weakest‑precondition synthesis suite for compiler optimisations. It encodes a single program fragment with four 32‑bit variables and a collection of Boolean flags that indicate which assignments (writes) and reads occur in the source and transformed versions; the core constraint is a universally‑quantified formula expressing the program’s semantics and the required weakest‑precondition, built from many ite, bvadd and comparison terms. Additional propositional axioms enforce disjointness and consistency of the flags, and the solver is asked to check the overall satisfiability of this combined bit‑vector and Boolean specification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/110.smt2",
    "description": "This instance encodes a verification condition for a compiler optimisation: the weakest‑precondition synthesis performed by the PSyCO tool is translated into a single universally‑quantified bit‑vector formula that relates the original and transformed program states through many conditional (ite) updates, together with Boolean flags expressing which variables are read or written and disjointness constraints (the DISJ_… predicates) that enforce non‑interference.  The problem is essentially a safety‑verification check (do the read/write sets and value updates satisfy the required equivalences) expressed in BV‑logic with 27 declared Boolean constants, a deep term structure (depth ≈ 39) and a rich mixture of arithmetic (bvadd, bvneg) and relational (bvsle, bvsge) operators, making the single quantified assertion challenging for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/064.smt2",
    "description": "This instance encodes a weakest‑precondition verification problem for a compiler optimisation (generated by PSyCO) in the quantifier‑free bit‑vector logic. It models two program states (source S1, source S2, and an expression E1) with 32‑bit variables and a large collection of Boolean flags that indicate which variables are written, read or mapped; the constraints enforce equality of mapped values, disjointness of write/read sets, and consistency of the pre‑ and post‑conditions via many nested ite‑expressions. The query asks whether the combination of these invariants (including a universal condition over all possible 32‑bit inputs) can be satisfied, which is typical of an industrial verification‑synthesis benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/113.smt2",
    "description": "This instance encodes a weakest‑precondition verification condition for a compiler optimization (generated by the PSyCO tool).  Boolean flags (W_*, R_*) select which variables are written or read, while a single quantified block over 32‑bit vectors describes the semantics of several program statements and the required relationships between their before/after values; the formula also contains exclusive‑choice (“DISJ_…”) constraints that enforce that exactly one of the possible read/write alternatives is taken.  The final assertions ask whether any assignment violating those exclusivity conditions is possible, so the solver must handle a deep quantified bit‑vector formula with many ite‑branches, several dozen Boolean variables, and a moderate quantifier alternation depth, making it a non‑trivial industrial verification/synthesis benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/070.smt2",
    "description": "This instance encodes a weakest‑precondition verification condition for a compiler optimisation, generated by the PSyCO tool and translated into the bit‑vector logic.  Boolean flags model reads and writes of several memory locations (e.g. R_E1_V4, W_S1_V3) and a single quantified “forall” formula relates the original and transformed program states using many nested ite‑expressions, equality and arithmetic constraints, together with disjointness conditions (DISJ_*) that capture non‑interference between reads and writes.  The task is to decide whether the combined memory‑consistency and transformation‑correctness constraints are satisfiable; the problem is challenging due to a deep term structure (depth ≈ 85), a large number of Boolean combinations, and the presence of one universal quantifier.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/083.smt2",
    "description": "This instance encodes a weakest‑precondition verification problem for a compiler optimization, generated by the PSyCO tool (Weakest Precondition Synthesis for Compiler Optimizations) and then translated to the BV logic.  The formula models two program statements (S1, S2) and an expression (E1) with Boolean read/write flags and a large collection of “disjointness” constraints (DISJ_…) that enforce non‑interfering memory accesses, while a single quantified block expresses the semantic preservation conditions over 32‑bit variables and a set of mode‑selection Booleans.  The benchmark is industrial‑style, features a deep term nesting (depth ≈ 165), many let‑bindings and ite‑expressions, and relies on a single quantified prefix with many variables, making the SAT/SMT solving challenging despite the absence of quantifier alternation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/041.smt2",
    "description": "This instance encodes a verification condition generated by the PSyCO weakest‑precondition synthesis tool for a compiler optimisation (see Lopes & Monteiro VMCAI’14).  The formula models reads and writes of several program variables (the R_/W_ and DISJ_ booleans), the possible “may‑write’’ choices (MW_… flags), and the arithmetic relationships between original and transformed values using 32‑bit bit‑vectors; the goal is to prove that the transformed program preserves the required data‑flow and disjointness properties.  The benchmark is an industrial‑style verification problem with a single large forall‑quantifier, many Boolean choices, deep nested ite expressions (term depth ≈ 170) and numerous consistency/­conflict constraints, making it a challenging SAT/SMT instance for BV‑solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/126.smt2",
    "description": "The instance encodes a weakest‑precondition verification problem generated by the PSyCO tool (used for compiler‑optimization correctness). It asserts that a large universally‑quantified conjunction of bit‑vector equalities, inequalities and conditional updates (modeling reads, writes and data‑flow of several program variables) can coexist with a set of “disjointness” Boolean constraints linking write‑flags to read‑flags; the final check asks whether the disjointness condition for the S1 state can be violated while a particular write flag ( W_S1_V1 ) holds. The formula contains a single deep quantifier over dozens of 32‑bit vectors, over 100 Boolean operators (ite, and, or, not) and a term depth of 87, producing a heavily intertwined, industrial‑style verification problem that is challenging for quantifier‑handling SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/101.smt2",
    "description": "This industrial benchmark encodes a **verification of a weakest‑precondition synthesis** for a small three‑statement program (variables V1‑V5, statements S1, S2, and expression E1) generated by the PSyCO tool and translated to the BV logic.  The formula contains a single universally‑quantified block that ties together a large set of Boolean flags (read/write permissions, “must‑write” choices) and 32‑bit data variables via deep `ite` nesting, and a collection of disjointness and ordering constraints; the final assertions negate several conjunctions of these conditions, asking the solver to find a conflict‑free assignment.  The instance is notable for its high combinatorial density (≈ 200 let/ite/or/and nodes, term depth ≈ 190) and the mixture of bit‑vector arithmetic with many Boolean control variables, which makes it a challenging case for BV‑solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/190.smt2",
    "description": "This instance is a **weakest‑precondition synthesis / verification** problem taken from the PSyCO tool (see Lopes & Monteiro, VMCAI ’14) and translated to quantifier‑free bit‑vector logic.  It encodes a compiler‑optimisation scenario with Boolean flags for reads (`R_…`) and writes (`W_…`) of several program variables, and a single universal quantifier over a large tuple of 32‑bit registers that captures all possible concrete states.  The constraints consist of many intertwined equalities, ordering relations and “write‑must‑be‑consistent” clauses built from deep `ite`/`let` nestings (max term depth 147), yielding 57 top‑level assertions, 25 Boolean constants and a single ∀‑quantifier with dozens of variables – a characteristic pattern of industrial verification instances that makes solving comparatively hard.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/182.smt2",
    "description": "This instance comes from PSyCO’s weakest‑precondition synthesis for a compiler optimisation. It encodes, with a single universal quantifier, the relational specification between the original (“R_…”) and the optimised (“W_…”) states of several 32‑bit variables, using many conditional (ite) updates, bit‑vector arithmetic (add, mul, neg) and equality constraints, together with a disjointness condition that the sets of written and read variables must not overlap. The SAT check asks whether there exists a consistent assignment to the Boolean flags (the “W” and “R” control variables) that satisfies all these constraints, a moderately sized industrial verification problem with deep term nesting and numerous Boolean‑bit‑vector interactions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/154.smt2",
    "description": "This instance is a verification condition generated by the PSyCO weakest‑precondition synthesis tool for a compiler optimisation.  It encodes, as a single universally‑quantified formula over 32‑bit integers, the relationship between original and optimised program states together with a large set of conditional (ite) arithmetic constraints (additions, a multiplication by 2 and signed inequalities).  The Boolean variables model “write” and “read” flags, and the final assertion checks that the write‑set and read‑set are disjoint; the problem therefore tests the correctness of the optimisation under all possible inputs, featuring deep term nesting (depth ≈ 104) but only one quantifier alternation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/040.smt2",
    "description": "This instance encodes a verification problem for a compiler optimisation: it models the pre‑ and post‑states of three program fragments (the original, the source and the target) with Boolean flags for reads/writes of several variables and 32‑bit arithmetic on their values, then asserts that the weakest‑precondition relation (expressed via a large quantified formula with many nested ite‑terms) respects the required disjointness and ordering constraints. The final assertions ask the solver to refute a collection of contradictory combinations of those read/write and disjointness flags, so the task is to prove the transformation is semantics‑preserving. The encoding is industrial‑scale, featuring a single ∀‑quantifier, deep term nesting (depth ≈ 170) and dozens of Boolean and bit‑vector variables, making it a challenging BV verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/174.smt2",
    "description": "The file encodes a verification condition that comes from the PSyCO weakest‑precondition synthesis benchmark for a compiler optimisation.  It contains a single universally‑quantified formula over 32‑bit variables (V1…V5) and a lattice of Boolean “may‑write” / “read” flags (W_…, R_…), together with disjointness constraints between write‑ and read‑sets (the DISJ_… predicates).  The final query asks whether a state exists in which certain writes are absent while all the disjointness conditions hold, i.e. whether the optimisation preserves the intended behavior.  The problem is an industrial‑style verification instance in the BV logic, with one quantifier, many ite‑rich equalities, moderate term depth (≈55) and a relatively large Boolean flag space.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/076.smt2",
    "description": "The instance encodes a *compiler‑optimization verification* problem generated by PSyCO: it models reads ( R_* ) and writes ( W_* ) to five 32‑bit variables across three program points (S1, S2, and an expression E1), together with SSA‑style value copies, arithmetic updates, and disjointness conditions for the memory locations. The Boolean constraints capture the weakest‑precondition semantics of the transformation (e.g., ordering of reads/writes, equality of renamed values, and non‑interference of different statements), and the final assertions ask whether a certain combination of disjointness and consistency properties can be simultaneously satisfied, i.e., whether a counterexample to the optimization’s correctness exists. The formula is a large quantifier‑free BV problem (≈18 k characters, depth 165) with many nested ite’s, let‑bindings and a single universally quantified block, typical of industrial verification workloads.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/117.smt2",
    "description": "This instance is a verification/synthesis check for a compiler optimisation generated by the PSyCO weakest‑precondition tool. It encodes, with a single universal quantifier over several 32‑bit variables, the semantic preservation conditions of the optimisation together with a large Boolean control‑variable matrix (read/write flags, disjointness predicates) and asks whether a consistent assignment to those flags exists. The problem features deep let‑nested terms, many ite‑expressions and mixed arithmetic‑comparison constraints, making it a non‑trivial quantified BV verification task typical of industrial‑scale weakest‑precondition synthesis.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/077.smt2",
    "description": "This instance encodes a verification task for a compiler optimisation, generated by the PSyCO weakest‑precondition synthesis tool and translated into the BV logic. It models reads, writes and mode‑selection flags for several program variables, imposes disjointness constraints between them, and asserts that the transformed program’s weakest precondition together with these safety conditions is unsatisfiable (i.e., the optimisation preserves semantics). The problem features a single, heavily‑nested ∀‑quantifier over many 32‑bit bit‑vectors, deep ite‑chains, and numerous Boolean let‑bindings, yielding a term depth of 165 and a dense combination of Boolean and bit‑vector constraints that make it challenging for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/033.smt2",
    "description": "This instance is a verification condition generated by the PSyCO weakest‑precondition synthesis tool for a compiler‑optimization benchmark (VMCAI '14) and then encoded into the bit‑vector logic. It encodes a large quantified formula that relates source‑ and target‑state variables, models read/write accesses (R_/W_*) and various disjointness constraints (DISJ_*) over Boolean flags, and adds many ordering and equality constraints on 32‑bit values with nested *ite* and arithmetic operations. The problem features a single universal quantifier, deep nesting (term depth ≈ 170), dozens of Boolean flags and extensive use of ite/let, making it a demanding industrial‑style BV satisfiability/verification check.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/095.smt2",
    "description": "This instance encodes a weakest‑precondition verification problem for a compiler optimization (generated by the PSyCO tool and taken from the “Weakest Precondition Synthesis for Compiler Optimizations” paper).  The formula combines a single quantified block over 32‑bit variables that models the effect of a sequence of memory reads/writes (via many Boolean flags and ite‑terms) with a large propositional component that enforces disjointness of reads/writes and a set of ordering/overflow constraints on the bit‑vector values.  The resulting BV problem is industrial‑scale, featuring a deep term nesting (depth ≈ 190) and hundreds of Boolean connectives, making it a challenging SAT‑plus‑BV verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/150.smt2",
    "description": "This instance encodes a weakest‑precondition synthesis problem for a compiler optimisation (PSyCO “Weakest Precondition Synthesis for Compiler Optimizations”).  The formula checks whether a set of Boolean flags that describe the relationship between the original program (variables R_E1_*, R_S1_*) and the optimised version (flags W_S1_*) can satisfy a large universally‑quantified bit‑vector condition together with several “disjointness” and consistency constraints.  The problem is an industrial‑style verification query featuring a single ∀‑quantifier over 32‑bit vectors, deep term nesting (depth ≈ 236), many ite‑expressions and arithmetic operations, and a substantial Boolean circuitry, making it a demanding SAT/UNSAT check for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/006.smt2",
    "description": "This benchmark encodes a verification task for a weakest‑precondition synthesis problem generated by the PSyCO tool (see Lopes & Monteiro VMCAI’14).  The formula declares Boolean “weak‑precondition” flags ( W_* ) and “relevance” flags ( R_* ) for three program components (statements S1, S2 and expression E1) and asserts that they must satisfy a large collection of equalities linking pre‑ and post‑state 32‑bit variables, together with ordering constraints ( bvsge/bvsle ) and a set of disjointness conditions between the weak predicates of different components.  The core contains a single ∀‑quantifier over the bit‑vector state, many nested ite/let definitions and deep term nesting (depth 161), making it a non‑trivial BV‑verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20210330-PEak/no-extern-loop_unsat_subset/medium.smt2",
    "description": "This instance encodes an industrial‑scale verification problem from the PEak project (hardware rewrite‑rule synthesis) using the BV logic.  A single quantified formula builds a massive 144‑bit word from many input fields, extracts sub‑ranges, and checks a cascade of equality, inequality and conditional (ite) constraints against fixed constants together with a final equality on the output bits ‑ essentially asking whether a particular rewrite rule can ever produce the required result (the benchmark is known to be UNSAT).  The encoding features an extreme term depth (≈ 6 700), thousands of nested let‑bindings, hundreds of extracts and concatenations, and a mixture of arithmetic, logical and comparison operators, making it a very demanding bit‑vector verification task.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210330-PEak/no-extern-loop_unsat_subset/easy.smt2",
    "description": "The instance models a single hardware instruction encoding (a 144‑bit vector built from several small bit‑vectors, flags and 16‑bit operands) and, under a universal quantifier over seven 16‑bit inputs plus a clock‑enable flag and a data word, extracts fields, performs arithmetic (add, sub, mul, shifts), comparisons and conditionals, and finally asserts that the resulting output matches a given constant while a 6‑bit identifier (`ib_0`) equals a specific pattern. The overall goal is to show that this conjunction is unsatisfiable – i.e., to verify that a proposed hardware rewrite rule cannot violate the specified property. The formula is a deep, heavily let‑bound bit‑vector verification problem (term depth ≈ 1400, 345 extracts, 104 concats, one ∀ quantifier) typical of industrial hardware‑synthesis checks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20210330-PEak/extern-loop_unsat_subset/easy.smt2",
    "description": "This instance encodes a hardware‑rewrite‑rule verification problem from the PEak project.  A single universally‑quantified formula (over dozens of 16‑bit inputs, a Boolean clock enable and other control bits) builds a massive bit‑vector expression using extracts, concatenations, arithmetic, shifts and comparisons, then asserts that a particular combination of equalities and range constraints can never be satisfied.  The task is to show the formula is unsatisfiable – i.e., the rewrite rule preserves the circuit’s behavior – and the challenge comes from the very deep term nesting (depth > 10 000) and the large number of bit‑vector operations.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210330-PEak/no-extern-loop_sat_subset/easy1.smt2",
    "description": "This instance encodes a single‑quantified correctness check for a hardware rewrite rule in the PEak industrial benchmark suite.  It models a 192‑bit datapath by concatenating, extracting, and conditionally combining dozens of bit‑vector inputs (including instruction fields, constants, and control flags) with arithmetic, shifts, and multiplications, then asserts that a complex Boolean predicate over those derived values can never be violated.  The problem is essentially a bit‑vector verification task—testing whether the synthesized rewrite preserves the intended behavior—featuring a deep term structure (depth ≈ 4600), over two hundred thousand symbols, and extensive use of ite, extract, and concat operators, which make it challenging for solvers.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210330-PEak/no-extern-loop_unsat_subset/hard.smt2",
    "description": "This SMT‑LIB file encodes a single quantified correctness condition for a hardware rewrite rule (PEak benchmark) using 25 Bit‑Vector constants, dozens of control fields, and a massive cascade of concatenations, extensions, arithmetic and case‑analysis (ite) operators. The assertion builds a deep “instruction‑packet’’ from many sub‑words, performs a long sequence of arithmetic, logical and comparison checks, and finally requires an impossible combination of Boolean and arithmetic equalities, making the instance unsatisfiable; its term depth exceeds 158 000 with over 300 k auxiliary let‑bindings. The problem is therefore an industrial‑scale hardware verification task, stressing solvers with deep nesting, extensive bit‑vector manipulation, and a single forall‑quantifier.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210330-PEak/extern-loop_sat_subset/medium2.smt2",
    "description": "This instance comes from the PEak hardware‑rewrite‑rule synthesis benchmark and encodes the verification of a single rewrite rule for a bit‑vector datapath.  It asserts, under a universal quantifier over all input words, that the original and rewritten hardware descriptions (built from many concatenations, extracts, muxes, arithmetic, shifts, and a large opcode case‑statement) are equivalent; additional constraints fix a concrete “instruction‑bundle” constant (ib_5) and several control flags.  The problem is thus a large BV‑SAT/validity check with deep term nesting (over 100 k term depth) and massive use of ite/concat/extract, typical of industrial hardware equivalence verification.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210330-PEak/no-extern-loop_sat_subset/easy4.smt2",
    "description": "This instance is a large‑scale bit‑vector verification problem generated by the PEak hardware rewrite‑rule synthesis suite. It asserts a single universally quantified formula over dozens of 16‑ and 84‑bit inputs that models a datapath with condition codes, ALU, multipliers and multiplexers, and then checks that the resulting output bits (including ib_6, ob_6 and PE_wrapped_if_10) equal specific constant patterns for all possible inputs. The formula is heavily composed of nested extracts, concatenations, ite‑branches and arithmetic‑shifts, leading to a deep term‑tree and a highly complex industrial‑style SAT check.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/llvm13-smtlib/08.smt2",
    "description": "This instance is an industrial verification benchmark derived from LLVM’s **ConstantRange** analysis (the “umax” operation that computes the smallest interval containing the element‑wise maximum of two intervals).  It asks whether there exists an interval R that is **strictly smaller** than the computed union of two non‑wrapped intervals N₁ and N₂ yet still **contains every maximum** umaxInt(n₁,n₂) for all n₁∈N₁ and n₂∈N₂.  The model encodes 16‑bit unsigned integers as 32‑bit interval bit‑vectors, defines predicates for emptiness/fullness, containment, size, and the “umax” interval, and includes a single quantified assertion; the formula is shallow (term depth 7) with a modest number of variables and no deep quantifier alternations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/llvm13-smtlib/07.smt2",
    "description": "This instance encodes a verification condition for LLVM’s `ConstantRange` unsigned‑maximum operation. It asserts that for two non‑wrapped 32‑bit intervals N₁ and N₂, the abstract interval R (which must be strictly smaller than the naive union of the operands) contains the unsigned maximum of any pair of concrete values drawn from N₁ and N₂, while also respecting the special cases of empty and full sets. The problem is an industrial BV‑logic verification query with a single quantifier, a handful of bit‑vector operations, and moderate term depth.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/llvm13-smtlib/03.smt2",
    "description": "The instance encodes a verification condition taken from LLVM’s ConstantRange implementation. It models 8‑bit integer intervals (with possible wrap‑around) and their sign‑extension to 12‑bit intervals, and asserts that the sign‑extended interval is at least as large as a given 12‑bit interval R and that every element of the original interval, when sign‑extended, is contained in R. The problem is a quantifier‑free BV verification task (with a single universal quantifier over the 8‑bit domain) involving interval‑containment predicates, size calculations, and sign‑extension logic, typical of industrial verification of compiler optimizations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/llvm13-smtlib/05.smt2",
    "description": "This instance encodes a verification condition from LLVM’s ConstantRange implementation. It models integer intervals as 64‑bit (and extended 72‑bit) bit‑vectors, defines operations for extracting bounds, testing emptiness/full‑wrap, containment, and computing interval size, then asserts that a transformed interval R is strictly smaller than the zero‑extended version of a source interval N while simultaneously requiring every element of N (zero‑extended) to belong to R. The problem therefore checks the consistency of an interval‑shrinking optimization and features a single universal quantifier over a bounded bit‑vector domain with modest term depth.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/llvm13-smtlib/01.smt2",
    "description": "This instance encodes a verification condition extracted from LLVM’s `ConstantRange.cpp`, checking the correctness of a sign‑extension transformation on integer intervals. It asserts that (i) an interval’s low and high bounds being equal implies the interval is either the full set or empty, (ii) the size of a 64‑bit interval R is strictly smaller than the size of the sign‑extended version of a 32‑bit interval N, and (iii) every element of N is also contained in the sign‑extended interval R (expressed with a universal quantifier). The problem is a small‑scale BV verification task involving interval arithmetic, wrapping semantics, and a single quantified implication, typical of industrial verification of compiler optimizations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20210301-Alive2/oggenc/363_oggenc.smt2",
    "description": "This instance is a bounded translation‑validation query generated by Alive2 for the LLVM‑based **oggenc** optimizer (PLDI '21). It asks whether a proposed compiler rewrite preserves the exact bit‑vector semantics of the original code, modelling undefined values, potential overflows, and arithmetic operations (add, mul, div, shifts) with a huge number of concatenations, extracts and nested ite‑expressions. The formula contains a single universal quantifier over dozens of “undef” variables, deep term nesting (depth ≈ 243) and thousands of bit‑vector operations, making it a challenging industrial‑scale verification problem.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210301-Alive2/oggenc/386_oggenc.smt2",
    "description": "This instance is a bounded translation‑validation query generated by the Alive2 tool for an LLVM optimization in the OggEnc audio encoder. It encodes the equivalence of the original and optimized 32‑bit integer code, modeling possible undefined values with many “undef” variables and a large universally quantified block. The check involves deep, nested bit‑vector arithmetic (adds, muls, divisions, extracts, concatenations) and a single quantified formula, making it a challenging industrial verification problem for SMT solvers.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210301-Alive2-partial-undef/sqlite3/773_sqlite3.smt2",
    "description": "This instance is a bounded translation‑validation query generated by Alive2 for an LLVM optimization that manipulates error‑code constants (POSIX and SQLite I/O errors) with partially undefined bit‑vectors. It asks a single quantified SMT‑BV formula to prove that the source and transformed code produce identical results under all possible undefined‑value assignments, encoding the equivalence with numerous bit‑wise masks, conditionals, and Boolean guards. The problem features a deep term structure (depth ≈ 52), a modest number of variables, but extensive nesting of let‑bindings, ite‑expressions, and logical operators, making it a non‑trivial verification task for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20210301-Alive2-partial-undef/ph7/626_ph7.smt2",
    "description": "This instance is a bounded translation‑validation query generated by the Alive2 verifier for an LLVM compiler optimisation (the “Alive2‑partial‑undef” benchmark). It encodes, under a single universal quantifier over many “undef” bit‑vector placeholders, a large conjunction of equality checks that compare the original and transformed values after masking and combining undefined bits with bvand/bvor, effectively testing whether the optimisation preserves semantics despite undefined behaviour. The formula features a very deep term structure (depth ≈ 165), hundreds of let‑bindings, many nested ite‑expressions and disjunctions, which make it a challenging bit‑vector verification problem for SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20210301-Alive2-partial-undef/ph7/659_ph7.smt2",
    "description": "This instance is a **translation‑validation / equivalence check** generated by the Alive2 tool (a bounded LLVM optimizer‑verification framework). It encodes a comparison between two 32‑bit bit‑vector fragments that involve many *partial‑undef* placeholders (the `undef!…` constants) and Boolean flags (`isundef_%c`, `np_%c`), translating the compiler’s conditional arithmetic into a large quantified formula with nested `ite`, `bvand`, `bvor`, and signed‑less‑or‑equal (`bvsle`) tests. The query stresses the solver with a single universal quantifier over the undefined values, deep term nesting (depth ≈ 81), dozens of `let` bindings and a rich combination of relational constraints, making it a typical industrial‑scale verification problem for bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-tptp/NUM917=1.smt2",
    "description": "This instance encodes a tiny quantified arithmetic check in 32‑bit bit‑vector logic: it asserts the negation of the claim that for every pair of bit‑vectors U and V there exists a bit‑vector W satisfying U − W = V. In other words, it asks whether subtraction is not surjective over 32‑bit values. The benchmark contains a single quantified assertion (∀∃) with only one subtraction term, yielding a shallow term depth and very few symbols, making it a minimal verification‑style test of basic BV arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20210330-PEak/no-extern-loop_sat_subset/medium2.smt2",
    "description": "The file encodes a hardware‑verification instance from the PEak rewrite‑rule synthesis benchmark: a single universally‑quantified assertion checks that two large BV circuits (a datapath built from multiplexers, ALU, LUT, multiplier, and constant fields) produce identical outputs for every possible combination of instruction bits, immediate data and control flags.  The problem is thus a SAT‑style equivalence check (no external loop) over a single quantified block with dozens of 16‑, 8‑ and 2‑bit vectors, heavily using `extract`, `concat`, nested `ite`s and arithmetic/comparison operators, which yields a massive term depth (> 130 k) and a very dense bit‑vector formula.  Its difficulty stems from the deep, highly structured term graph and the need to reason about many intertwined bit‑vector manipulations in order to prove the rewrite rule preserves the hardware’s functional behavior.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210330-PEak/extern-loop_unsat_subset/medium.smt2",
    "description": "This instance comes from the PEak project (hardware rewrite‑rule synthesis) and encodes a single quantified verification condition over a large BV‑state built from many 16‑bit data words, control bits and multiplexers. The formula concatenates dozens of sub‑words, applies a cascade of arithmetic (add, mul, shifts, extensions) and logical (and, or, ite) operations, and finally asserts that a particular output pattern (including a wrapped‑if flag) must equal a constant; the benchmark is labeled *unsat*, meaning the property is intended to hold for all possible inputs. The problem is industrial‑scale, with a term depth over 200 k, tens of thousands of `ite`/`let` nodes and a dense mix of bit‑vector operators, making it a challenging case for BV solvers.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210301-Alive2/oggenc/283_oggenc.smt2",
    "description": "This instance is a **compiler‑optimization verification** query generated by the Alive2 tool for the `oggenc` audio encoder (an LLVM IR transformation). It asks whether the original sequence of 32‑bit bit‑vector operations (adds, multiplies, extracts, concatenations, divisions and signed‑less‑or‑equal tests) is semantically equivalent to the optimized version, universally quantified over all possible “undef” values that may appear in the code. The problem is thus a large, deeply nested BV‑logic refinement check with many quantifier alternations, heavy use of `concat`/`extract`, and overflow/zero‑extension constraints that make the solving task challenging.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210330-PEak/no-extern-loop_sat_subset/medium0.smt2",
    "description": "This instance encodes a **hardware rewrite‑rule verification/synthesis** problem from the PEak benchmark suite.  It asserts, via a single quantified formula, that a complex bit‑vector transformation (built from dozens of concatenations, extracts, multiplexers, arithmetic and comparisons on an 840‑bit input and several 16‑bit sub‑fields) respects a set of functional constraints (e.g., bounds, equality and sign/zero extensions).  The formula is extremely large and deep (over 275 k term depth, tens of thousands of ite/extract/let nodes), which makes it a difficult industrial BV‑SAT/SMT challenge for solvers.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210330-PEak/extern-loop_sat_subset/hard0.smt2",
    "description": "This instance encodes an industrial‑strength hardware‑rewrite‑rule verification problem from the PEak benchmark suite.  Using the BV logic, it asserts a single universally‑quantified formula that concatenates, extracts, extends, and multiplies dozens of 16‑ and 66‑bit vectors, with thousands of nested ite, and, or, bvadd, bvmul, bvshl/ashr, and comparison operations, yielding a term depth of over 170 k.  The solver must decide whether the complex bit‑level constraints (including specific input patterns and output flags) hold for all possible inputs, a task that stresses SAT/SMT engines on both quantifier handling and deep bit‑vector reasoning.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210330-PEak/no-extern-loop_sat_subset/medium1.smt2",
    "description": "This instance encodes a **hardware rewrite‑rule verification** problem from the PEak (Peak‑Rewrite‑Rule‑Synthesis) benchmark suite.  It models a datapath built from dozens of 8‑, 16‑, 32‑ and 64‑bit vectors, with a large quantified block that concatenates many control, mux, ALU and constant fields, then checks that the resulting output (`ob_2`) is equal to a particular constant (`#b1`) under a complex combination of bit‑vector arithmetic, shifts, extensions and conditionals.  The formula lives in the **BV** logic, contains a single universal quantifier over many input bits, and features extremely deep nesting (over 130 k term depth) with thousands of extracts, concatenations and ite‑expressions, making it a heavyweight industrial‑scale verification case.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node677435.smt2",
    "description": "This instance is a verification condition derived from the KeYmaera hybrid‑system proof of a “safe intersection” controller.  After translation to 32‑bit bit‑vectors, it checks that, for all admissible parameter values (non‑negative speeds, distances, and timing bounds), a safety inequality involving non‑linear terms (quadratic speed products divided by a linear expression) holds; the formula is expressed as the negation of an existential clause, so the solver must prove the existential is unsatisfiable.  The benchmark comes from the industrial Preiner‑Keymaera family, features a single quantified block, 19 bit‑vector variables, mixed linear/non‑linear arithmetic (multiplication, division, comparisons), and a moderate maximal term depth (≈20), making it a representative hard case for BV solvers handling non‑linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/ETCS-essentials-node4106.smt2",
    "description": "This benchmark encodes a verification condition taken from the KeYmaera hybrid‑system verifier (ETCS‑essentials, node 4106) that has been translated into 32‑bit bit‑vector arithmetic. The formula, after an outer negation, asks the solver to show that there is **no** assignment to a quantified time variable that can satisfy a collection of nonlinear constraints involving many multiplications, divisions and linear inequalities over bit‑vectors. It contains a single existential quantifier, deep nonlinear terms (depth ≈ 16) and numerous bvmul/bvsdiv operations, making it a challenging industrial‑style non‑linear BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node24127.smt2",
    "description": "This instance encodes a safety verification condition from the KeYmaera hybrid‑system verifier (the “intersection‑example‑onelane” proof), translated into 32‑bit bit‑vector arithmetic. The formula checks, under a collection of linear and non‑linear (quadratic multiplication and a division) bounds on positions, velocities, and time variables, whether an existential time point can violate the required safety inequalities; it is expressed as a single quantified assertion in the BV logic. The problem features a moderate number of variables (13), a deep term structure (depth 23), and mixed arithmetic‑inequality constraints, making it a non‑linear, industrial‑style verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20210330-PEak/extern-loop_sat_subset/hard1.smt2",
    "description": "This SAT‑core instance comes from the PEak project (hardware rewrite‑rule synthesis) and models a datapath rewrite rule for a processor unit, with numerous bit‑vector signals such as condition codes, multiplexers, signed flags, and a multiplier.  The single top‑level assertion is a massive quantified formula (∀ over dozens of 16‑bit data words and Boolean controls) that builds a deep expression using extracts, concatenations, arithmetic, comparisons and a cascade of ite‑branches to enforce functional equivalence of the original and rewritten hardware.  Because of the universal quantifier, the huge term depth (≈ 620 k) and the massive number of ite/concat/extract operations, the problem is a very large, industrial‑style BV verification/synthesis challenge.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node532347.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system prover (a “simple intersection” example) that has been translated into 32‑bit bit‑vector arithmetic. The formula asserts that no time value can exist that simultaneously satisfies a collection of bounds on positions, velocities, and parameters—constraints that involve both linear relations and non‑linear operations such as multiplication and signed division. It features a single existential quantifier over a bit‑vector, 19 declared constants, moderate term depth (≈20), and a dense mix of arithmetic and ordering predicates, making it a typical industrial‑style BV verification problem that challenges solvers with non‑linear arithmetic and quantified reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node385461.smt2",
    "description": "This benchmark is a verification condition taken from the KeYmaera proof of a “safe‑intersection” hybrid‑system model.  The SMT‑LIB file encodes the condition as a single quantified bit‑vector formula (BV 32) that mixes non‑linear operations (multiplication, signed division) with a number of linear comparisons, representing constraints on vehicle positions, velocities and timing parameters.  The task is to show the negated existential is unsatisfiable, i.e., that the safety property holds; the instance is industrial‑style, features a single quantifier, moderate term depth (≈19) and a mix of arithmetic and Boolean structure that makes it a challenging non‑linear BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node601999.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems verifier (the “intersection‑example” from the safe‑intersection case study) as a 32‑bit bit‑vector formula. The query asserts the negation of an existential condition over a time variable, combining numerous non‑linear arithmetic constraints (multiplication, division) and linear inequalities on positions, velocities, and system parameters, together with several range bounds (e.g., non‑negativity, upper limits). It therefore tests a bit‑vector solver’s ability to handle quantified, non‑linear arithmetic and a moderate number of variables (19) with relatively deep term nesting (depth 21) in an industrial‑style verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node252045.smt2",
    "description": "This benchmark is a safety‑verification condition extracted from the KeYmaera hybrid‑system prover (the “intersection‑example” for vehicle crossing) and translated into 32‑bit bit‑vector arithmetic. It asserts that no assignment to an existential time variable can satisfy a collection of non‑linear constraints—positivity and upper‑bounds on several variables, a quadratic term (v₂·v₂)/(2·B), and several relational bounds linking the vehicle states—thus checking the unsatisfiability of the existential formula. The instance contains a single quantifier alternation, non‑linear multiplication/division, 20 bit‑vector constants and a maximum term depth of 21, making it a representative industrial verification challenge.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node365475.smt2",
    "description": "This instance encodes a safety verification condition from the KeYmaera hybrid‑system prover (the “intersection‑example” benchmark) after translation to 32‑bit bit‑vectors. The single quantified formula asserts that, given non‑negative parameters and bounds (A, B, V, ep > 0) and quadratic expressions built from the variables (e.g., v₁·v₁, v₂·v₂) the reachable states satisfy a set of linear and non‑linear inequalities; the outer “not ∃” checks that no counterexample exists. Consequently, the problem is a non‑linear arithmetic verification task expressed in the BV logic, featuring one existential quantifier, moderate term depth (21), about 19 bit‑vector variables, and a dense conjunction of arithmetic constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node21762.smt2",
    "description": "This benchmark encodes a safety verification condition for a one‑lane traffic‑intersection hybrid system (the “intersection‑example‑onelane” from KeYmaera). The formula is a single quantified (∃ ts) bit‑vector assertion that combines numerous bounded‑range constraints with non‑linear arithmetic (multiplication, division) over 32‑bit words, checking that no reachable state violates the safety invariant. The presence of a quantifier together with deep, nested non‑linear BV operations makes the instance challenging for solvers despite the modest number of variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node391949.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems tool (the “intersection‑example” proof node) as a single quantified bit‑vector formula. The goal is to show that, under a collection of non‑linear arithmetic constraints (squared velocities, products with a time variable, and several linear inequalities), no assignment to the existential time variable can violate the safety bounds—i.e., the formula is unsatisfiable. The instance features 32‑bit bit‑vectors, non‑linear multiplications and a division, one existential quantifier, and a relatively deep term structure, making it a challenging industrial QF_BV‑with‑quantifiers problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/binary_driver-2007-10-09-node8745.smt2",
    "description": "This benchmark encodes a safety verification condition generated by the KeYmaera hybrid‑system prover for the “binary_driver” example; the original real‑valued VC was translated to 32‑bit bit‑vectors by Mathias Preiner. The single assertion states that no 32‑bit value for the variable ts₁ can satisfy a large conjunction of non‑linear arithmetic constraints (quadratic terms, products of several variables, and integer divisions) together with numerous linear bounds, effectively checking a universally‑quantified property. The instance is medium‑sized (15 constants, term depth 23) but difficult for solvers because it combines non‑linear bit‑vector arithmetic with an existential quantifier inside a negation, typical of industrial verification problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node622752.smt2",
    "description": "This benchmark encodes a verification condition from the KeYmaera hybrid‑systems prover (the “safe intersection” example) as a single, negated existential formula over 32‑bit signed bit‑vectors. It asserts that, under a host of non‑linear constraints involving squares and divisions of velocity variables, positivity bounds, and timing relationships, no witness can violate the safety invariant; thus the solver must prove the formula unsatisfiable. The instance is an industrial‑style BV problem featuring one quantified variable, mixed signed comparisons, and several multiplications/divisions, giving a moderate term depth (20) and a substantial non‑linear arithmetic component that makes it challenging for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/bouncing-ball-simple-node5587.smt2",
    "description": "This instance encodes a verification condition from the Keymaera “bouncing‑ball‑simple” benchmark (node 5587), translated from real‑valued hybrid‑system dynamics into 32‑bit bit‑vector arithmetic. The formula asserts the negation of an existentially quantified state variable, requiring that a set of non‑linear constraints—quadratic multiplications, mixed addition/subtraction, and divisions—cannot be satisfied, effectively checking a safety invariant. The problem features a single quantified block, several non‑linear bvmul terms, and a moderate term depth (19) on a modest number of variables, making it a challenging non‑linear BV verification query.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node672522.smt2",
    "description": "This benchmark encodes a verification condition for the “safe‑intersection” hybrid‑system example from the KeYmaera tool.  The condition is expressed in the BV logic as a negated existential formula that combines non‑linear arithmetic (multiplications and signed divisions) with many bounded‑range constraints on positions, velocities and timing variables, and includes a single quantifier over a time step.  The instance therefore tests a solver’s ability to handle non‑linear bit‑vector arithmetic and quantifier reasoning on a modestly sized (19 constants, depth 21) industrial‑style verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node550504.smt2",
    "description": "This benchmark encodes a safety verification condition from the Keymaera hybrid‑system verifier (the “intersection‑example‑simple” proof node) as a quantifier‑free bit‑vector problem with a single existential quantifier. The formula asserts that, under a large conjunction of bound constraints (non‑negative variables, upper bounds V, and relationships such as xI2 > x2 + v2²/(2·B)), there exists a time‑step ts2626uscore0 satisfying additional linear and non‑linear (multiplication, division) BV arithmetic; the outer ¬∃ turns the check into an unsatisfiability proof of that existential witness. It features moderate size (19 constants, term depth 20) but includes non‑linear BV operations and a quantifier, making it a representative industrial verification instance for non‑linear arithmetic solving.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/bouncing-ball-simple-node5981.smt2",
    "description": "This benchmark encodes a verification condition from the KeYmaera “bouncing‑ball‑simple” example (node 5981) that was translated into 32‑bit bit‑vector arithmetic. The formula asserts, under a collection of linear bounds and quadratic relationships among time, height and velocity variables, that no value of the auxiliary time variable can violate the safety invariant (non‑negative height and velocity constraints), i.e. it checks the unsatisfiability of an existentially quantified counterexample. The instance therefore represents a non‑linear arithmetic verification problem expressed in the BV logic, featuring a single quantifier and moderate term depth (18) with several multiplied and squared terms.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node351731.smt2",
    "description": "The benchmark encodes a safety verification condition generated by the KeYmaera hybrid‑system prover for a simple traffic‑intersection example. After translation to 32‑bit bit‑vectors, the formula contains non‑linear multiplications, a division, and many positivity and range constraints on the system’s state variables; the outermost “not (exists …)” forces the solver to prove the original condition holds (i.e., the existential part is unsatisfiable). The instance has a single existential quantifier, moderate term depth (20) and a dense mix of arithmetic operations, making it a non‑linear BV verification problem from an industrial source.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node44538.smt2",
    "description": "This benchmark encodes a verification condition from the KeYmaera hybrid‑systems tool (the “intersection‑example‑onelane” safety proof). The goal is to show that, for all values of the quantified time variable, a set of nonlinear relations among 32‑bit bit‑vector variables (positions, velocities, constants, and time bounds) holds; the formula contains several multiplications and divisions, nested let‑bindings, and a combination of linear and non‑linear inequalities. It is an industrial‑style BV instance with a single existential quantifier, deep term nesting (depth 24) and many non‑linear arithmetic operations, making it a challenging case for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node172099.smt2",
    "description": "This instance is a bit‑vector encoding of a verification condition generated by the KeYmaera hybrid‑system verifier for a “safe intersection” traffic‑control example. It asserts (via a negated existential) that a set of time, position and velocity variables stay within prescribed bounds while satisfying non‑linear relations (multiplication, division) and several arithmetic inequalities, thus checking the satisfiability of the safety VC. The problem features a single existential quantifier, moderate‑size (≈20 variables) but deep (term depth 20) non‑linear bit‑vector arithmetic, making it a representative industrial benchmark for BV‑solver handling of hybrid‑system invariants.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node488227.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems prover (the “intersection‑example‑simple” proof). The goal is to show that a quantified formula over 32‑bit bit‑vectors—containing many chained inequalities, non‑linear multiplications, a division, and several relational constraints on velocities, positions and timing variables—is unsatisfiable, i.e., that the vehicle‑intersection safety property holds. The instance features a single existential quantifier, a deep term structure (depth 22) and non‑linear bit‑vector arithmetic, making it a challenging industrial‑level verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node32497.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system verifier (the “intersection‑example‑onelane” case). The goal is to prove that no assignment to a quantified time variable can violate a set of linear and non‑linear 32‑bit bit‑vector constraints describing vehicle positions, speeds, and timing at a traffic intersection; consequently the outer `not (exists …)` must be unsatisfiable. The instance features a single quantified block, a let‑binding, several multiplications and a division, and a moderate term depth (21) over 13 bit‑vector constants, making it a non‑linear arithmetic verification problem of industrial origin.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node267466.smt2",
    "description": "This instance is a verification condition extracted from a KeYmaera hybrid‑system proof (a safety proof for a traffic‑intersection scenario). After translation to 32‑bit bit‑vectors, the formula asserts that **no** assignment to a time‑step variable can satisfy a conjunction of linear and non‑linear arithmetic constraints (including multiplication, division and several inequality bounds) that would violate the safety invariant. The benchmark therefore tests a BV solver’s ability to handle a single existential quantifier, deep nested terms (depth ≈ 20), and mixed‑sign, non‑linear arithmetic typical of industrial hybrid‑system verification problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node248047.smt2",
    "description": "The benchmark encodes a safety verification condition taken from a KeYmaera hybrid‑system proof for a simple traffic‑intersection example. It is a single quantified formula over 32‑bit bit‑vectors that asserts the non‑existence of a time instant satisfying a conjunction of non‑linear arithmetic constraints (multiplication, division and kinematic relations) together with numerous non‑negativity and bound conditions on positions, velocities and timing parameters. The instance contains one existential quantifier, deep Boolean nesting (depth ≈ 20) and non‑linear BV arithmetic, typical of industrial verification problems derived from hybrid‑system models.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node38802.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system prover (the “intersection‑example‑onelane” proof node) as a 32‑bit bit‑vector formula. The query asserts the negation of an existentially quantified conjunction of linear and quadratic arithmetic constraints (additions, multiplications, divisions) over a handful of constants, and ends with a disjunction that compares a vehicle‑position variable against a complex nonlinear expression. The instance is industrial‑style, features deep term nesting (depth 24) and many nonlinear bit‑vector multiplications, making it a challenging non‑linear arithmetic verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node253609.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system prover (the “intersection‑example” from a traffic‑intersection case study) that has been translated into 32‑bit bit‑vector arithmetic. The formula asserts that, under a range of non‑negative bounds on several state variables, a set of linear and non‑linear (multiplication and division) relationships guarantees the required inequality; it is wrapped in a single existential quantifier over a time‑step variable. The problem therefore tests BV solvers on a quantified, non‑linear arithmetic instance with moderate size (20 constants, depth 21) typical of industrial hybrid‑system verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node6814.smt2",
    "description": "This instance encodes a safety verification condition for a hybrid‑system model of a one‑lane traffic intersection (the “intersection‑example‑onelane” proof from the KeYmaera tool suite). After translating the original real‑valued dynamics into 32‑bit bit‑vectors, the formula asserts that no choice of a time variable can violate a collection of linear and non‑linear (bit‑vector multiplication) constraints on positions, velocities and timing bounds; the outer negation makes the problem a SAT query for the validity of the safety property. The benchmark is an industrial‑style verification task with a single existential quantifier, 13 bit‑vector constants, moderate term depth (21) and a handful of non‑linear arithmetic operations, which together give it a typical difficulty for BV solvers handling quantified non‑linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node99986.smt2",
    "description": "This instance encodes a verification condition generated by the KeYmaera hybrid‑systems prover for a “safe intersection” example. After translating the original real‑valued non‑linear arithmetic into 32‑bit bit‑vectors, the formula asserts that no assignment to a time‑step variable can satisfy a conjunction of linear equalities and inequalities involving several system parameters (position, velocity, constants A, B, etc.). Hence the SAT check is used to prove safety of the hybrid model; the problem features a single existential quantifier, moderate term depth (18), and 19 bit‑vector variables, typical of industrial verification benchmarks derived from hybrid‑system analysis.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node271799.smt2",
    "description": "This benchmark encodes a safety verification condition generated by the KeYmaera hybrid‑system prover (the “intersection‑example‑simple” proof node). After translation to 32‑bit bit‑vectors, the formula asserts that there is **no** reachable state violating a set of nonlinear arithmetic constraints involving multiplication, division and inequalities over time, position, velocity and parameters of an intersection scenario. Solving it requires reasoning about a single existential quantifier, mixed signed‑ and unsigned‑bit‑vector comparisons, and non‑linear (quadratic) terms, leading to a moderately deep term structure (depth 19) and a typical industrial‑level difficulty for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node618750.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system verifier (intersection‑example‑simple) as a single quantified bit‑vector formula. The goal is to refute the existence of a timestamp ts₍2956₎ that simultaneously satisfies a collection of non‑linear arithmetic constraints (quadratic terms and a division) on vehicle speeds, positions, and timing parameters, all expressed with 32‑bit unsigned/signed arithmetic and bounded by positivity and upper‑limit assumptions. It is an industrial‑style verification instance featuring one existential quantifier, deep nested arithmetic (term depth 21) and a mix of linear, multiplicative, and division constraints, making it a challenging BV‑encoded non‑linear arithmetic problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/vsl.proof-node1377.smt2",
    "description": "This benchmark is an industrial verification condition originating from a KeYmaera hybrid‑system proof (node 1377 of *vsl.proof*). It is encoded in the 32‑bit bit‑vector logic and checks the negation of an existential time‑step variable against a set of linear and quadratic inequalities that involve several multiplications, divisions and sign‑comparisons; essentially it asks whether a certain safety inequality can ever be violated. The presence of non‑linear arithmetic, a single quantified variable and 32‑bit overflow semantics makes it a representative, moderately sized (≈ 2 kB, depth 17) BV‑non‑linear instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node268443.smt2",
    "description": "This benchmark is a safety‑verification condition extracted from the KeYmaera hybrid‑system proof for a simple traffic‑intersection scenario.  It asks whether there exists a time instant (the quantified 32‑bit variable ts1247₀) that can satisfy a conjunctive set of linear and non‑linear bit‑vector constraints describing vehicle positions, velocities, accelerations and timing bounds (including a quadratic term v₂·v₂ divided by 2·B).  The instance is encoded in the BV logic with 18 32‑bit constants, a single existential quantifier, and a moderate term depth, making it a typical industrial‑style verification problem involving nonlinear arithmetic over fixed‑size bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node737898.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems prover (the “intersection‑example‑simple” case) as a 32‑bit bit‑vector problem.  The formula asserts that, for all admissible states and a bounded time variable, a set of non‑linear arithmetic constraints (quadratic terms v·v, products B·t, and signed divisions) together with a handful of linear bounds on vehicle speeds and positions cannot be violated; the only quantifier is an existential over the time‑stamp.  The instance is industrial‑scale (≈19 bit‑vector constants, depth 20) and is difficult because it combines non‑linear multiplication/division with a quantified variable, all under BV semantics.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/dccs-example-simple-node3459.smt2",
    "description": "This instance encodes a verification condition from the KeYmaera hybrid‑system benchmark (adaptive cruise‑control) that has been translated into 32‑bit bit‑vector arithmetic. It asserts that there is no assignment to a time variable satisfying a conjunction of linear and non‑linear (multiplicative) constraints involving positivity, ordering, and safety bounds on velocities, positions and parameters (A, B, ε). The problem features a single existential quantifier, several nested arithmetic relations, and a relatively deep term structure (depth 20), making it a non‑linear BV verification task of industrial origin.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node621704.smt2",
    "description": "This instance encodes a verification condition from the KeYmaera hybrid‑system benchmark suite (the “safe intersection” example). After translating the original real‑valued non‑linear arithmetic into 32‑bit bit‑vectors, it asks whether a conjunction of signed inequalities involving multiplications, divisions and additions—together with an existentially quantified time variable—can be violated. The problem is a single, moderately sized (≈19 variables, depth 20) BV‑logic query that tests the validity of a safety property for a hybrid system, featuring non‑linear arithmetic that makes it challenging for standard bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node270992.smt2",
    "description": "This instance encodes a safety verification condition from the KeYmaera hybrid‑system tool (the “intersection‑example‑simple” proof node).  The goal is to show that, under a set of linear and non‑linear (multiplication/division) bit‑vector constraints on 32‑bit variables, a certain safety invariant holds; the formula is negated and wrapped in an existential quantifier, so the solver must find a counterexample or prove unsatisfiability.  The benchmark stems from an industrial transportation‑systems case study, features 19 BV32 constants, non‑linear arithmetic translated to bit‑vectors, and a moderate term depth (21) with a single quantified block, making it a challenging verification‑style problem for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node529901.smt2",
    "description": "This benchmark encodes a safety verification condition for the “simple intersection” hybrid‑system example from the KeYmaera tool suite.  The condition is expressed in 32‑bit bit‑vector arithmetic (BV) and contains a single existential quantifier over a time variable, together with many non‑linear constraints (multiplications, a division and several signed comparisons) that model positions, velocities and timing of two agents.  Solving the instance amounts to proving that the asserted conjunction of inequalities is unsatisfiable, a task made difficult by the depth of the term (≈20) and the presence of non‑linear bit‑vector operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node54865.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system prover (the “simple intersection” example) as a single quantified bit‑vector formula.  The goal is to show that, under a collection of linear bounds on positions, velocities, and timing variables (all 32‑bit vectors) together with non‑linear constraints involving BV multiplication, there is **no** witness for a time variable that violates the safety property—i.e., the formula’s negated existential should be unsatisfiable.  The instance features one existential quantifier, moderate term depth (≈19) and a mix of linear order constraints and non‑linear arithmetic, making it a typical industrial verification problem that stresses BV‑solvers’ handling of multiplication and quantifiers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node674647.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system verifier (the “intersection‑example‑simple” proof) as a quantifier‑rich, non‑linear bit‑vector problem. It asserts that, under numerous non‑negativity and boundedness constraints on positions, velocities and timing parameters, a set of algebraic inequalities involving multiplication, division and squares cannot be satisfied, and it is expressed with a single existential quantifier over a time variable. The instance is industrial‑style, features 19 32‑bit variables, deep term nesting (depth 20), and a mixture of arithmetic and relational bit‑vector operators, making it a challenging case for BV solvers handling non‑linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node703624.smt2",
    "description": "This benchmark is a safety verification condition extracted from the KeYmaera proof of a “safe intersection” hybrid‑system model and translated into 32‑bit bit‑vector arithmetic. It asserts that there is no time instant (the existential variable ts) for which a collection of non‑linear constraints—mixing additions, multiplications of unknowns, and a division term—together with several non‑negativity and bound conditions on variables such as speeds, distances, and parameters, can be satisfied. The formula features a single existential quantifier, deep term nesting (depth 21), and non‑linear BV operations, making it a representative industrial instance of quantified non‑linear BV verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node388424.smt2",
    "description": "This benchmark encodes a safety‑condition verification for a hybrid‑system model of a traffic intersection (originating from a KeYmaera proof) as a single quantified bit‑vector formula. The assertion checks that, under a set of non‑linear arithmetic constraints (quadratic terms, division, and multiple linear inequalities on 32‑bit variables such as positions, velocities, and time bounds), there exists no choice of a time‑stamp variable that violates the required safety bounds. The instance is an industrial‑style BV encoding with one existential quantifier, many non‑linear multiplications, and deep term nesting, illustrating the difficulty of solving non‑linear arithmetic after translation to bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node532026.smt2",
    "description": "The instance encodes a verification condition from the KeYmaera hybrid‑systems benchmark “safe intersections”. After translating the original real‑valued non‑linear arithmetic proof into 32‑bit bit‑vectors, it asserts the negation of an existential formula that captures the safety‑critical constraints (bounds on speeds, positions, and timing) of two intersecting vehicles. The solver must show the formula is unsatisfiable, i.e., that no assignment to the existential time variable can violate the safety predicates, despite the presence of non‑linear multiplications and several linear inequalities.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node603757.smt2",
    "description": "This benchmark encodes a safety verification condition for a hybrid‑system model of a traffic intersection (the “intersection‑example‑simple” from KeYmaera), translated into 32‑bit bit‑vector arithmetic. The formula asserts, under a single existentially‑quantified time variable, a conjunction of linear and non‑linear (multiplication and a division) constraints on positions, velocities and parameters, and then negates it, so the solver must prove the condition unsatisfiable; the instance involves many BV comparisons, a moderate term depth (20) and 19 declared constants, making it a non‑trivial industrial BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node384248.smt2",
    "description": "This instance encodes a safety‑verification condition from the KeYmaera hybrid‑system benchmark “intersection‑example‑simple”, translated into 32‑bit bit‑vector arithmetic.  It asserts the negation of an existential formula that couples non‑linear constraints (squares, multiplications, divisions) with range and positivity bounds on several state variables, expressing that a vehicle’s braking distance stays within a safe limit.  The problem is a single‑quantifier BV verification task with moderate term depth (≈21) and a handful of non‑linear bit‑vector operations, typical of industrial hybrid‑system safety checks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node676430.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems prover (the “intersection‑example” proof node). The goal is to show that no assignment to a 32‑bit time variable can violate a set of non‑linear bit‑vector constraints that model vehicle positions, velocities and timing (including multiplications, divisions and several positivity and bound checks). The single quantified formula mixes existential quantification, deep non‑linear arithmetic and many signed comparison operators, making it a challenging industrial BV‑non‑linear instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/dccs-example-simple-node3457.smt2",
    "description": "This instance encodes a verification condition from the Keymaera hybrid‑system benchmark suite (adaptive cruise‑control example) that has been translated into 32‑bit bit‑vector arithmetic. It checks, via the negated existential formula, whether a set of linear and non‑linear (multiplication) inequalities over the variables can be satisfied—i.e., whether the safety property holds. The problem features a single existential quantifier, a deep conjunction of BV inequalities, and non‑linear multiplications, making it a quantified bit‑vector safety‑verification query of moderate size (12 constants, term depth 20).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/vsl.proof-node1722.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system prover, translated into 32‑bit bit‑vector arithmetic. The single assertion states that there is **no** value of a time‑step variable satisfying a conjunction of linear and non‑linear constraints (multiplications, a division, and several inequalities) involving several pre‑declared constants; the solver therefore must prove the negated existential. The instance is an industrial‑style BV problem with deep, non‑linear terms (term depth 18, multiple multiplications/divisions) and a single quantified block, making it a challenging case for bit‑vector non‑linear arithmetic solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node709146.smt2",
    "description": "The instance encodes a safety verification condition for the “safe‑intersection” hybrid system from the KeYmaera benchmark suite. It checks, via a single existential quantifier over a 32‑bit time variable, that a set of nonlinear relations (including products and a division of bit‑vectors) and a host of linear bounds on speeds, positions and parameters cannot be simultaneously satisfied—i.e., it proves the unsatisfiability of a counterexample. The encoding uses 32‑bit bit‑vectors, non‑linear arithmetic, several positivity and ordering constraints, and a moderate quantifier depth (term depth 21), making it a challenging industrial‑style BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node291962.smt2",
    "description": "This instance encodes a safety verification condition from the KeYmaera hybrid‑systems benchmark “intersection‑example‑simple”, translated into 32‑bit bit‑vector arithmetic. The formula asserts that no choice of a time variable can violate a collection of bounded, non‑negative constraints involving positions, velocities and parameters (with addition, multiplication and a division), i.e., it checks a universal safety property over a single existential quantifier. It is an industrial‑style BV benchmark featuring moderate term depth (≈20), a handful of linear/non‑linear constraints and only one quantifier block, making it a representative case of non‑linear arithmetic verification after bit‑vector encoding.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node631857.smt2",
    "description": "This instance encodes a safety verification condition for a hybrid‑system model of a vehicle intersection (derived from a KeYmaera proof). The goal is to refute the existence of a time instant satisfying a set of non‑linear arithmetic constraints on positions, velocities and timing parameters, all represented as 32‑bit bit‑vectors; the formula contains a single existential quantifier, several arithmetic inequalities, and a handful of conditional implications. The benchmark is an industrial‑style verification problem with a moderate number of variables (≈20) and deep, non‑linear term structure (multiplication and division), which makes it a challenging test for BV solvers handling quantified, non‑linear constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node292166.smt2",
    "description": "The benchmark encodes a safety‑verification condition from the KeYmaera proof of a “safe intersection” hybrid‑system example. After translating the original real‑valued non‑linear arithmetic (multiplications, a division, and many order constraints over positions, velocities, time and parameters) into 32‑bit bit‑vector arithmetic, the formula asserts the negation of an existential witness that would violate the safety invariant. Consequently the solver must show the conjunction of numerous non‑linear BV constraints is unsatisfiable, making this a non‑linear arithmetic verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node369871.smt2",
    "description": "This benchmark encodes a safety verification condition from the Keymaera hybrid‑system verifier (the “intersection‑example‑simple” case) as a single quantified assertion over 32‑bit bit‑vectors. The condition contains non‑linear arithmetic (multiplications, a division, and several nested arithmetic comparisons) together with a handful of linear bounds, and it is wrapped in a negated ∃‑quantifier, so the solver must prove the negated existential formula unsatisfiable. The instance is relatively small (19 declared constants) but features deep (depth 19) non‑linear BV terms and a quantifier alternation, making it a challenging industrial‑style verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node54870.smt2",
    "description": "This benchmark encodes a verification condition extracted from the KeYmaera hybrid‑system verifier (the “intersection‑example‑onelane” proof).  The goal is to show that, under a set of linear bounds on time, positions, velocities and constants, a non‑linear safety inequality always holds; hence the SMT query asserts the negation of an existentially‑quantified condition and asks the solver to prove it unsatisfiable.  The problem is formulated in the BV logic with 32‑bit vectors and features extensive nonlinear arithmetic (multiplications of variables and constants, a division, and quadratic terms) together with a single existential quantifier, giving a deep term structure (depth 24) and a relatively high number of bit‑vector operations, which makes it a challenging industrial verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node195048.smt2",
    "description": "This instance encodes a safety verification condition for a hybrid‑system model of a road intersection (the “Keymaera” benchmark), translated from real arithmetic into 32‑bit bit‑vector arithmetic. The formula asserts the negation of an existentially‑quantified condition over a time variable, combining non‑linear operations (multiplication, division) with a mixture of signed inequalities and equalities that express bounds on velocities, positions, and timing parameters. Because it features a single quantified variable, deep (≈20) term nesting, and many non‑linear BV constraints, it is representative of an industrial‑level BV verification problem that is hard for solvers to discharge.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node1479.smt2",
    "description": "This benchmark is a safety‑verification condition extracted from the KeYmaera hybrid‑systems prover (the “intersection‑example‑onelane” case) and translated into 32‑bit bit‑vector logic. It asserts that no choice of a time variable can violate a conjunction of linear bounds on positions, velocities and constants, but the encoding contains non‑linear multiplications (e.g., A·ts0, A·t1) and a single existential quantifier, yielding deep (≈22) term nesting over 13 bit‑vector variables. Consequently the instance tests a solver’s ability to handle industrial‑scale BV verification problems with nonlinear arithmetic and quantified constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node386295.smt2",
    "description": "This benchmark is a verification condition extracted from the KeYmaera proof of a “safe‑intersection” hybrid‑system example.  It encodes, as a single quantified formula over 32‑bit bit‑vectors, the negation of the safety property: it asserts that there exists a time stamp for which a collection of non‑linear arithmetic constraints (involving multiplications, divisions and several interval variables) would violate the invariant on positions, velocities and timing bounds.  The solver therefore has to prove the formula unsatisfiable, which is difficult because of the non‑linear BV arithmetic, a deep term nesting (depth 20) and many inter‑dependent constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node369234.smt2",
    "description": "This instance encodes a safety verification condition for the “intersection‑example” hybrid‑system benchmark from the KeYmaera suite, translated into 32‑bit bit‑vector arithmetic. It asserts (via a negated existential) that there is no choice of a time variable satisfying a set of non‑linear constraints involving squares, products and divisions together with numerous bounds on positions, velocities and parameters; the goal is to prove the condition unsatisfiable. The problem features a single quantified block, deep (≈19) term nesting, and a mix of non‑linear arithmetic and linear inequalities, making it a challenging industrial‑style BV verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node475811.smt2",
    "description": "This benchmark encodes a verification condition from the KeYmaera hybrid‑system tool (a simple safe‑intersection example) as a 32‑bit bit‑vector formula. It asserts the negation of an existential statement over a time‑step variable, imposing numerous lower/upper‑bound constraints on velocities, positions, and parameters together with non‑linear arithmetic (multiplication and division) and ordering predicates to express that a safety inequality must hold for all admissible states. The problem therefore tests BV solvers on a single quantified, moderately deep (depth 21) formula with non‑linear operations and a rich conjunction of bounds, typical of industrial verification workloads.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node39725.smt2",
    "description": "This instance encodes a safety verification condition from the KeYmaera hybrid‑system benchmark suite (a one‑lane traffic‑intersection example). After being translated to 32‑bit bit‑vectors, the property is expressed as the negation of an existential formula that combines numerous linear bounds (e.g., non‑negativity of time, velocities, and parameters) with non‑linear arithmetic (multiplications, a division, and quadratic terms) over the variables. The single, deep (depth 24) quantified assertion involves 13 bit‑vector constants and makes the problem challenging for BV solvers because of the mixed linear‑non‑linear constraints and the need to refute a potential counterexample.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node287144.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems prover (the “intersection‑example” from the safe‑intersection case study) into 32‑bit bit‑vectors. The conjecture is expressed as a single negated existential quantified block that tests whether there exists a reachable state violating a set of linear and non‑linear arithmetic constraints (multiplication, division, and several inequality bounds) over variables that model positions, velocities, and timing parameters. The solver must show the formula unsatisfiable, i.e., that no counterexample to the safety property exists, despite the presence of non‑linear arithmetic and moderately deep term nesting.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node345166.smt2",
    "description": "This benchmark encodes a safety verification condition from a KeYmaera hybrid‑system proof (the “intersection‑example” of a safe road crossing) that was translated into 32‑bit bit‑vector arithmetic. The formula asserts that no choice of a time‑step variable can satisfy a collection of non‑linear constraints involving sums, products and divisions together with several range and positivity conditions on the system’s state variables; the instance therefore checks the unsatisfiability of a quantified safety‑property V‑C. It features a single existential quantifier, 18 bit‑vector constants, deep (≈21) term nesting and a mixture of non‑linear arithmetic (multiplication, division) and ordering operations, which makes it a challenging industrial‑style verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node350275.smt2",
    "description": "This benchmark encodes a verification condition from the Keymaera hybrid‑system verifier (the “safe intersection” example). The single, quantified assertion checks that, under a set of non‑linear arithmetic constraints on 32‑bit bit‑vectors (including multiplication, division and several ordering relations), no assignment to the existential time variable can violate the safety bounds on velocities and positions. Consequently the problem is an industrial‑style safety‑property check that features a deep term structure (depth 21), many bit‑vector variables, and a single existential quantifier, making it a non‑linear BV verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node560330.smt2",
    "description": "This instance encodes a safety verification condition from the KeYmaera hybrid‑systems benchmark “intersection‑example‑simple” (a vehicle‑intersection scenario) that has been translated into 32‑bit bit‑vector arithmetic. The formula checks, via a single existential quantifier, that no assignment to the time variable can violate a conjunction of nonlinear numeric constraints (bounds on velocities, positions, and a quadratic term v₂·v₂ divided by a constant B) together with several linear inequalities; the outer (not …) turns the problem into an unsatisfiability query. The benchmark features a non‑linear arithmetic fragment (multiplication and division) represented as BV operations, a moderately deep term structure (depth 22) and 19 declared bit‑vector constants, typical of industrial verification problems from the Preiner‑keymaera family.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node272548.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems verifier (the “intersection‑example” case study).  The goal is to refute the existence of a time‑step value (a 32‑bit bit‑vector) that satisfies a conjunction of linear and non‑linear bit‑vector constraints describing bounds on velocities, accelerations, distances and a timing horizon.  The formula features one existential quantifier, several nested let‑bindings, and non‑linear operations (multiplication and division) together with many signed inequality checks, making it a representative industrial verification problem that is challenging for BV solvers because of the combination of quantification and non‑linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/bouncing-ball-simple-node5586.smt2",
    "description": "This instance encodes a safety verification condition from the KeYmaera hybrid‑systems tool (the “bouncing‑ball‑simple” example) as a 32‑bit bit‑vector formula. The problem checks that, for all reachable states, a non‑linear polynomial inequality involving several variables (including products of state variables and constants) holds; this is expressed as the negation of an existential condition over a time‑step variable. The benchmark therefore tests BV solvers on a single‑existential, highly non‑linear arithmetic constraint with moderate term depth (≈20) and a handful of quantified and arithmetic operators, typical of industrial verification workloads.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node561763.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system verifier (the “intersection‑example”); the SMT query asserts that no time instant ts can satisfy a collection of nonlinear bit‑vector constraints on positions, velocities, and parameters such as A, B, V, ep, etc. The formula is a single existential quantifier over ts together with a large conjunction of signed‑comparison, addition, multiplication and division constraints, and the overall goal is to show the negated existence (i.e., the condition is unsatisfiable). Consequently the instance is a moderately sized BV verification problem with non‑linear arithmetic, several dozen variables, and a depth‑20 term structure.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/rbc-controllability-characterisation-node3299.smt2",
    "description": "This instance is a quantified verification condition originating from the Keymaera hybrid‑systems tool (the “rbc‑controllability‑characterisation” benchmark). It asks, after negating an existential formula, whether there exist 32‑bit values for two variables that satisfy a conjunction of non‑linear bit‑vector inequalities involving multiplications, subtractions and signed comparisons. The problem therefore tests a solver’s ability to handle nested quantifiers together with non‑linear BV arithmetic, a characteristic difficulty of industrial verification benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node717892.smt2",
    "description": "This instance encodes a verification condition from the KeYmaera hybrid‑systems prover, modelling a simple traffic‑intersection safety scenario. The formula is a single quantified BV assertion that combines linear and non‑linear constraints (multiplication, division, and inequalities) over 32‑bit variables representing positions, velocities and timing parameters; the outer negation turns the check into an UNSAT test that the safety property holds for all admissible time steps. The problem therefore belongs to industrial verification of hybrid‑system safety, featuring a moderate‑size, deeply nested term structure with one existential quantifier and non‑linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node5607.smt2",
    "description": "This instance encodes a verification condition for the KeYmaera hybrid‑system proof “intersection‑example‑onelane” (a safety property of a single‑lane traffic intersection) that has been translated from real‑valued non‑linear arithmetic into 32‑bit bit‑vectors. The formula asserts that no 32‑bit time value `ts10uscore1` can satisfy a conjunction of many non‑linear constraints involving multiplications, divisions, and comparisons of the declared constants, and it ends with a disjunction that captures the safety‑property violation. The problem is an industrial‑style BV verification task with a single existential quantifier, deep (depth 23) nested arithmetic terms, and several non‑linear operations, making it a challenging case for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node369550.smt2",
    "description": "This benchmark is a safety verification condition translated from a KeYmaera hybrid‑system proof about a traffic‑intersection scenario. It checks, using 32‑bit bit‑vector arithmetic, that no assignment to a timing variable can satisfy a conjunction of bounds on positions, velocities, and parameters (all required to be non‑negative) while violating a safety inequality; the outer negation makes the query ask whether a counterexample exists. The formula features non‑linear operations (multiplication and division), a single existential quantifier and nested arithmetic, giving a moderate‑size, deep‑term BV instance that is representative of industrial hybrid‑system verification problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node174126.smt2",
    "description": "This benchmark encodes a safety‑verification condition from a hybrid‑systems proof (the “intersection‑example” from KeYmaera) after translation to 32‑bit bit‑vector arithmetic. The formula asserts that there is **no** assignment to a time variable that violates a collection of non‑linear relationships among velocities, positions, and timing bounds (involving multiplication, division and signed comparisons), essentially checking that the system’s invariant holds for all reachable states. The instance features a single quantified existential, moderate term depth (20), and a mix of non‑linear BV operations, making it a typical industrial verification problem for nonlinear arithmetic solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node74776.smt2",
    "description": "The benchmark encodes a safety verification condition taken from the KeYmaera hybrid‑systems verifier (the “intersection‑example” from the safe‑intersection case study). After translation to 32‑bit bit‑vectors, the formula asserts the non‑existence of a time stamp ts that satisfies a conjunction of linear and non‑linear (multiplicative) bounds on positions, velocities and parameters of two intersecting vehicles; the outer `not (exists …)` therefore checks that the safety property holds. The instance is a single‑quantifier BV problem with 19 variables, moderate term depth (18) and a handful of nonlinear multiplications, typical of industrial verification‑condition benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node18278.smt2",
    "description": "This instance is a verification condition taken from the KeYmaera hybrid‑system verifier (the “safe‑intersection” example) that has been translated into 32‑bit bit‑vector arithmetic. The formula asserts the negation of an existential quantifier over a time variable, threading together a large conjunction of non‑linear constraints (multiplications, a division, and several linear inequalities) that model bounds on positions, speeds and safety distances. Consequently, the problem is a single, deeply nested non‑linear BV query typical of industrial safety‑property checking, with a high term depth and many arithmetic operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node348711.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system prover (the “intersection‑example” proof node). After translating the original real‑valued dynamics to 32‑bit bit‑vectors, the formula asserts that no assignment to an existential time variable can violate a collection of non‑linear arithmetic constraints (multiplications, a division, and several order relations) on vehicle speeds, positions and timing parameters. The problem belongs to the industrial “Preiner‑keymaera” family, features a single quantified block, 19 bit‑vector constants and a maximum term depth of 21, making it a challenging BV non‑linear verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node290877.smt2",
    "description": "The instance encodes a safety verification condition from the KeYmaera hybrid‑system verifier (the “intersection‑example” case).  After translating the original real‑valued dynamics to 32‑bit bit‑vectors, the formula asserts that there is **no** assignment to a time‑parameter (`ts1355uscore0`) satisfying a collection of non‑linear arithmetic constraints (multiplications, a division, and several linear inequalities) together with bounds on variables such as speeds, distances, and a positive safety margin (`ep`).  It is an industrial‑style BV benchmark featuring one existential quantifier, nested `let` bindings, and deep (depth ≈ 21) non‑linear terms, making it a challenging case for solvers that handle bit‑vector non‑linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node37018.smt2",
    "description": "The instance is a verification condition extracted from the KeYmaera hybrid‑systems tool (the “intersection‑example‑onelane” safety proof) and translated to 32‑bit bit‑vectors. It asserts the negation of an existentially‑quantified state (ts82) together with a large conjunction of linear and non‑linear arithmetic constraints (multiplication of v by itself, a division, and several range and ordering checks) that model safety bounds on positions, velocities and timing for a one‑lane intersection scenario. The formula involves a single quantifier, 13 BV variables, deep (depth 23) nested arithmetic expressions, and therefore tests the solver’s ability to handle non‑linear BV reasoning in an industrial‑style verification setting.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node534610.smt2",
    "description": "This benchmark is a verification condition extracted from the KeYmaera hybrid‑system proof of a “safe intersection” scenario (node 534610 of *intersection‑example‑simple.proof*). After being translated to 32‑bit bit‑vectors, it checks that a set of nonlinear arithmetic constraints (including multiplication, division, and quadratic terms) together with several safety bounds on positions, velocities and timing variables cannot be violated; formally it asserts the unsatisfiability of an existential statement over a time‐stamp variable. The instance features a single quantified block, a relatively deep term nesting (depth 20) and a mixture of signed comparisons, making it a non‑linear BV verification problem of industrial origin.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node369000.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems prover (the “intersection‑example” from the safe‑intersection case study) as a 32‑bit bit‑vector formula. The property asserts that, under a number of linear and non‑linear constraints on positions, velocities and timing variables (including products and divisions of bit‑vectors), no existential choice of a time slot can violate the safety bounds, i.e. the formula should be unsatisfiable. The instance features a single large quantified implication with deep nesting (max term depth 19), many non‑linear BV multiplications and a division, making it a challenging industrial‑style BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node269013.smt2",
    "description": "This benchmark encodes a verification condition extracted from the KeYmaera hybrid‑system verifier (the “intersection‑example‑simple” proof node), translated into 32‑bit bit‑vector arithmetic. The formula asserts that no assignment to the time‑stamp variable can satisfy a conjunction of non‑linear constraints involving additions, multiplications and a division, together with a series of ordering constraints on positions, velocities, and safety margins (e.g., positivity of parameters, bounds on computed positions, and a deadline `ep`). The instance therefore tests a bit‑vector solver’s ability to handle a single existential quantifier, deep nested arithmetic terms (depth 20), and many linear/non‑linear inequalities arising from an industrial hybrid‑system safety proof.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node252371.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system proof “safe intersection”.  The goal is to show that, for all admissible values of the system parameters (non‑negative bit‑vector constants, quadratic terms v₂·v₂, and linear time‑dependent terms A·t, B·t), a set of signed inequality constraints (bounds by V, positivity of ep, etc.) cannot be violated; the model is expressed as a single negated existential formula over a time variable.  The problem originates from an industrial case study, is translated to 32‑bit bit‑vectors, contains non‑linear multiplications, and features a moderate number of variables (19) with a maximum term depth of 20, making it a typical non‑linear arithmetic verification instance for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/binary_driver-2007-10-09-node10279.smt2",
    "description": "This benchmark encodes a KeYmaera verification condition (a safety‑property safety proof for a hybrid‑system model called *binary_driver*) that has been translated from real arithmetic into 32‑bit bit‑vector arithmetic. The formula asserts that there is **no** value of a time‑step variable (`ts3`) satisfying a large conjunction of linear and non‑linear BV constraints involving multiplications, divisions, and squares of several parameters (e.g., `b`, `amax`, `v`, `d`, etc.). Consequently the problem is an industrial‑style, quantifier‑rich, non‑linear BV verification query with a single existential quantifier, deep term nesting (depth 22) and many mixed arithmetic operations, making it challenging for solvers that handle non‑linear bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node174360.smt2",
    "description": "This benchmark encodes a safety verification condition for the “intersection‑example” hybrid‑system proof from the KeYmaera tool chain. After being translated to 32‑bit bit‑vectors, the formula checks that, under a set of linear bounds on velocities, positions and parameters, a non‑linear invariant (involving products of the variables and a division) holds for some reachable time instant. The instance features a single existential quantifier, many non‑linear BV multiplications, moderate term depth (≈20) and 18 declared constants, making it a typical industrial‑scale verification problem from the Preiner‑keymaera family.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node13832.smt2",
    "description": "This benchmark encodes a safety verification condition for a one‑lane traffic‑intersection hybrid system (the “Keymaera” example). The property is expressed as a quantified Bit‑Vector formula that combines signed comparisons, linear arithmetic and a single non‑linear multiplication term (the product of a negated parameter B and a time variable). The solver must prove that no assignment to the existentially‑quantified time variable satisfies the large conjunction of bounds on positions, velocities, and timing parameters; equivalently, it must show the negated existential is unsatisfiable. The instance is industrial‑style, features 13 Bit‑Vec variables, a moderate term depth (23) and a single quantifier, and was generated by translating the original real‑valued hybrid‑system model into 32‑bit bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node550261.smt2",
    "description": "This benchmark encodes a safety‑verification condition from the KeYmaera hybrid‑system proof “intersection‑example‑simple” (a traffic‑intersection scenario) that has been translated to 32‑bit bit‑vector arithmetic. The asserted formula is the negation of an existential over a time variable, together with a large conjunctive block of linear and non‑linear constraints (including a quadratic term v₂·v₂ and a division), so the solver must show the existential is unsatisfiable, i.e., that the universally quantified safety property holds. The instance features a moderate number of bit‑vector constants (19) but deep terms (depth 21) and non‑linear arithmetic, making it a representative industrial verification challenge for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node630639.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems prover (the “safe‑intersection” example) as a quantifier‑free bit‑vector problem. The formula asserts that, under a collection of non‑negative bounds and nonlinear relationships (quadratic terms turned into BV multiplication/division), no time value can violate the invariant relating positions, velocities and timing parameters, and the top‑level negated existential checks unsatisfiability of a counterexample. The instance is industrial‑scale, features a single existential quantifier, deep (≈21) term nesting and non‑linear BV arithmetic, making it a challenging case for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20210330-PEak/extern-loop_sat_subset/medium0.smt2",
    "description": "This SMT‑LIB file encodes a **hardware rewrite‑rule synthesis** problem (from the PEak benchmark suite). The single assertion checks whether a massive bit‑vector expression—built from thousands of nested concatenations, extracts, arithmetic, shifts and conditionals—can satisfy a set of equalities and ordering constraints on the input and output vectors (including a concrete zero‑input and a true output flag). Because the expression depth exceeds a million nodes, with hundreds of thousands of extract/ite operations, the instance is an industrial‑scale, quantifier‑free BV verification/synthesis task that stresses solvers’ term‑management and reasoning capabilities.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node34026.smt2",
    "description": "This benchmark encodes a safety verification condition from the Keymaera hybrid‑system prover (the “intersection‑example‑onelane” traffic‑intersection model). The goal is to show that no time‑step value ts75 can satisfy a large conjunction of linear and non‑linear bit‑vector constraints—primarily bounds on positions, velocities, and accelerations, together with a quadratic term (v·v) and a division—while also meeting the invariant that the lane‑index I1 equals 2. It is an industrial‑style BV instance featuring a single existential quantifier, nonlinear multiplication/division, and moderate term depth (≈21) that tests solvers’ ability to handle quantified, non‑linear bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node369346.smt2",
    "description": "This instance encodes a verification condition from the KeYmaera hybrid‑system proof “safe intersection” (the “intersection‑example‑simple” benchmark) that was translated into 32‑bit bit‑vector arithmetic.  The formula asserts that, under non‑negative bounds on parameters A, B, V, ep and on the velocities v₁, v₂, the squared‑velocity terms (v₁·v₁, v₂·v₂) divided by 2·B stay within the interval \\([0,V]\\) and that a time variable t satisfies the required inequalities; the whole condition is negated and wrapped in an existential over a time instant ts₁₇₂₄, turning the check into a validity problem.  The problem is an industrial‑style non‑linear arithmetic verification encoded as BV, featuring a single quantified assertion, deep (depth 19) nested bit‑vector expressions, and many multiplications/divisions, making it a challenging benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node365878.smt2",
    "description": "This benchmark encodes a verification condition from the Keymaera hybrid‑system verifier (a “safe intersection” example) as a bit‑vector problem.  The formula asserts, under a host of non‑negative bounds on speed‑like variables (v1, v2, A, B, V, etc.), that a certain inequality involving quadratic terms (v·v) and a linear combination of a time variable holds; the condition is wrapped in a single existential quantifier over the time instant.  It therefore tests solvers on non‑linear arithmetic (multiplication and signed division) after translation to 32‑bit BV, with a moderate number of variables, deep nesting of arithmetic and logical operators, and one quantifier alternation, making it a challenging industrial verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node559861.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems prover (the “intersection‑example” proof node).  The formula, translated into 32‑bit bit‑vector arithmetic, asserts that under a set of non‑negative bounds on parameters (velocities, distances, constants A, B, and a horizon V) and a nonlinear relationship between them (including multiplications and a division), there exists a time instant `ts` that would violate the safety invariant; the outer negation checks that no such `ts` can exist.  The instance features a single existential quantifier, deep nesting of arithmetic constraints, and non‑linear BV operations, making it a challenging industrial verification problem for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node345278.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system verifier for a traffic‑intersection example. It is a single quantified bit‑vector formula (32‑bit BV) that combines non‑linear multiplications, divisions and many inequality bounds to assert that no reachable state can violate the prescribed safety limits. The problem features one existential quantifier, a moderate number of variables and conjuncts, and a term depth of 20, making it a typical industrial BV non‑linear arithmetic verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node152733.smt2",
    "description": "This benchmark encodes a verification condition from the KeYmaera hybrid‑system example “safe intersection” (node 152733 of *intersection‑example‑simple.proof*), translated into 32‑bit bit‑vector arithmetic. The single quantified assertion checks that, under a series of non‑negative bounds and linear‑inequality relations (including a non‑linear term that multiplies a variable by itself), a certain safety implication holds for all admissible time‑step values. The instance features an existential quantifier, nonlinear multiplication, and relatively deep terms (depth 20) over 19 bit‑vector variables, making it representative of industrial‑scale BV‑encoded hybrid‑system verification problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node733082.smt2",
    "description": "This benchmark is a safety‑verification condition taken from the KeYmaera hybrid‑system proof “intersection‑example‑simple” (node 733082). After being translated to 32‑bit bit‑vectors, it asserts that no assignment to a time variable can satisfy a collection of nonlinear arithmetic constraints (quadratic terms v₁·v₁, v₂·v₂ and a division) together with bounds on velocities, positions and parameters of two intersecting vehicles; the outer `not (exists …)` turns the verification condition into a SAT query. The problem features a single quantified variable, deeply nested arithmetic (max term depth 20), many bit‑vector multiplications/divisions and a mix of signed comparisons, making it a challenging non‑linear BV instance from the industrial “Preiner‑keymaera” family.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node476116.smt2",
    "description": "This instance is a Bit‑Vector encoding of a verification condition generated by the KeYmaera hybrid‑system prover for a “safe intersection” scenario.  It asserts, under a collection of linear bounds (non‑negative positions, velocities, times, and a positive safety margin) and a non‑linear relation involving products and a division (e.g., v₁·v₁ and A·t), that there is no assignment to the existential time variable that violates the safety invariant; the outer `not (exists …)` therefore checks the unsatisfiability of a counterexample.  The formula contains a single existential quantifier, numerous arithmetic constraints, and moderate term depth (≈20) with 19 bit‑vector constants, making it a typical industrial‑scale non‑linear BV verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node601673.smt2",
    "description": "This benchmark encodes a safety verification condition for the “intersection‑example” hybrid system from the KeYmaera proof suite, translated into 32‑bit bit‑vector arithmetic. The formula asserts that no assignment to the time variable (an existentially‑quantified bit‑vector) can satisfy a collection of non‑linear constraints involving multiplications of state variables, signed inequalities, and bounds on velocities and positions, effectively checking the unsatisfiability of a potential counterexample. The instance is notable for its use of non‑linear BV arithmetic (e.g., A·t, B·t, v₂·v₂) together with a moderate number of variables (18), a single quantifier, and a term depth of 19, making it a challenging industrial verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node152942.smt2",
    "description": "This benchmark encodes a verification condition from the KeYmaera hybrid‑systems prover (the “safe‑intersection” example) that has been translated into 32‑bit bit‑vector arithmetic.  The formula asserts the negation of an existential witness for a set of non‑linear constraints involving multiplications, a division, and several linear inequalities that capture positivity of velocities, distances and timing parameters of two intersecting vehicles.  It contains a single quantified block, 18 bit‑vector constants, and a maximal term depth of 21, making it a moderate‑size industrial verification instance that stresses solvers’ handling of non‑linear BV arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node631164.smt2",
    "description": "This benchmark is a safety‑verification condition from the KeYmaera hybrid‑systems tool (the “intersection‑example‑simple” proof), translated into 32‑bit bit‑vector arithmetic. The formula checks that, for all admissible values of positions, velocities and a time bound, a set of non‑linear constraints (quadratic terms v₁·v₁, v₂·v₂, a product A·t, and a signed division) together with several signed orderings can never be satisfied; it is encoded as the negation of an existential quantifier. The instance features a single quantified variable, 20 bit‑vector constants, deep (≈21‑level) expressions, and a mix of multiplication, division and signed inequalities, making it a challenging non‑linear BV verification problem of industrial origin.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node351935.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems prover (the “intersection‑example‑simple” proof), translated into 32‑bit bit‑vector arithmetic. The single, quantified assertion checks that, under a set of non‑linear constraints (including multiplications, a division, and many linear inequalities on positions, velocities, and timing variables), the system never reaches an unsafe state (e.g., a collision) and respects bounds on safety parameters such as the allowed speed and the time horizon. The problem features a deep term structure (depth ≈ 20), a mixture of arithmetic operators, and an existential quantifier, making it a challenging industrial‑style verification instance for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/safety-lemma-node10952.smt2",
    "description": "This instance encodes a safety‑lemma verification condition extracted from the KeYmaera hybrid‑systems verifier (European Train Control System case study). The formula asserts the negation of an existential statement over a 32‑bit time variable, together with a large conjunction of non‑linear bit‑vector inequalities (squared terms, products, and divisions) that model physical and controller constraints such as speed, distance, and control parameters. Because the arithmetic is translated into 32‑bit bit‑vectors, the problem features deep term nesting (depth 23), many multiplication/division operations, and a single quantified variable, making it a challenging industrial‑style BV non‑linear verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node534722.smt2",
    "description": "This benchmark encodes a verification condition from the KeYmaera hybrid‑systems tool (the “intersection‑example‑simple” safety proof) after translation into 32‑bit bit‑vectors. The single top‑level assertion negates an existentially quantified formula that combines several non‑linear arithmetic constraints (multiplications, a division, and quadratic terms) with linear ordering constraints on the variables, all expressed with signed‑bit‑vector comparisons. The problem therefore tests SMT solvers’ ability to handle quantified, non‑linear BV arithmetic in an industrial‑style safety‑verification setting.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node287256.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system prover (the “intersection‑example‑simple” proof node) as a quantifier‑free bit‑vector problem.  The formula asserts that, under a set of linear and non‑linear (multiply/divide) bounds on velocities, positions and timing variables, no counter‑example exists for the existentially quantified time‑step variable; its negation is checked for unsatisfiability.  Although relatively small (18 32‑bit variables, depth 20), the instance features mixed signed inequalities, a single existential quantifier and non‑linear arithmetic, making it representative of industrial hybrid‑system verification workloads.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node247731.smt2",
    "description": "This benchmark encodes a verification condition from the KeYmaera hybrid‑systems verifier (the “safe intersection” example) that has been translated into 32‑bit bit‑vector arithmetic. The single quantified formula asserts that, for all admissible values of the system parameters (velocities, bounds, and a time‑step variable), a set of nonlinear arithmetic constraints (including multiplications and a division) respects the safety inequalities; the outer `not` makes the problem a SAT check for the negated existence of a counter‑example. The instance features 18 bit‑vector variables, deep nested let‑expressions (max term depth 21) and a mixture of linear and non‑linear BV constraints, making it a representative industrial‑style non‑linear arithmetic verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node46832.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems tool (the “intersection‑example‑onelane” proof) as a 32‑bit bit‑vector formula. The single quantified assertion asks whether there exists a time‑step value that can satisfy a large conjunction of non‑linear arithmetic constraints (mixing additions, multiplications, divisions and signed comparisons) involving vehicle positions, velocities and system parameters; the overall goal is to show the condition is unsatisfiable, i.e., the intersection is safe. The instance is industrial‑scale, with 13 declared bit‑vectors, deep term nesting (depth 25) and many arithmetic operators, making it a challenging non‑linear BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node559428.smt2",
    "description": "The instance encodes a safety verification condition from the Keymaera hybrid‑system verifier (the “safe intersection” example) that has been translated into 32‑bit bit‑vector arithmetic. It asserts, via a single quantified formula, a conjunction of linear and non‑linear (multiplication and division) inequalities over many variables, checking that no assignment to a time‑step variable can violate bounds on positions, velocities and safety margins. The benchmark is industrial‑type, contains a single existential quantifier, 20 bit‑vector constants and a moderate term depth (21), making it a typical non‑linear BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node704363.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system proof of a simple traffic‑intersection scenario. The formula asserts (via a negated ∃‑quantifier) that no assignment to the 32‑bit variables—representing velocities, positions, timing bounds and constants—can satisfy a set of nonlinear bit‑vector constraints (including multiplication, division and several ordering relations) while violating the safety property. The problem thus tests BV solvers on a single‑existential, non‑linear arithmetic VC with moderate depth (20) and 18 variables, originating from an industrial‑style hybrid‑system verification case.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node271104.smt2",
    "description": "This benchmark is a safety verification condition extracted from the KeYmaera hybrid‑system prover (the “intersection‑example” from the safe‑intersection case study) and translated into 32‑bit bit‑vector arithmetic. It asserts that, under a collection of signed inequality bounds and non‑linear relationships (multiplications and a division) among twenty variables, an existentially‑quantified bad state cannot be reached; the outer “not” forces the solver to prove unsatisfiability of that existential formula. The problem features a single quantified block, mixed linear/non‑linear BV operations, moderate term depth (≈20) and a relatively dense network of comparisons, making it a typical industrial non‑linear BV verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/dccs-example-simple-node3458.smt2",
    "description": "This benchmark is a verification condition extracted from the KeYmaera hybrid‑system verifier (the “dccs‑example‑simple” adaptive cruise‑control model) and translated into 32‑bit bit‑vector arithmetic. It checks, via a single quantified formula, that a set of linear and quadratic safety constraints (involving velocities, positions, a time variable and parameters A, B, ε) cannot be simultaneously violated; the formula contains one existential quantifier, many nested conjunctions, and non‑linear BV multiplications (e.g., a squared time term). The instance is industrial‑style, medium‑size (≈2500 characters, depth 20) and typical of non‑linear arithmetic problems that are hard for pure BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node154163.smt2",
    "description": "This benchmark is a verification condition originating from the KeYmaera hybrid‑system prover (the “safe‑intersection” example) that has been bit‑vector‑encoded for the BV logic.  The formula asserts that, under a set of signed 32‑bit arithmetic constraints describing vehicle speeds, positions and timing (including non‑linear products such as A·t and a quadratic term v₁·v₁, as well as a signed division), there is **no** witness for the existential variable ts that violates the safety invariant; the solver therefore must prove the negated ∃‑formula unsatisfiable.  The instance features a single quantified block, 18 bit‑vector constants, moderate term depth (≈20) and a mix of linear and non‑linear comparisons, making it a typical industrial‑style safety‑verification problem with non‑linear arithmetic encoded in fixed‑size bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node171228.smt2",
    "description": "This instance encodes a safety verification condition from the KeYmaera hybrid‑systems benchmark suite (the “intersection‑example‑simple” proof node).  The goal is to prove that, given bounds on velocities, accelerations and a positive time horizon, the reachable positions of two vehicles remain within a safe interval; the formula is expressed as a single existential‑quantified BV‑formula whose negation is asserted, so the solver must show unsatisfiability.  The problem features 32‑bit non‑linear arithmetic (multiplication and division), a moderate number of variables (≈18), deep nested conjuncts (term depth ≈20), and no quantifier alternation, making it a typical industrial verification benchmark for bit‑vector nonlinear reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/train_goal4-node5686.smt2",
    "description": "This benchmark is an industrial verification condition originating from the KeYmaera proof of the European Train Control System (the “train_goal4” VC). It encodes a safety property as the negation of an existentially quantified conjunction of many 32‑bit bit‑vector constraints, featuring non‑linear arithmetic (several multiplications, a division, and quadratic terms) together with bounds and positivity assumptions on the variables. The solver must show that the existential formula is unsatisfiable, i.e., that the safety invariant holds; the instance is moderate in size (15 constants, depth 23) but challenging because of the dense non‑linear BV arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node14168.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system model of a one‑lane traffic intersection.  After translation to 32‑bit bitvectors, the formula asserts (via a negated existential) that no choice of the time variable can satisfy a large conjunction of linear and a few non‑linear (multiplication) bit‑vector constraints representing bounds on positions, velocities, and timing parameters.  The instance is an industrial‑style BV problem with a single quantified block, moderate depth (22) and 13 declared bit‑vector variables, making it a non‑linear arithmetic verification challenge.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node19598.smt2",
    "description": "This instance is a verification condition derived from the KeYmaera hybrid‑system verifier for a “safe intersection” scenario (single‑lane traffic). It encodes, in 32‑bit bit‑vector arithmetic, a safety invariant that must hold for all reachable states; the formula asserts the negation of an existential over a time variable together with a large conjunct of linear and non‑linear (multiplication, division) constraints on position, velocity and timing variables. The benchmark originates from an industrial case study (Keymaera/ITS) and features a single quantified assertion with moderate term depth (24) and several arithmetic operations, making it a typical non‑linear BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node170139.smt2",
    "description": "This instance encodes a verification condition from the KeYmaera hybrid‑systems tool (the “safe‑intersection” example) that has been translated into 32‑bit bit‑vector arithmetic.  The goal is to prove that, under a collection of linear and non‑linear bounds on positions, velocities, and timing variables (including multiplications and a division), no reachable state violates the safety predicate; formally it is the negation of an existential formula asserting the existence of a counterexample.  The benchmark therefore tests BV solvers on a single, moderately sized VC with one quantifier, many nested arithmetic constraints and a relatively deep term structure (depth 21), reflecting industrial‑level nonlinear arithmetic verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node392932.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system verifier for a simple traffic‑intersection scenario. It is a single quantified formula over 32‑bit bit‑vectors that mixes non‑linear arithmetic (multiplication and signed division) with many bound and ordering constraints on speeds, positions, timing and control parameters; the outer `not` forces the solver to prove the formula unsatisfiable (i.e., that no violating time exists). The instance is of industrial size (≈ 18 variables, term depth 20) and is challenging because of the nonlinear BV operations and the nested let‑expressions within the quantified block.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node694990.smt2",
    "description": "This instance encodes a verification condition extracted from a KeYmaera proof about a “safe‑intersection” hybrid system; the original real‑valued arithmetic has been translated to 32‑bit signed bit‑vectors. The formula asserts (by negating an existential) a conjunction of non‑linear constraints (multiplication, division, quadratic terms) together with bounds on several state variables, and asks the solver to prove that the quantified sub‑formula is unsatisfiable. Consequently, the problem is an industrial‑style safety‑verification check that features a single quantified variable, deep nested arithmetic expressions, and non‑linear bit‑vector reasoning, which makes it challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node392708.smt2",
    "description": "This benchmark is a bit‑vector encoding of a verification condition from the KeYmaera hybrid‑systems verifier, modeling a simple traffic‑intersection safety scenario.  It asserts, under a single existential time variable, a conjunction of non‑linear arithmetic constraints (multiplications, a division, and several signed comparisons) over 32‑bit quantities such as positions, velocities, and safety bounds, and then checks the negation of this existential formula for unsatisfiability.  The instance features a moderate number of variables (18 constants) but deep, non‑linear term structure (max depth 20) and a quantified sub‑formula, making it a challenging industrial‑style BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node19624.smt2",
    "description": "This instance encodes a safety verification condition from the KeYmaera hybrid‑systems benchmark suite (the “intersection‑example‑onelane” VC).  After being translated to 32‑bit bit‑vectors, the formula checks that, for all reachable states, a complex non‑linear arithmetic inequality (involving multiplications, squares, and divisions of several variables) never violates a safety bound; the SMT query is the negation of an existential sub‑condition, so the solver must prove unsatisfiability.  The benchmark is industrial‑grade, features a single quantified variable, deep (≈25) term nesting, and many non‑linear BV operations, making it a hard case for BV‑solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node479619.smt2",
    "description": "This instance is a safety‑verification condition extracted from a KeYmaera proof about a vehicle intersection scenario, translated into 32‑bit bit‑vector arithmetic. It asserts (negatively) that there exists a time point satisfying a collection of non‑linear constraints (multiplications, a division, and several linear inequalities) together with bounds on velocities, positions and parameters; the goal is to show the formula is unsatisfiable, i.e., the system stays safe. The problem features a single quantified existential, a moderate number of variables (19), deep terms (depth 20), and nonlinear BV arithmetic, making it a challenging industrial‑style verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node603232.smt2",
    "description": "This instance is a verification‑condition derived from the Keymaera hybrid‑system proof “intersection‑example‑simple”, modelling a safe‑intersection scenario. After translation to 32‑bit bit‑vectors it checks (by asserting the negation of an existential) that, under a collection of non‑linear arithmetic constraints (multiplications, a division and several linear bounds on positions, velocities and timestamps), a reachable state always respects the prescribed safety limits. The problem features a single quantified variable, mixed linear/non‑linear BV arithmetic, moderate term depth (≈20) and a handful of variables, making it a typical industrial safety‑verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/binary_driver-2007-10-09-node13791.smt2",
    "description": "This benchmark is an industrial verification condition extracted from the KeYmaera hybrid‑systems prover (binary driver example, node 13791) and translated into 32‑bit bit‑vector arithmetic. The single assertion checks that a quantified state (over a 32‑bit time variable) satisfies a large conjunction of non‑linear constraints involving many multiplications, squares, divisions and inequalities; it essentially encodes a safety invariant that must hold for all reachable states. The problem features a single existential quantifier, deep (≈22) term nesting, and a dense use of non‑linear bit‑vector operations, making it a challenging instance for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node290002.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system verifier (the “intersection‑example” case) as a single quantified bit‑vector formula. It checks that, under a set of linear bounds on several 32‑bit variables and a non‑linear term (the product v₂·v₂), no assignment exists that violates the required inequality constraints (e.g., vehicle speed limits and timing conditions). The instance features one existential quantifier, deep nested arithmetic (term depth 19) and a mix of linear and non‑linear BV operations, making it a challenging industrial‑style verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node346170.smt2",
    "description": "This benchmark is a verification condition taken from the KeYmaera hybrid‑systems prover (the “intersection‑example‑simple” proof node) and translated into 32‑bit bit‑vector arithmetic. It checks that, under a set of non‑linear relations (products and divisions of velocities) and a host of positivity and bound constraints on positions, velocities, and parameters, no witness exists for a timestamp that would violate the safety property of a traffic‑intersection model. The problem features a single quantified (∃) formula with many conjunctive constraints, non‑linear BV operations, and a moderate depth (21) over 19 variables, making it a challenging industrial BV‑non‑linear verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node197075.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems tool (the “intersection‑example” for safe traffic‑light crossings) as a 32‑bit bit‑vector formula. The assertion checks that, under a large set of linear bounds on velocities, positions, and timing variables, there is **no** assignment to the existential time variable that would violate the quadratic safety inequality involving v₁·v₁ / (2·B). The problem features non‑linear arithmetic (multiplication and division), a single quantified variable, and deep (≈20) term nesting, making it a challenging industrial‑style BV verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/dccs-example-node6709-new.smt2",
    "description": "This instance is a bit‑vector verification condition originating from the Keymaera hybrid‑system verifier (adaptive cruise‑control example) and was translated to BV by Mathias Preiner. It asks whether there exists a 32‑bit time stamp that satisfies a conjunction of signed inequalities involving non‑linear arithmetic (quadratic terms, multiplication, and division by a symbolic constant) together with positivity constraints on several parameters. The formula is a single, deeply nested existential query (term depth 20, 10 variables) that encodes a safety property, making it a challenging non‑linear BV‑SAT problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node31555.smt2",
    "description": "The benchmark encodes a safety verification condition from the KeYmaera hybrid‑system verifier (the “safe‑intersection” example) that has been translated into 32‑bit signed bit‑vector arithmetic. It asks to prove the unsatisfiability of a single existential formula that contains a rich conjunction of non‑linear constraints – quadratic terms, products of variables, and divisions – together with many signed inequality bounds. With 13 bit‑vector constants, a maximal term depth of 23 and mixed arithmetic, the instance represents a challenging industrial BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20210330-PEak/no-extern-loop_sat_subset/hard1.smt2",
    "description": "This instance comes from the PEak project’s hardware rewrite‑rule synthesis benchmark. It encodes a single quantified condition over a large collection of 16‑bit input vectors, registers and control bits, and then checks a huge Boolean conjunction that mixes extracts, concatenations, sign/zero extensions, arithmetic (add, mul, shift) and many nested ite‑expressions to model a complex datapath (muxes, condition codes, LUTs, etc.). With a term‑depth exceeding 1.6 million and over a hundred thousand let‑bindings, it is an industrial‑scale BV verification problem that is deliberately hard for solvers such as CVC4 and Z3.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node389601.smt2",
    "description": "The instance encodes a verification condition from the Keymaera hybrid‑system verifier (the “intersection‑example‑simple” case). It is a single‑quantified (∃ ts) safety check on 32‑bit signed bit‑vectors that involve non‑linear arithmetic (multiplications, a signed division) and many signed order constraints over variables representing positions, velocities and time bounds. The problem is an industrial‑style BV benchmark whose difficulty stems from the combination of non‑linear bit‑vector operations, a quantified variable, and a relatively deep term structure (depth ≈ 20).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node45116.smt2",
    "description": "This instance is a verification condition extracted from the KeYmaera hybrid‑system verifier (the “intersection‑example‑onelane” case) and translated into 32‑bit bit‑vector arithmetic.  It checks that, for all admissible values of time, position and velocity variables (non‑negative, bounded by a safety limit V, and satisfying several non‑linear relations such as v·v and B·t), a certain safety inequality holds; the SMT query is the negation of an existential formula, so the solver must show the formula is unsatisfiable.  The problem features a single quantified block, many non‑linear BV multiplications/divisions, and a relatively deep term structure (depth 24), making it a challenging industrial‑style non‑linear arithmetic verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node193438.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system prover (the “intersection‑example” proof node) as a quantifier‑free bit‑vector formula.  The single‐assertion asserts the negation of an existential witness for a time‑step variable that would violate a set of linear and non‑linear arithmetic bounds (including multiplications, divisions and signed comparisons) over 32‑bit integers.  It therefore tests a solver’s ability to handle deep, nested let‑expressions, mixed signed/unsigned inequalities, and non‑linear BV arithmetic in an industrial‑style verification setting.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node606769.smt2",
    "description": "This instance encodes a verification condition from the KeYmaera hybrid‑system verifier (a safe‑intersection proof) as a quantified bit‑vector formula.  It asserts the negation of an existential claim over a time variable, combining linear and non‑linear constraints (multiplications, a division, and several signed inequalities) on 32‑bit variables that model positions, velocities and parameters of the system.  The problem therefore tests a solver’s ability to handle non‑linear arithmetic on bit‑vectors with a moderate number of variables, deep term nesting (depth 19) and a single quantifier alternation, typical of industrial hybrid‑system verification workloads.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node254826.smt2",
    "description": "This instance encodes a safety verification condition from the KeYmaera hybrid‑systems verifier (the “intersection‑example” from the safe‑intersection case study) that has been translated to 32‑bit bit‑vector arithmetic. It asks whether there exists a time‑step value satisfying a conjunction of non‑linear constraints involving multiplications, a division, and many signed order relations over positions, velocities and parameters; the outermost negation turns the query into an unsatisfiability check for that existential witness. The benchmark is industrial‑style, features a single quantified variable, deep (≤20) term nesting, and non‑linear BV arithmetic, making it a hard case for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node345482.smt2",
    "description": "The file encodes a verification condition for a hybrid‑systems safety proof (the “intersection‑example” from the KeYmaera tool).  After being translated from real‑valued non‑linear arithmetic to 32‑bit bit‑vectors, the goal is to show that the negated existential formula is unsatisfiable; it contains a single quantified variable together with many non‑linear multiplications, a division, and numerous signed‑comparison constraints over 19 bit‑vector constants.  The benchmark therefore tests a solver’s ability to handle quantified, non‑linear bit‑vector arithmetic typical of industrial hybrid‑system verification problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node488018.smt2",
    "description": "This benchmark encodes a safety‑property verification condition from the KeYmaera hybrid‑systems verifier (the “intersection‑example” case study). After being translated to 32‑bit bit‑vectors, it asks whether there exists a time instant ts that satisfies a conjunction of non‑linear constraints involving multiplications, a division, and several signed inequalities over system parameters (A, B, V, etc.). The single existential quantifier and the depth‑21, non‑linear BV arithmetic make it a challenging industrial verification instance rather than a pure SAT‑check.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node619055.smt2",
    "description": "This benchmark encodes a verification condition generated by the KeYmaera hybrid‑systems prover for the “safe intersection” example (node 619055 of the proof “intersection‑example‑simple”). The original real‑valued non‑linear arithmetic constraints (quadratic terms, division, and inequalities) have been bit‑vector‑translated (32‑bit) and wrapped in a single existential quantifier, yielding a BV‑logic formula that checks an invariant about vehicle positions, speeds (v₁, v₂) and a time bound (ep). The instance is industrial‑style, features nonlinear BV arithmetic, nested let‑bindings, and a moderate quantifier depth, making it representative of hard non‑linear arithmetic verification problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node392183.smt2",
    "description": "This benchmark encodes a verification condition from the KeYmaera hybrid‑system verifier (the “safe‑intersection” example) as a single quantified bit‑vector formula. The goal is to show that no 32‑bit time value can satisfy a set of non‑linear arithmetic constraints (quadratic terms, products of variables, and division) that model vehicle positions, velocities and safety bounds, i.e., to prove the safety invariant holds. The instance features a negated existential over a time variable, numerous linear and non‑linear BV inequalities, deep term nesting (depth 19) and 18 declared constants, making it a challenging BV‑non‑linear verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node719994.smt2",
    "description": "This instance encodes a verification condition from the KeYmaera hybrid‑systems verifier (the “safe‑intersection” example) that has been translated into 32‑bit bit‑vector arithmetic. The formula asserts that, for all admissible values of the system’s parameters (positions, velocities, bounds A, B, V, and a time variable), a safety property expressed through non‑linear relationships (multiplications and divisions of bit‑vectors) holds; the SMT query is the negation of an existentially‑quantified condition, so the solver must refute a single, fairly large non‑linear BV constraint. The benchmark features one quantifier, several non‑linear BV operations, a moderate number of constants (20) and a term depth of 20, making it a representative industrial‑style verification problem that stresses BV solvers on quantified non‑linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node53911.smt2",
    "description": "This instance encodes a verification condition from the KeYmaera hybrid‑systems verifier (the “intersection‑example‑onelane” proof) that checks a safety property of a traffic‑intersection scenario.  After being translated to 32‑bit bit‑vectors, the formula asserts (via a negated existential) a conjunction of non‑linear arithmetic constraints—bounds, positivity conditions, and a key inequality involving products (e.g., A·t, v·v) and a division by 2·B—together with a disjunction linking two possible cases for a control flag.  The problem is a single‑quantifier, non‑linear BV verification task of moderate size (13 variables, term depth 22) that challenges solvers with mixed multiplication/division and several layered range constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node535359.smt2",
    "description": "This instance encodes a safety verification condition from the KeYmaera hybrid‑systems tool (the “intersection‑example‑simple” proof) that was translated into 32‑bit bit‑vector arithmetic. It asserts that no values of the time variable ts satisfy a conjunction of linear and non‑linear constraints (including multiplication of two symbolic bit‑vectors and a signed division) that would violate the safety bounds on velocities, distances, and other parameters—hence the outer **not exists** checks unsatisfiability. The benchmark features a single quantified formula with deep (depth 20) terms, many signed comparisons, and non‑linear arithmetic, making it a challenging industrial BV‑solving problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node368427.smt2",
    "description": "The benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems verifier (the “intersection‑example‑simple” proof node).  After translation to 32‑bit bit‑vectors it asserts that there is **no** time instant `ts` satisfying a large conjunction of linear and non‑linear arithmetic constraints involving multiplications, a division, and several bounds on positions, velocities, and parameters (e.g., `A`, `B`, `V`, `ep`).  The formula contains a single existential quantifier under a negation, 19 bit‑vector constants, deep nested arithmetic (term depth 21) and many relational operators, making it a non‑linear BV verification problem typical of industrial hybrid‑system case studies.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node351044.smt2",
    "description": "This benchmark encodes a safety verification condition for a hybrid‑systems model of a road intersection (the “KeYmaera” example). The original nonlinear arithmetic proof obligation—containing quadratic terms, divisions and several inequalities over vehicle positions, velocities and time—is translated into 32‑bit bit‑vector constraints and wrapped in a single negated existential formula, so the solver must prove the negation unsatisfiable. The instance is industrial‑grade (large term depth, mixed linear/non‑linear BV arithmetic, one quantifier) and tests a solver’s ability to handle non‑linear arithmetic after bit‑vector encoding.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node290415.smt2",
    "description": "This benchmark encodes a verification condition from the KeYmaera hybrid‑systems prover (the “safe intersection” example) as a 32‑bit bit‑vector problem. The formula asserts the non‑existence of a time‑step value that violates a collection of non‑linear arithmetic constraints involving multiplication, division and several order relations on vehicle‑position and speed variables. It features a single existential quantifier, nested let‑bindings, and moderate term depth (19), making it a representative industrial non‑linear BV verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node672726.smt2",
    "description": "The benchmark encodes a safety verification condition for a hybrid‑system model of a vehicle intersection (the “intersection‑example” from KeYmaera). After translating the original real‑valued non‑linear arithmetic into 32‑bit bit‑vectors, the formula asserts that no choice of a time variable can satisfy a conjunction of non‑linear constraints (multiplications and a division) together with numerous upper‑ and lower‑bound inequalities on positions, velocities and parameters. It therefore constitutes a single‑existential, non‑linear BV verification problem with about 20 variables and a deep term structure, typical of industrial hybrid‑system proof obligations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/dccs-example-node3897.smt2",
    "description": "This instance encodes a safety verification condition from the KeYmaera hybrid‑system verifier (the “dccs‑example” adaptive‑cruise‑control benchmark), translated into 32‑bit bit‑vector arithmetic. The formula asserts, via a negated existential quantifier, that a conjunction of many non‑linear constraints (products of variables, a division, and several linear inequalities) can never be satisfied, effectively checking that a hybrid‑system invariant holds. The benchmark is industrial‑style, contains a single quantified assertion with deep nesting (term depth 22) and a high density of multiplication/division operations, making it a challenging non‑linear BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node672976.smt2",
    "description": "This instance encodes a safety verification condition for the “safe‑intersection” hybrid‑system example from the KeYmaera proof suite. After being translated to 32‑bit bit‑vectors, the formula asserts (by negating an existential) that all of a large conjunction of linear and non‑linear constraints—including squares of velocities (bvmul v v), divisions, and several lower/upper bounds on positions, velocities, and timing parameters—must hold for any admissible time instant, thereby checking an invariant of the traffic‑intersection model. The benchmark is industrial‑style, contains a single quantified block, many conjuncts (≈20), and non‑linear arithmetic over bit‑vectors, which together make it a challenging case for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node172570.smt2",
    "description": "This benchmark is a safety‑verification condition originating from the KeYmaera hybrid‑systems prover (the “intersection‑example” from the safe‑intersection case study). It encodes, in 32‑bit bit‑vector arithmetic, non‑linear constraints on vehicle speeds, accelerations and positions (including multiplication and signed division) together with bounds that must hold for all reachable states; the formula asserts the non‑existence of a counterexample time instant satisfying these constraints. The instance features a single existential quantifier, a deep conjunction of arithmetic inequalities, and non‑linear BV operations, making it a challenging industrial verification problem in the BV logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node197946.smt2",
    "description": "This benchmark encodes a safety‑verification condition for a hybrid‑system model of a traffic intersection (the KeYmaera “intersection‑example”). The formula states, in 32‑bit bit‑vector arithmetic, that under a collection of positivity and bound constraints (including a non‑linear term v₁·v₁/(2·B) and several multiplications) there is **no** choice of the time variable ts₉₂₆ that violates the invariant; the SMT query checks the unsatisfiability of the negated existential condition. The instance features a single quantified block, moderate term depth (≈20), and non‑linear bit‑vector operations, making it a representative industrial verification problem for non‑linear arithmetic solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node633178.smt2",
    "description": "This benchmark encodes a verification condition from the KeYmaera hybrid‑system verifier (the “safe‑intersection” example) as a 32‑bit bit‑vector problem. It checks that, under a set of non‑linear arithmetic constraints involving quadratic terms, divisions, and several positivity/ordering inequalities, a safety predicate holds for all reachable states; the condition is expressed with a single existential quantifier over a time variable and a deep conjunction of arithmetic relations. The instance features many 32‑bit variables, non‑linear multiplications, and division, leading to a relatively high term depth (20) and making it a challenging industrial‑style BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node389285.smt2",
    "description": "This benchmark encodes a safety‑verification condition for a hybrid‑systems model of a road intersection (originating from the KeYmaera proof suite) that has been translated to 32‑bit bit‑vectors. The asserted formula is the negation of an existential statement over a time variable, containing non‑linear arithmetic (products of velocities, division by constants) and order constraints that ensure the vehicles’ positions stay beyond a computed safety distance. The problem features a single quantifier but deep term nesting (depth 21) and several non‑linear BV operations, making it a challenging industrial verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/bouncing-ball-simple-node5920.smt2",
    "description": "This instance is a verification‑condition from the KeYmaera “bouncing‑ball” benchmark, translated into 32‑bit bit‑vector arithmetic. It asserts (by negating an existential) that for every admissible time step the quadratic dynamics of a bouncing ball keep the height non‑negative and respect velocity bounds, using non‑linear multiplications, divisions and several linear inequalities. The problem therefore tests solvers on a small but highly non‑linear BV formula with a single quantifier and deep term nesting (depth 19), typical of industrial hybrid‑system verification tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node195519.smt2",
    "description": "This instance is a verification condition extracted from a KeYmaera hybrid‑system proof about a “safe intersection” scenario (node 195519 of *intersection‑example‑simple*). It asks whether a single existentially quantified 32‑bit variable can satisfy a conjunction of linear and non‑linear BV constraints (including multiplication, division and several signed inequality relations) that encode the safety invariants of the system; the outer negation turns the query into a validity check (unsat ⇔ the safety property holds). The problem features only one quantifier block but a relatively deep term structure (depth 21) with 18 bit‑vector variables and a mix of arithmetic operations, making it a challenging non‑linear BV verification benchmark from the industrial Preiner‑Keymaera family.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node5581.smt2",
    "description": "This instance encodes a safety verification condition from the KeYmaera hybrid‑systems benchmark “intersection‑example‑onelane”.  After translation to 32‑bit bit‑vectors it asserts that there exists a time instant (represented by the variable ts10) for which a complex non‑linear inequality—mixing multiplications, divisions and additions over constants A, B, V, ep, etc.—holds, while also respecting a host of bounds on all involved quantities.  The solver must decide whether the quantified formula is unsatisfiable, i.e., whether the encoded collision‑avoidance invariant is guaranteed; the problem features a single existential quantifier, moderate term depth (23) and non‑linear bit‑vector arithmetic, making it a challenging industrial verification case.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node631052.smt2",
    "description": "This benchmark is a safety‑verification condition extracted from the KeYmaera hybrid‑systems prover (the “intersection‑example‑simple” proof) and translated into 32‑bit bit‑vector arithmetic. It checks that, under a set of linear bounds on positions, velocities and timing variables, the hybrid dynamics (involving non‑linear terms such as v₁·v₁ and v₂·v₂) never violate the intersection safety invariant; the formula is a single quantified (∃ ts) implication containing many conjuncts of equality, inequality and division constraints. The instance is industrial‑type, features one existential quantifier, non‑linear multiplications, deep term nesting (depth 22) and a modest number of bit‑vector variables (19), making it a challenging BV‑non‑linear arithmetic verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node21162.smt2",
    "description": "This benchmark encodes a safety verification condition for a hybrid‑systems model of a one‑lane traffic intersection (Keymaera proof node 21162).  The SMT‑LIB file asserts the negation of an existential formula over 32‑bit bit‑vectors, containing non‑linear arithmetic (multiplication of variables, a division, and quadratic terms) together with several linear bounds on positions, speeds and timing parameters.  The solver must show the formula is unsatisfiable, thereby proving that the encoded safety invariant holds; the instance features a single quantifier, moderate term depth (23) and 13 declared constants, making it a typical industrial verification benchmark for non‑linear bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node489032.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems verifier (the “safe‑intersection” example) that has been translated into 32‑bit bit‑vector arithmetic. The formula asserts the negation of an existential state (over a time variable) satisfying a collection of non‑linear constraints—multiplications, a division, and several linear inequalities—together with bounds on the system variables, representing the requirement that no unsafe crossing can occur. Consequently, the instance challenges solvers with a single quantified bit‑vector formula featuring non‑linear arithmetic, deep nesting (term depth 21) and numerous conjuncts, typical of industrial hybrid‑system verification problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node156618.smt2",
    "description": "This benchmark encodes a safety verification condition for the “intersection‑example‑simple” hybrid‑system case study from the KeYmaera verification tool suite (see Loos & Platzer, ITSC 2011). The formula is a single ¬∃ assertion over 32‑bit bit‑vectors that asserts a conjunction of bounds on positions, velocities and timing variables together with a non‑linear term (a product of a velocity‑related variable and a time variable). The goal is to show the existential condition is unsatisfiable, i.e., that the intersection model respects the specified safety invariant; the presence of quantified BV arithmetic, several linear and one non‑linear multiplication, and a moderate term depth (≈20) makes the instance a challenging industrial‑style verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/binary_driver-2007-10-09-node12552.smt2",
    "description": "This benchmark encodes a verification condition from the KeYmaera hybrid‑system verifier (the “binary driver” example) that has been translated into 32‑bit bit‑vector arithmetic. The single assertion is the negation of an existential property over a time variable, containing many non‑linear operations (quadratic multiplications, divisions and mixed additions/subtractions) together with a variety of signed order constraints, so the solver must prove the formula unsatisfiable. It is an industrial‑style BV instance with 15 declared constants, a deep term structure (depth 23) and a single quantified block, making it a challenging case for non‑linear BV solving.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node43329.smt2",
    "description": "This benchmark encodes a safety verification condition for a hybrid‑systems model of a single‑lane intersection (the “intersection‑example‑onelane” proof from the KeYmaera verifier). The goal is to show that no 32‑bit state satisfying a complex set of linear and non‑linear bounds (including multiplications, a division, and several ordering constraints) can make the safety predicate false; this is expressed as the unsatisfiability of a single existential BV formula that is then negated. The instance derives from the industrial‑style Keymaera suite, features 12 bit‑vector variables, deep (≈22) term nesting, and a dense conjunction of arithmetic constraints, making it a challenging non‑linear arithmetic/verification problem in the BV logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node156170.smt2",
    "description": "This benchmark encodes a safety‑verification condition from the KeYmaera proof of a “safe intersection” hybrid system.  All relevant variables (positions, speeds, parameters) are represented as 32‑bit bit‑vectors, and the formula asserts that, under non‑negative assumptions on the parameters and a non‑linear relation involving multiplication and division, the system’s state after an existentially‑quantified time step satisfies several inequality constraints (bounds on speeds, position ordering, and a timing limit).  It is a single‑quantifier, non‑linear arithmetic VC translated to BV, characteristic of industrial hybrid‑system verification problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node191763.smt2",
    "description": "This instance encodes a verification condition from the KeYmaera hybrid‑systems prover (the “intersection‑example‑simple” proof node), translated into 32‑bit bit‑vector arithmetic. The formula asserts the negation of an existential statement over a time variable and contains a mixture of range constraints and a non‑linear arithmetic core (multiplications, a division and quadratic terms) together with several relational checks (≥0, ≤V, >0). Consequently, the problem is an industrial safety‑verification benchmark that challenges BV solvers with deep, quantified, non‑linear bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node192976.smt2",
    "description": "This instance is a safety‑verification condition from the KeYmaera hybrid‑systems benchmark “Safe intersections”, translated from real arithmetic to 32‑bit bit‑vectors.  The formula asserts (by negating an ∃‑quantified sub‑formula) that a set of non‑linear arithmetic constraints—multiplications, a division, and several inequality relations over velocities, positions and time—cannot be satisfied, thus checking the validity of the VC.  Although modest in size (18 constants, one quantified sub‑formula), it features deep nested terms (depth 20) and non‑linear bit‑vector operations, making it a challenging industrial‑style BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node16159.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system proof “intersection‑example‑onelane” (an industrial‐grade traffic‑intersection model) after translation to 32‑bit bit‑vector arithmetic. The formula asserts that no assignment to a time‑stamp variable can simultaneously satisfy a collection of linear bounds together with a non‑linear relation involving products and a division of bit‑vectors (effectively a quadratic inequality on positions, velocities and time). It features a single existential quantifier, 13 declared constants, a moderate term depth (23), and heavy use of bvmul/bvsdiv, making it a challenging non‑linear bit‑vector verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node723526.smt2",
    "description": "This instance encodes a single verification condition from the Keymaera hybrid‑systems benchmark “safe intersections”.  The VC has been translated from non‑linear real arithmetic into 32‑bit bit‑vectors, introducing multiplications and signed divisions that model the quadratic motion of two vehicles.  It contains an existentially‑quantified time variable and a conjunction of bounds (variables ≥0, ≤ V) together with safety constraints that compare the vehicles’ positions to safety margins; the outer “not‑exists” asserts that no counter‑example exists.  The problem is thus an industrial‑style safety‑verification query with one quantifier block, moderate term depth (≈21) and a handful of non‑linear BV operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node194065.smt2",
    "description": "This benchmark encodes a safety verification condition from KeYmaera’s “safe‑intersection” hybrid‑system example. After being translated to 32‑bit vector arithmetic, it checks (by negating an existential) that no time‑step value can violate a collection of non‑linear constraints involving addition, multiplication, division and several ordering relations on system variables. The problem features a single quantified block, many nested conjuncts, non‑linear BV operations and a moderate term depth, making it a typical industrial verification‑condition instance for BV‑solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node709258.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system prover (the “intersection‑example” case) that has been translated to 32‑bit bit‑vector arithmetic.  It asserts the *negation* of an existential property over a time variable, combining signed inequalities with non‑linear operations (multiplication and division) and several auxiliary constants, so the solver must show the formula is unsatisfiable to prove the original safety invariant.  The instance is industrial‑style, uses a single quantified block, about 20 BV variables, and reaches a moderate term depth (≈21), making it a non‑linear BV verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node166868.smt2",
    "description": "This instance encodes a safety verification condition from the KeYmaera hybrid‑system benchmark “intersection‑example‑simple”.  The formula asserts the non‑existence of a time instant (the quantified bit‑vector ts771₀) that violates a collection of linear and non‑linear 32‑bit arithmetic constraints modeling positions, velocities and timing bounds (e.g., quadratic terms v₁·v₁, products with constants A, B, and a division).  Consequently, the solver must prove the negated existential (i.e., an unsatisfiable set) in the BV logic, which involves a single quantifier, moderate term depth (≈20) and mixed multiplication/division, making it a typical industrial verification problem with non‑linear bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node391376.smt2",
    "description": "This instance is a safety‐verification condition extracted from the KeYmaera hybrid‑system tool (the “intersection‑example‑simple” proof). It has been translated into 32‑bit bit‑vector arithmetic, preserving the original non‑linear relationships (multiplications and signed divisions) among a handful of numeric variables that model positions, velocities and timing of two moving objects. The formula is a single quantified (∃ ts) assertion that is negated, so the solver must prove that no counter‑example exists; it contains a mixture of linear and non‑linear BV inequalities, a few equalities, and one quantifier alternation, making it a typical industrial‑style BV verification problem with moderate term depth (≈21) and 19 declared constants.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node190062.smt2",
    "description": "This benchmark encodes a verification condition from the Keymaera hybrid‑system verifier (the “safe intersection” example).  After translating the original real‑valued proof goal into 32‑bit bit‑vectors, the formula asserts that there is **no** assignment to a time variable ( ts883uscore0 ) satisfying a conjunction of signed inequalities and non‑linear arithmetic (multiplications and a division) that model vehicle positions, velocities, and safety parameters (A, B, V, ep).  The problem is a single‑existential BV query with moderate term depth (21) and a handful of quantified and non‑linear constraints, typical of industrial verification of hybrid‑system safety properties.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/bouncing-ball-simple-node5964.smt2",
    "description": "This instance is a verification condition from the Keymaera “bouncing‑ball‑simple” benchmark (node 5964), translated into 32‑bit bit‑vector arithmetic. It encodes a non‑linear safety property of a hybrid system: a quantified formula asserts the existence of a time instant satisfying a conjunction of range constraints and quadratic inequalities (e.g., t², ts²) together with a linear relation among the variables; the outer negation turns the check into an unsatisfiability query. The problem features a single quantified block, deep (≈19) term nesting, and multiple non‑linear bv‑multiplications, making it a challenging industrial BV‑non‑linear arithmetic verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node548485.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems prover (the “intersection‑example‑simple” proof) as a quantifier‑free bit‑vector problem. The single assertion checks that no assignment to the time variable can simultaneously satisfy a collection of non‑linear arithmetic constraints (multiplications, a division, and several signed inequalities) involving twenty 32‑bit variables, so the solver must prove the negated existential is unsatisfiable. The instance features moderate term depth (21) and a single existential quantifier, but the presence of non‑linear bit‑vector operations makes it a challenging industrial‑style verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node12517.smt2",
    "description": "This instance encodes a verification condition generated by the KeYmaera hybrid‑system prover for the “safe‑intersection” example (one‑lane traffic crossing) and was translated from real arithmetic to 32‑bit bit‑vector arithmetic. The formula asserts that, under a collection of linear and non‑linear (multiplication, division) constraints on positions, velocities, and timing variables, a safety inequality on the vehicle’s position holds; the check is expressed with a single existential quantifier over a time variable. The benchmark is classified as an industrial‑level verification problem and is demanding for solvers because it combines non‑linear bit‑vector arithmetic, a moderate number of variables (13), deep term nesting (depth 24), and quantifier reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/ETCS-essentials-live2.proof-node640.smt2",
    "description": "This benchmark encodes a verification condition from the European Train Control System case study (Keymaera) as a 32‑bit bit‑vector problem. It asks whether there exists a 32‑bit value that satisfies a set of signed‑greater‑zero constraints on several variables together with a non‑linear inequality involving a product of two variables and an addition; the outer negation turns the query into an “is the condition unsatisfiable?” check. The instance contains a single existential quantifier, modest term depth (8), seven declared constants, and a mix of signed comparisons and BV multiplication, making the difficulty stem mainly from the non‑linear arithmetic rather than quantifier alternation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node4261.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system prover (the “intersection‑example‑onelane” proof), translated into 32‑bit bit‑vector arithmetic. The formula asserts that there is **no** assignment to a time variable satisfying a conjunction of linear and non‑linear (multiplication, division) constraints that would violate the intended invariant about vehicle positions, speeds and timing at a traffic intersection. The instance is an industrial‑style BV problem with 13 constants, a single existential quantifier, moderate term depth (23) and several non‑linear bit‑vector operations, making it a challenging case for solvers handling non‑linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node559749.smt2",
    "description": "This benchmark encodes a verification condition from the KeYmaera hybrid‑system verifier (the “intersection‑example” case) and has been translated into 32‑bit bit‑vector arithmetic. The single quantified assertion negates the existence of a time stamp satisfying a collection of non‑negative bounds, linear and non‑linear (multiplication, division) relationships among the variables, effectively checking that the safety property holds for all reachable states. The problem features 20 bit‑vector constants, deep nested Boolean structure, and non‑linear arithmetic, making it a moderately large, industrial‑style BV verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node291616.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system prover (the “intersection‑example” from the safe‑intersection case study). After translating the original real‑valued nonlinear dynamics into 32‑bit bit‑vectors, the formula asserts that no valuation of the time variable ts₁₃₆₀ can violate a collection of positivity, bounds, and nonlinear (quadratic and division) constraints on positions, velocities, and interval parameters; the outer `not (exists …)` therefore checks the validity of the safety property. The instance features a single existential quantifier, moderate term depth (≈19), and non‑linear bit‑vector arithmetic (multiplication and division), making it a representative industrial verification problem that is hard for standard BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node152045.smt2",
    "description": "This benchmark encodes a safety verification condition generated by the KeYmaera hybrid‑systems prover (the “intersection‑example‑simple” case). The goal is to show that, under a set of bounds on speeds, positions and timing variables (all modeled as 32‑bit signed bit‑vectors), a dangerous crossing cannot occur; the formula contains an existentially‑quantified time variable together with non‑linear arithmetic (multiplication and division) that has been translated into bit‑vector operations. The instance features a single large conjunctive clause with many signed‑comparison constraints, a moderate number of variables (19) and a relatively deep term structure (depth 20), making it a non‑linear, quantified BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node5338.smt2",
    "description": "This instance is a verification condition from the KeYmaera hybrid‑system prover, extracted from a safety proof for a one‑lane traffic‑intersection scenario. The formula asserts the non‑existence of a time instant ts9 that simultaneously satisfies a large conjunction of linear and non‑linear (multiplication/division) 32‑bit bit‑vector constraints on positions, velocities, and parameters such as acceleration and safety distances. It contains a single existential quantifier, deep nested arithmetic (term depth 23) and several non‑linear BV operations, making it a challenging BV‑non‑linear arithmetic benchmark in the industrial “Preiner‑keymaera” family.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node732272.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems tool (the “safe‑intersection” example) as a quantifier‑free bit‑vector formula. After translating the original real‑valued non‑linear arithmetic into 32‑bit bit‑vectors, the instance checks that, under a set of positivity and range constraints on speeds, distances and timing parameters, no counter‑example exists for the existential timing variable; the formula therefore consists of a single negated existential with numerous non‑linear multiplications, divisions and signed inequalities. The problem is industrial‑style verification, featuring 19 bit‑vector constants, moderate term depth (20) and a single quantifier layer, making the difficulty stem mainly from the non‑linear BV arithmetic rather than quantifier alternation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node99874.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems prover (the “intersection‑example‑simple” proof) as a quantifier‑rich bit‑vector formula.  The goal is to refute the existence of a time instant ts₄₆₆₀ that satisfies a collection of linear‑arithmetic constraints on positions, velocities, and parameters (A, B, V, ep) together with bounds such as non‑negativity, upper limits (≤ V), and a positivity condition on a derived linear expression ( A·ts₄₆₆₀ + v₂ , −B·ts₄₆₆₀ + v₁ ).  The instance features a single existential quantifier over a 32‑bit variable, about 18 declared bit‑vectors, and a moderate term depth (19), making it a representative industrial verification problem with non‑linear arithmetic that has been translated into the BV logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/dynamic_reaction_to_static_bounds.proof-node849.smt2",
    "description": "This instance is a bit‑vector encoding of a verification condition extracted from the KeYmaera hybrid‑systems verifier (dynamic reaction to static bounds). The formula asserts, under a collection of lower/upper bound constraints on several 32‑bit variables, that a final inequality involving a non‑linear term (a₂·t₁ + B·Tr) holds; the SMT problem checks the unsatisfiability of its negation, using a single existential quantifier. It features moderate size (≈1700 characters), 8 declared constants, a maximum term depth of 16, and non‑linear bit‑vector multiplication, which makes the solving task non‑trivial despite the lack of quantifier alternations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node347607.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system verifier (the “intersection‑example” proof), translated into 32‑bit bit‑vector arithmetic. The formula asserts, under a collection of non‑linear constraints (multiplications, a division, and several signed inequalities on velocity‑ and position‑like variables), that a certain existentially‑quantified state cannot exist – i.e., it checks unsatisfiability of the negated property. The instance is medium‑sized (19 bit‑vector constants, term depth 20) and stresses a solver’s ability to handle non‑linear BV reasoning with many arithmetic and relational operators.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node619900.smt2",
    "description": "This benchmark encodes a safety verification condition from the Keymaera hybrid‑system model of a road intersection, translated into 32‑bit bit‑vector arithmetic. It asks whether there exists a time instant (the quantified variable) that violates a set of nonlinear constraints—quadratic terms, divisions, and linear bounds—describing vehicle positions, velocities and acceleration limits, together with positivity and range requirements on the parameters. The instance is an industrial‑style BV problem with a single quantified formula, moderate term depth (21) and about twenty variables, illustrating the difficulty of solving non‑linear arithmetic after bit‑vector encoding.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node267257.smt2",
    "description": "The benchmark encodes a safety verification condition from the KeYmaera hybrid‑system proof “intersection‑example‑simple”, translated into 32‑bit bit‑vector arithmetic. It asks whether there exists a time value (`ts1241uscore0`) satisfying a conjunction of non‑linear constraints (multiplications, a division, and several linear inequalities) that would violate the intended invariant of the intersection scenario; the outer `not` turns the query into a proof‑obligation that the unsafe region is unreachable. The instance features a single existential quantifier, moderate term depth (≈20), and numerous bit‑vector arithmetic operations, making it a typical industrial BV encoding of a nonlinear arithmetic verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node264965.smt2",
    "description": "This benchmark encodes a verification condition generated by the KeYmaera hybrid‑systems tool for a simple traffic‑intersection safety example. After translation to 32‑bit bit‑vectors, the formula asserts that **no** assignment to a quantified time variable can satisfy a conjunction of range constraints, non‑negative bounds, and mixed linear/non‑linear (multiplication and division) arithmetic on the variables. Consequently, the instance challenges solvers with a modest number of bit‑vector variables (19) but non‑linear BV operations inside an existential quantifier, giving a moderate term depth (≈20) and making quantified non‑linear bit‑vector reasoning the main difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/dccs-example-node3896.smt2",
    "description": "This benchmark encodes a verification condition from the KeYmaera hybrid‑system proof of an adaptive cruise‑control example (node 3896 of the dccs‑example).  The goal is to show that, under a collection of linear and non‑linear bit‑vector inequalities (including products of variables and a division by a constant), a certain safety inequality always holds; the condition is expressed with a single existential quantifier over a time variable.  The problem is therefore a non‑linear arithmetic verification task translated into 32‑bit BV, featuring moderate term depth (22), several multiplications/divisions and a handful of quantified constraints, which makes it challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node682405.smt2",
    "description": "This instance encodes a safety verification condition from the KeYmaera hybrid‑systems proof “intersection‑example‑simple”, translated into 32‑bit bit‑vector arithmetic.  It asserts that, under a set of linear bounds on positions, velocities, time variables and parameters (all required to be non‑negative and within a given maximum V), there cannot exist a time step `ts3263uscore0` that violates the hybrid‑system dynamics (expressed through linear combinations `A·t+v1` and `‑B·t+v2`) while still respecting a global deadline `ep`.  The formula contains a single existential quantifier, an implication chain, and modest term depth (≈20) with 19 bit‑vector constants, making it a typical industrial‑style verification benchmark rather than a large‑scale synthesis or scheduling problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node551039.smt2",
    "description": "This instance encodes a verification condition from the KeYmaera hybrid‑system verifier (the “safe‑intersection” example) as a quantifier‑free bit‑vector problem.  It asserts that no assignment to the time variable ts1246₀ can satisfy a conjunction of non‑linear arithmetic constraints (including multiplications, a division by 2·B, and several signed ≤/≥ comparisons) that model safety properties such as non‑negative speeds, bounded velocities, and the condition xI₂ > x₂ + v₂²/(2·B).  The benchmark is industrial‑scale, features a single existential quantifier, deep term nesting (depth 20), and many intertwined bit‑vector operations, making it a challenging case for solvers handling non‑linear arithmetic translated to the BV logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node48996.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system verifier (a “safe‑intersection” proof) as a single quantified bit‑vector formula.  The goal is to show that no assignment to the existentially‑bound time variable can satisfy a conjunction of non‑linear constraints involving several 32‑bit multiplications, a division, and numerous linear bounds on vehicle speeds, positions and timing parameters.  The problem therefore belongs to the industrial verification family and is challenging because it mixes non‑linear arithmetic with a deep term structure (depth 22) and an existential quantifier over bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node289727.smt2",
    "description": "This instance is an industrial verification benchmark derived from the KeYmaera hybrid‑system proof “intersection‑example‑simple” (safe intersection of vehicular trajectories). After translating the original nonlinear real arithmetic safety condition into 32‑bit bit‑vectors, the formula asserts that **no** values of a time variable can satisfy a conjunction of positivity, bound, and relational constraints on velocities, positions and parameters (including non‑linear multiplications and a division). The problem features a single quantified (existential) sub‑formula, a moderate term depth (21) and a handful of bit‑vector operations, making it a typical non‑linear arithmetic‑to‑BV verification challenge.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node174997.smt2",
    "description": "This instance encodes a verification condition from the KeYmaera hybrid‑system verifier (a safety proof for a vehicular intersection), translated into 32‑bit bit‑vector arithmetic with non‑linear operations (multiplication and division). The single asserted formula is the negation of an existential query over a time variable, demanding that a conjunction of bounds on velocities, positions, and parameters (all expressed with signed inequalities, equalities and arithmetic) never leads to a violation of the safety invariant. The problem features a moderate quantifier depth (one ∃) and a relatively deep term structure (depth 20) with many intertwined BV constraints, making it a challenging industrial‑style safety‑verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node403505.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems tool (the “intersection‑example”).  The original real‑valued VC, which checks that certain position and velocity variables stay within bounds and that a timing variable remains non‑negative, has been translated into 32‑bit bit‑vector arithmetic with non‑linear multiplications (e.g., A·t and (‑B)·t).  The solver must decide the negated existential formula that combines linear order constraints, positivity bounds and a single existential quantifier, making the instance a non‑linear BV verification problem of moderate size (18 constants, depth ≈20).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/bouncing-ball-simple-node5980.smt2",
    "description": "This instance encodes a safety verification condition for the “bouncing‑ball” hybrid‑system benchmark (Keymaera), translated from nonlinear real arithmetic into 32‑bit bit‑vectors. It asserts the negation of an existential property that requires a time variable to satisfy a set of quadratic inequalities together with several linear bounds on the system’s parameters, then checks whether the formula is unsatisfiable. The problem features a single quantified variable, non‑linear (quadratic) BV arithmetic, and a moderate term depth, making it a typical industrial‑style verification query arising from the Keymaera family.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node392295.smt2",
    "description": "This instance encodes a safety‐verification condition from the KeYmaera hybrid‑system benchmark suite (the “intersection‑example‑simple” proof).  After translating the original nonlinear real arithmetic model into 32‑bit bit‑vectors, the formula asserts the negation of an existential statement about a time stamp, together with a conjunction of arithmetic inequalities that involve quadratic terms (v₁·v₁, v₂·v₂), divisions, and bounds on positions and velocities.  The problem is therefore a BV‑based non‑linear arithmetic verification task with a single quantified block, a moderate number of variables (19) but relatively deep terms (depth 19) and mixed signed‑comparison operators, which makes it challenging for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node166425.smt2",
    "description": "This benchmark encodes a safety verification condition for the “intersection‑example” hybrid system from the KeYmaera tool‑chain (see Platzer et al., 2009). After translation to 32‑bit bit‑vectors it asserts, under a single existential time variable, a conjunction of linear bounds on positions, velocities and a safety margin together with non‑linear arithmetic (multiplication of velocities, division by a constant) and checks that the derived intermediate expressions stay within the prescribed limits. The problem is a bit‑vector instance with one quantifier, 18 variables, moderate term depth (21) and non‑linear operations, making it a typical industrial verification task that stresses solvers’ handling of quantified non‑linear BV arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/bouncing-ball-simple-node5963.smt2",
    "description": "This benchmark encodes a verification condition from the KeYmaera “bouncing‑ball‑simple” example (node 5963) as a 32‑bit bit‑vector formula. The single assertion checks, via a negated existential over a time variable, that the ball’s height, velocity and related quadratic expressions remain non‑negative and satisfy the physics‑derived relations (involving products such as t·t and t·v). The instance features non‑linear arithmetic on bit‑vectors, a handful of variables, moderate term depth (19), and is intended to assess BV solvers’ ability to handle overflow‑sensitive, quantified, non‑linear constraints in an industrial verification setting.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/vsl.proof-node2228.smt2",
    "description": "This instance encodes a verification condition taken from the KeYmaera hybrid‑systems prover (node 2228 of the vsl.proof benchmark). After being translated into 32‑bit bit‑vectors, it asserts the negation of an existential statement over a time variable and contains a dense conjunction of non‑linear arithmetic constraints (multiplications, squares, divisions) relating parameters such as A, B, ep and several state variables. The problem is therefore a non‑linear BV verification task with a single quantifier alternation, deep term nesting (depth ≈ 19) and ten declared constants, making it a challenging industrial‑style benchmark for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node361630.smt2",
    "description": "This benchmark encodes a safety verification condition from the Keymaera hybrid‑systems prover (the “intersection‑example‑simple” proof). The formula asserts—via a single existentially‑quantified time variable—that a set of 32‑bit variables obey non‑negative range bounds, linear bounds on a time interval, and non‑linear constraints involving quadratic terms (e.g., v₁·v₁ and v₂·v₂) and integer division. The instance is thus a non‑linear arithmetic verification problem translated to bit‑vector arithmetic, featuring moderate term depth (21) and a handful of quantified and let‑bound sub‑expressions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node267053.smt2",
    "description": "This benchmark encodes a verification condition extracted from the KeYmaera hybrid‑system proof “Safe intersections”. After being translated to 32‑bit bit‑vectors, the formula asserts that for any non‑negative time instant `ts1240uscore0` the system’s state variables satisfy a collection of linear and non‑linear (multiplication, division) constraints—e.g., non‑negative bounds on velocities, accelerations, and a safety inequality involving `B`, `v2` and `x` variables. The SMT problem therefore checks the validity of a single existentially‑quantified safety property (no quantifier alternation), and its difficulty stems mainly from the mixed arithmetic (multiplication/division) over bit‑vectors rather than from large numbers of variables or deep quantifier nesting.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node272436.smt2",
    "description": "This benchmark encodes a verification condition extracted from the KeYmaera hybrid‑system proof “intersection‑example‑simple” (a safety proof for vehicle intersections). The goal is to show, via a single existentially‑quantified time variable, that a collection of 32‑bit bit‑vector variables satisfy a web of linear inequality bounds together with a non‑linear arithmetic fragment (a product v₂·v₂ and a division by 2·B) that models the continuous dynamics of the system. The instance is an industrial‑style BV problem with moderate size (19 constants, depth‑19 terms) and a single quantifier alternation, making it a challenging but typical non‑linear arithmetic verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node254296.smt2",
    "description": "This benchmark encodes a verification condition from the KeYmaera hybrid‑systems proof “Safe intersections” (node 254296 of *intersection‑example‑simple*). It is presented in the BV logic as a single quantified assertion that must be unsatisfiable; the formula mixes many order‑relations on 32‑bit vectors with non‑linear arithmetic (multiplications of variables such as A·ts, B·ts, and v₂·v₂) and a single existential quantifier over a time variable. The instance therefore represents an industrial safety‑property check for a hybrid system, notable for its combination of bit‑vector non‑linear constraints and moderate term depth (20) within a relatively compact formula.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node287914.smt2",
    "description": "This benchmark encodes a verification condition from the KeYmaera hybrid‑systems verifier for the “safe intersection” example. After translating the original real‑valued nonlinear arithmetic into 32‑bit bit‑vectors, the formula checks that a set of non‑negative variables (representing positions, velocities, timing parameters, etc.) satisfy a collection of linear and non‑linear inequalities (including multiplications and a division) and that a certain safety predicate holds for all reachable states. The problem features a single existential quantifier, several nested Boolean conjuncts, and moderate term depth, making it a representative industrial BV instance with non‑linear arithmetic structure.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node601561.smt2",
    "description": "This instance encodes a safety verification condition from the KeYmaera hybrid‑systems benchmark “safe intersection”, translated into 32‑bit bit‑vector arithmetic. It asserts the negation of an existential statement over a time variable, combining non‑linear operations (multiplication, division) with numerous linear constraints that enforce non‑negativity, bounds, and relationships among variables modelling positions, velocities and constants of the intersection scenario. The problem is a single‑quantifier BV formula with moderate term depth (20) and a mix of arithmetic and ordering operators, making it a representative industrial benchmark for solving non‑linear bit‑vector verification tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node348040.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system verifier (the “intersection‑example” proof) as a quantifier‑free bit‑vector problem in the BV logic. The formula asserts that, under a set of non‑linear arithmetic constraints (quadratic terms v₁·v₁, v₂·v₂, divisions, and several positivity and bound conditions on speeds, distances, and timing variables), there exists a time stamp that would violate the safety invariant; the outer `not` tests that no such witness exists. The instance features one existential quantifier, deep nested let‑bindings, and a mixture of multiplications, divisions and signed comparisons, yielding a relatively high term depth (20) and making it a challenging industrial verification case for non‑linear BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node389810.smt2",
    "description": "This benchmark encodes a safety verification condition for the “intersection‑example” hybrid system used in the KeYmaera theorem prover (as cited in the Loos‑Platzer “Safe intersections” paper). The formula is a single quantified assertion over a 32‑bit time variable, asserting that a collection of non‑negative, bounded variables (including positions, velocities and parameters) satisfy a set of nonlinear arithmetic constraints (quadratic terms and divisions) that have been bit‑vector‑ized. It represents an industrial‑style verification problem with one existential quantifier, many linear and nonlinear BV inequalities, and moderate term depth, making it a typical non‑linear arithmetic‑to‑BV challenge for SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node193953.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems verifier (the “intersection‑example” from the safe‑intersection case study).  The property is expressed as a single quantified formula over 32‑bit bit‑vectors that combines linear bounds with non‑linear arithmetic (multiplication and a signed division) and several relational constraints on variables representing positions, velocities and timing parameters.  The task is to show the formula is unsatisfiable (i.e., no counterexample exists); the presence of one existential quantifier, deep term nesting (depth 21) and mixed non‑linear BV arithmetic makes it a challenging industrial verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node349276.smt2",
    "description": "This benchmark encodes a safety verification condition for a hybrid‑systems traffic‑intersection model (Keymaera “intersection‑example‑simple”) that has been translated into 32‑bit bit‑vector arithmetic. The sole assertion is a negated ∃‑quantifier over a time variable that must satisfy a conjunction of non‑linear constraints involving multiplications, divisions, and several linear bounds on positions, velocities, and control parameters; the formula checks that no reachable state violates the safety inequality. The problem features a single quantified block, a moderate number of variables (≈20), deep terms (depth 21), and mixed arithmetic, making it a challenging non‑linear BV verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node292487.smt2",
    "description": "This benchmark encodes a safety verification condition from the Keymaera proof of a simple traffic‑intersection hybrid system. It asserts, via a negated existential over a time variable, that no 32‑bit bit‑vector assignment can violate a collection of linear and non‑linear inequalities linking positions, velocities, accelerations, and safety bounds (including a quadratic term v₂²/(2·B)). The formula involves multiplication, division and several nested arithmetic constraints, giving a moderate term depth (≈20) and a single quantifier alternation, which together make the instance a challenging non‑linear BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node559637.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system verifier (the “intersection‑example” from the safe‑intersection case study). After being translated to 32‑bit bit‑vectors, the goal is to show that the conjunction of non‑linear arithmetic constraints (involving multiplications, a division, and numerous ordering relations) cannot be satisfied for any choice of the existential time variable, i.e., the VC is unsatisfiable. The instance features a single quantified block, 19 bit‑vector constants, deep nested Boolean structure (term depth 22) and a mix of linear and non‑linear BV arithmetic, reflecting the industrial‑scale difficulty of proving hybrid‑system safety properties.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node93152.smt2",
    "description": "The file encodes a safety verification condition from the KeYmaera hybrid‑systems tool (the “intersection‑example” case). It asserts, via a single existential quantifier over a time variable, that no 32‑bit assignment can satisfy a conjunction of linear and non‑linear (multiplicative) bit‑vector inequalities that relate positions, velocities, and safety bounds—i.e., it checks that a safety invariant holds for the intersection scenario. The benchmark involves mixed inequalities, a few multiplications, and a quantifier, giving a moderate‑size non‑linear BV problem typical of industrial verification workloads.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node150970.smt2",
    "description": "This instance encodes a safety verification condition from the KeYmaera hybrid‑system verifier (the “intersection‑example‑simple” proof), translated into 32‑bit bit‑vector arithmetic. It asserts, via a negated existential, that no reachable state violates a set of non‑linear constraints involving multiplication, division and signed inequalities over variables such as positions, velocities and timing parameters; the goal is to prove the formula unsatisfiable (i.e., the safety property holds). The problem features a single quantified variable, deep (depth 20) non‑linear term structure, and a dense conjunctive core (18 ∧‑clauses), making it a challenging bit‑vector instance with arithmetic‑heavy reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node54847.smt2",
    "description": "This benchmark encodes a safety‑verification condition from the KeYmaera hybrid‑system proof “intersection‑example‑onelane”, translated into 32‑bit bit‑vector arithmetic. The sole assertion states that no value of the time variable can satisfy a conjunction of linear and non‑linear constraints (including multiplications, a division, and several interval bounds) together with the system’s dynamics, i.e., it checks the unsatisfiability of an existential counterexample. The problem features a single quantified variable, nested let‑bindings, and non‑linear bit‑vector arithmetic, making it a moderately sized but challenging instance for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node190266.smt2",
    "description": "This instance is a verification condition generated by the Keymaera hybrid‑system prover for a “safe intersection” example, translated into 32‑bit bit‑vector arithmetic.  It asserts the negation of a safety property using a single existentially‑quantified time variable together with a mixture of linear and non‑linear (multiplication) BV constraints such as \\`A·ts + v1\\` and quadratic terms like \\`v1·v1 / (2·B)\\`.  The formula contains about twenty variables, a nesting depth of 21, and many conjunctive inequalities, making it a typical industrial‑style non‑linear BV verification problem that challenges solvers with quantifiers and arithmetic over bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node673414.smt2",
    "description": "This instance encodes a safety‑verification condition from the KeYmaera hybrid‑systems benchmark “intersection‑example‑simple”, translated into 32‑bit bit‑vector arithmetic. It asserts that no assignment to the time variable can violate a set of non‑linear constraints (quadratic terms, divisions and several inequalities) that model vehicle positions, velocities and timing bounds, and thus checks a safety invariant for a road‑intersection scenario. The problem features a single quantified existential, deep (≈21) term nesting, and extensive use of BV multiplication/division, making it a challenging non‑linear arithmetic verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node551029.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system proof of a vehicle‑intersection scenario.  The single quantified assertion checks that, for all admissible time steps, a set of bounds on velocities, positions and a safety margin (expressed with non‑linear bit‑vector arithmetic: multiplication, division and subtraction) are maintained, while also enforcing positivity and range constraints on the parameters.  The problem features an existential quantifier, nested conjunctions, and deep terms (depth ≈ 20), making it a challenging industrial BV verification instance with significant non‑linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node704546.smt2",
    "description": "The instance is a verification condition extracted from the KeYmaera hybrid‑system proof “intersection‑example‑simple”, checking a safety‑invariant for a traffic‑intersection scenario. After translation to 32‑bit bit‑vectors it encodes a non‑linear arithmetic property (quadratic term v₁·v₁, multiplication by constants, and a signed division) together with a single existentially‑quantified time variable, all wrapped in a large conjunction of ordering and positivity constraints. The solver must refute the existential witness (i.e., prove the VC unsatisfiable), which is challenging because of the non‑linear BV arithmetic, the quantifier, and the relatively deep term structure (depth ≈ 20) despite the modest number of variables (19).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node682293.smt2",
    "description": "This instance encodes a safety‑verification condition for the “safe intersection” hybrid‑system example from the Keymaera tool suite. After translating the original real‑valued non‑linear arithmetic proof into 32‑bit bit‑vector arithmetic, it asserts (under a negated existential over a time variable) that a set of linear and non‑linear (multiplication) constraints on positions, velocities, and parameters (all bounded and non‑negative) cannot be simultaneously satisfied; a SAT answer would indicate a reachable unsafe state. The benchmark features a single quantified block, deep term nesting (depth ≈ 20) and several bit‑vector multiplications, making it a moderately challenging industrial verification problem in the BV logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node251841.smt2",
    "description": "This benchmark encodes a safety verification condition for the “intersection‑example” hybrid system from the KeYmaera proof suite. After translating the original real‑valued dynamics into 32‑bit bit‑vectors, the formula asserts that, for any non‑negative time step ts, the evolved positions and velocities (involving non‑linear multiplications and a division) stay within prescribed bounds and never breach the intersection safety limits. The instance features a single existential quantifier, about twenty bit‑vector variables, non‑linear arithmetic (multiplication/division) and a moderate term depth (21), making it a typical industrial verification‑condition problem for SMT solvers handling BV‑encoded hybrid‑system safety.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node17882.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system proof “intersection‑example‑onelane” as a 32‑bit bit‑vector formula. The query asserts the negation of an existential time variable that would satisfy a conjunction of linear and non‑linear arithmetic constraints (multiplication, division, and ordering) modeling vehicle positions, velocities, and timing bounds, thereby checking that no unsafe state is reachable. The instance is industrial‑scale, featuring 13 BV variables, nested let‑bindings, and a moderate term depth (24), with a single quantified sub‑formula that makes the problem challenging for BV solvers handling non‑linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node39751.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system model of a one‑lane traffic intersection. After translating the original real‑valued proof obligations to 32‑bit bit‑vectors, the formula asserts (via a negated existential) that a complex nonlinear invariant—mixing additions, multiplications and signed divisions on several bounded variables—cannot be violated. The instance features a single quantified block, 13 bit‑vector constants, deep nested arithmetic terms (depth 24) and thus serves as a challenging industrial BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node349694.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system prover (the “intersection‑example” about a traffic crossing) as a quantified non‑linear bit‑vector problem.  The formula asserts the negation of an existential witness for a time‑step variable that would break a set of arithmetic inequalities involving quadratic terms (multiplications of velocity variables) and division, together with numerous non‑negative and ordering constraints on the system’s parameters.  The instance is industrial‑style, uses a single quantifier over a 32‑bit word, features non‑linear BV arithmetic, and has a relatively deep term structure (depth 21) with about twenty constants, making it a challenging case for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node294860.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system prover (the “intersection‑example‑simple” case) as a 32‑bit bit‑vector formula. The goal is to show that no assignment to the existential time variable can satisfy a conjunction of linear and non‑linear constraints—bounds on positions, velocities, and parameters, together with multiplications and a division—while respecting positivity and ordering requirements. The instance contains a single quantified block, a let‑binding, and a moderate term depth (18) with several non‑linear BV operations, making it a challenging BV‑non‑linear arithmetic verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node532235.smt2",
    "description": "This benchmark encodes a verification condition from the KeYmaera hybrid‑system verifier (the “safe‑intersection” example).  It asks whether there exists a time‑step ts satisfying a collection of safety constraints—non‑negativity of positions, velocities and parameters, bounds such as B > 0, V > 0, relational conditions like xI₁ > x₁ + v₁²/(2·B) and a linear inequality −B·ts + v₁₀ ∈ [0,V]—together with interval limits on ts and an upper bound ep.  The problem is a non‑linear arithmetic VC translated to 32‑bit bitvectors, featuring one existential quantifier, multiplication, division, and a moderate term depth, making it a typical industrial verification challenge for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node673526.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems prover (the “intersection‑example‑simple” proof node) as a quantifier‑free bit‑vector formula.  The single existential quantifier ranges over a time‑step variable and the body consists of a cascade of non‑linear arithmetic constraints (multiplications, divisions, and signed comparisons) that enforce non‑negative velocities, bounded speeds, positive parameters, and that a derived position exceeds a safety margin.  The instance originates from an industrial‑style verification suite, uses 20 32‑bit variables, features moderate term depth (≈21) and a mixture of linear and non‑linear BV operations, making it a challenging case for solvers handling quantified non‑linear bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node367444.smt2",
    "description": "The benchmark encodes a safety‑verification condition for a hybrid‑system model of a road‑intersection (a Keymaera example) that has been translated into 32‑bit bit‑vector arithmetic. It asserts the negation of an existential statement over a time variable, requiring that no assignment can satisfy a conjunction of numerous linear and non‑linear (multiplication, division) inequalities relating velocities, positions, and safety limits; thus the solver must prove the formula unsatisfiable. The instance features a single quantified block, 18 bit‑vector constants, deep nested terms (depth 21) and a mix of arithmetic and relational constraints, making it a non‑linear BV verification benchmark from the industrial “Preiner‑keymaera” family.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/to_left-node1505.smt2",
    "description": "This instance encodes a verification condition from the KeYmaera train‑control case study, translated into 32‑bit bit‑vector arithmetic. It asserts the negation of an existential formula that mixes several non‑linear multiplications, divisions and linear inequalities over the variables, essentially checking whether a safety inequality holds for all admissible values. The problem involves a single quantifier block but heavy non‑linear BV reasoning, making it a challenging industrial benchmark for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/binary_driver-2007-10-09-node14896.smt2",
    "description": "This benchmark encodes a verification condition from the KeYmaera hybrid‑systems tool (the “binary_driver” example) that has been translated into 32‑bit bit‑vector arithmetic. The formula asserts the negation of an existentially quantified condition over a time‑step variable together with numerous non‑linear constraints (products of variables, quadratic terms, and mixed additions/subtractions) and several ordering predicates (≤, ≥, >) on the variables. The presence of a single quantifier, many bit‑vector multiplications, a deep term nesting (depth 21) and fifteen declared constants makes the instance a challenging industrial‑style non‑linear BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node11162.smt2",
    "description": "This instance encodes a safety‑verification condition for a hybrid‑systems model of a one‑lane traffic intersection (the “intersection‑example‑onelane” proof node from the KeYmaera benchmark suite). After translating the original real‑valued dynamics into 32‑bit bit‑vectors, the formula asserts that there exists a time instant ts23 satisfying a collection of linear and non‑linear constraints (including multiplications, a division by 2, and quadratic terms) together with bounds on velocities, positions and system parameters. The outer “not … exists” turns the verification condition into a SAT query: the solver must show the negated existential formula is unsatisfiable, i.e., that no reachable state violates the safety property. The problem features a single quantified block, deep term nesting (depth 23) and several non‑linear BV operations, making it a challenging industrial‑style BV verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node194936.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system prover (the “intersection‑example‑simple” proof node) as a single quantified bit‑vector formula.  The assertion states that, under a collection of linear and non‑linear constraints on 32‑bit variables representing positions, velocities, and timing parameters of two intersecting vehicles, a certain safety property (e.g., no collision) must hold; the formula is negated and wrapped in an existential quantifier over a time variable, turning the verification problem into checking unsatisfiability.  The instance is industrial‑grade, features non‑linear multiplication/division on bit‑vectors, a moderate number of constants (19), a deep term nesting (depth 21), and a single quantifier, making it a challenging case for BV solvers handling quantified, non‑linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node190475.smt2",
    "description": "The benchmark encodes a safety verification condition from the KeYmaera hybrid‑system tool (the “intersection‑example” case study), translated into 32‑bit bit‑vectors. It asserts, via a single existential quantifier over a time variable, that a conjunction of non‑linear arithmetic constraints (involving additions, multiplications, a division, and numerous ordering and positivity bounds on positions, velocities, and constants) cannot be satisfied; the outer `not (exists …)` therefore checks the unsatisfiability of that guarded conjunction. The problem features moderate size (19 bit‑vector constants), a term depth of 20, and a mixture of linear and non‑linear BV operations, typical of industrial verification instances.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/vsli-alert.proof-node2442.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system prover (the “vsli‑alert” example) as a quantifier‑free bit‑vector formula with a single existentially‑quantified time variable. The asserted condition is the negation of the VC, i.e., it asks whether there exists a 32‑bit assignment that violates the intended safety (the “alerted” flag being non‑zero) while respecting a rich set of non‑linear arithmetic constraints (squares, products, divisions, and several linear inequalities). The instance features deep (depth ≈ 26) non‑linear BV terms, 14 declared 32‑bit constants, and many arithmetic operations, making it a challenging industrial‑style verification problem for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node172682.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems verifier (the “intersection‑example‑simple” proof node) that has been translated into 32‑bit bit‑vector arithmetic.  The single, quantified assertion checks that, under a collection of non‑negative bounds on variables and parameters, a non‑linear inequality involving multiplications and a signed division never violates the safety property; it combines many linear and non‑linear BV constraints (e.g., bvadd, bvmul, bvsdiv) together with a single existential quantifier over a time variable.  The problem is moderate in size (≈2800 nodes, depth 20) but is challenging because it mixes quantification with non‑linear bit‑vector arithmetic typical of industrial hybrid‑system verification tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node37008.smt2",
    "description": "This benchmark is a verification condition extracted from the KeYmaera hybrid‑system verifier (the “intersection‑example‑onelane” proof node) and translated into 32‑bit bit‑vector arithmetic. It asserts that no assignment to a time variable can violate a safety inequality that involves non‑linear operations (a product v·v, a division by 2·B, and several linear bounds on positions, velocities and timers) together with a handful of range and positivity constraints. The formula contains a single existential quantifier, a deep conjunction of bit‑vector comparisons, and non‑linear arithmetic, making it a challenging BV instance despite its modest size (13 constants, term depth 23).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node269426.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems tool (the “intersection‑example” from a safe‑intersection proof) as a single quantified bit‑vector formula over 32‑bit words. The model contains 19 variables and combines non‑linear arithmetic (multiplication and division) with a rich set of linear inequalities, and the query asks whether there exists a time instant satisfying all constraints – the outer negation turns the problem into proving unsatisfiability. Consequently, the instance is an industrial‑style BV verification problem that stresses solvers with mixed non‑linear arithmetic, deep term nesting (depth 21), and a quantified existential.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node270758.smt2",
    "description": "This instance encodes a verification condition from the KeYmaera hybrid‑system safety benchmark (a simple traffic‑intersection example) as a 32‑bit bit‑vector problem with non‑linear arithmetic (multiplications and a division) and a single existential quantifier.  The formula asserts that, under a collection of bounds on positions, velocities, and system parameters, a safety inequality (essentially a braking‑distance constraint) cannot be violated; the outer `not` makes the check a proof‑obligation for unsatisfiability.  The benchmark features moderate size (18 constants, term depth 20) but non‑linear bit‑vector operations and a quantifier, which together make it a challenging industrial verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node254500.smt2",
    "description": "The benchmark encodes a safety verification condition for the “intersection‑example” hybrid system from the KeYmaera proof suite. After translating the original real‑valued dynamics into 32‑bit bit‑vectors, the formula asserts that there exists a time‑step `ts1183uscore0` satisfying a conjunction of non‑negativity, bound, and arithmetic constraints (including non‑linear multiplications and a division) that would violate the intended invariant; the outer negation therefore checks that no such witness exists. The problem features a single existential quantifier, about two dozen bit‑vector variables, and moderate term depth (≈20), making it a typical industrial verification instance with non‑linear arithmetic encoded in the BV logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node488451.smt2",
    "description": "This instance encodes a safety verification condition for a hybrid‑system “intersection” model (originating from the KeYmaera proof “intersection‑example‑simple”), translated from real arithmetic into 32‑bit bit‑vectors. The single (negated) existential formula asserts that, under a collection of linear and non‑linear bounds on positions, velocities, and parameters (including products and a division), a reachable state violating the safety interval cannot exist; thus the solver must prove the formula unsatisfiable. The problem features one quantifier, several non‑linear bit‑vector operations, and a moderate term depth (≈20) with 19 declared constants, making it a typical industrial verification benchmark that stresses BV handling of mixed arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node531822.smt2",
    "description": "The instance encodes a safety verification condition arising from the KeYmaera hybrid‑systems benchmark “intersection‑example‑simple”. After translating the original real‑valued dynamics into 32‑bit bit‑vectors, the formula checks that, for all admissible parameter values (non‑negative bounds, quadratic term v₁·v₁, division by B, etc.), there is **no** time ts satisfying a set of linear and non‑linear arithmetic constraints; this is expressed as a single negated existential quantifier. The problem therefore challenges a BV solver with non‑linear multiplication, a division, several layered inequalities and a moderate quantifier depth (max term depth 20, 19 declared constants).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node603436.smt2",
    "description": "This benchmark is a verification condition extracted from the KeYmaera hybrid‑system prover (the “safe‑intersection” example) and translated into 32‑bit bit‑vector arithmetic. The formula asserts the negation of an existential witness for a time variable, requiring a conjunction of linear and non‑linear (multiplication, division) BV constraints together with several ordering and range checks. It is a single‑query, industrial‑style VC that tests solvers on mixed arithmetic, deep term nesting (depth ≈ 20) and a modest number of variables (≈ 20).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node46589.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems tool, modelling a one‑lane traffic‑intersection scenario (the “intersection‑example‑onelane” proof). The property is expressed as a single quantified (∃) bit‑vector formula over 32‑bit variables, involving numerous non‑linear arithmetic constraints (multiplication, division, and quadratic terms) that relate velocities, positions, and timing bounds; the whole condition is negated, so the solver must prove unsatisfiability. The instance is industrial‑scale, with a deep term nesting (depth 26) and a mix of arithmetic and ordering relations, making it a challenging case for BV solvers that handle non‑linear arithmetic and quantifiers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node732160.smt2",
    "description": "This instance is a safety‑verification condition extracted from the KeYmaera hybrid‑systems tool (the “intersection‑example” proof). It checks, by negating an existential quantifier, that no 32‑bit time‑step value can satisfy a set of non‑linear arithmetic constraints—squared velocities, products with parameters, and division—together with numerous bounds on positions, velocities and constants that model a vehicle‑intersection scenario. The problem therefore consists of a single, deep (term depth 21) quantified bit‑vector formula with 18 variables, mixing multiplication, division and relational operators, making it a challenging non‑linear BV verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node171004.smt2",
    "description": "This benchmark encodes a safety verification condition from the Keymaera hybrid‑system verifier (the “intersection‑example” proof node). The formula, expressed in 32‑bit bit‑vector arithmetic, contains a single existential quantifier and a mixture of linear and non‑linear constraints (multiplications, divisions, and several signed‑inequality checks) that model the dynamics of two interacting vehicles and timing variables. The goal is to show that the negated existential property is unsatisfiable, i.e., that the safety condition holds for all reachable states.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node345732.smt2",
    "description": "This instance is a verification condition extracted from the KeYmaera proof of a “safe‑intersection” hybrid‑system example (the paper *Safe intersections*). After being translated to 32‑bit bit‑vectors, the formula asserts that, for a (existentially‑quantified) time stamp, a collection of non‑linear arithmetic constraints (multiplications, a division, and several signed orderings) involving vehicle positions, velocities, and system parameters satisfy the safety inequalities prescribed by the original hybrid‑system model. The problem is a single‑quantifier BV formula with moderate size (19 constants, depth 20) but contains non‑linear bit‑vector operations, making it a challenging industrial verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node54859.smt2",
    "description": "This instance encodes a safety‑verification condition from the KeYmaera hybrid‑systems tool (the “intersection‑example‑onelane” proof). The formula is the negated existence of a time variable satisfying a collection of nonlinear 32‑bit bit‑vector constraints that model vehicle dynamics, bounds on positions and velocities, and timing requirements; it therefore checks that a reachable‑state scenario violating the safety invariant cannot occur. The problem is industrial‑scale, features a single existential quantifier, deep (≈23) term nesting, and many non‑linear operations (multiplication, division) on bit‑vectors, making it a challenging benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node363688.smt2",
    "description": "This benchmark is a safety‑verification condition translated from a KeYmaera hybrid‑system proof (the “intersection‑example‑simple” case). It asserts the negation of an existential counterexample over 32‑bit bit‑vectors, encoding a mixture of linear and non‑linear arithmetic (multiplications, a division, and several signed inequality constraints) that capture relationships among velocities, positions and time bounds. The single quantified formula involves 18 variables, deep term nesting (depth 21) and non‑linear BV operations, making it a challenging industrial‑style BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/ETCS-essentials-node3023.smt2",
    "description": "This benchmark is a verification condition extracted from the KeYmaera hybrid‑system verifier (the “ETCS‑essentials” model, node 3023) and translated into 32‑bit bit‑vector arithmetic. It asks whether there exists a time‑like variable that can satisfy a large conjunction of linear and quadratic inequalities, involving many multiplications, divisions, and sign constraints on several parameters; the outer `not` turns the problem into checking the unsatisfiability of that existential formula. The instance is an industrial‑style non‑linear BV problem, characterized by a single quantified block, deep nested terms (depth 17) and a high count of `bvmul`/`bvsdiv` operations, which together make it a demanding case for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node265077.smt2",
    "description": "This benchmark is a safety verification condition extracted from the KeYmaera hybrid‑system verifier (the “intersection‑example” proof node).  The original real‑valued constraints about vehicle positions, velocities and timing have been translated into 32‑bit bit‑vector arithmetic, yielding a single quantified formula that mixes many linear inequalities with non‑linear operations (multiplication, a signed division and negation).  The solver must show the negated existential clause is unsatisfiable, i.e., that under the non‑negative bounds on all variables and the given relational constraints no counter‑example exists.  The instance features a deep term structure (depth 20), one quantifier and a dense conjunction of BV comparisons, making it a non‑linear BV verification problem of industrial difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node269538.smt2",
    "description": "This instance is a 32‑bit bit‑vector encoding of a safety verification condition from the KeYmaera hybrid‑system verifier (the “intersection‑example” case study). It asserts that, under a collection of non‑negative bounds and linear relationships between the variables (including a non‑linear term bvmul v2 v2), there is **no** choice of the existential time variable that violates the invariant, i.e., the formula checks unsatisfiability of a quantified safety condition. The benchmark therefore tests BV solvers on a modest‑size (≈20 constants) non‑linear arithmetic verification problem drawn from an industrial hybrid‑systems application.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node251490.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system verifier (the “intersection‑example” proof node), translated into 32‑bit bit‑vector arithmetic. The formula asserts that no assignment to the time variable ts1169 can satisfy a large conjunction of linear and non‑linear (multiplicative) constraints involving positions, velocities, and timing bounds, and the solver is asked to prove unsatisfiability (i.e., the safety property holds). It features a single existential quantifier, mixed signed comparisons, a non‑linear multiplication term, and a relatively deep term structure (depth 21), making it a challenging non‑linear BV verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node476763.smt2",
    "description": "This benchmark encodes a safety verification condition from the Keymaera hybrid‑system verifier (the “intersection‑example” for safe traffic intersections). After being translated from real‑valued non‑linear arithmetic, the VC appears as a single quantified formula over 32‑bit signed bit‑vectors, featuring linear and non‑linear constraints (addition, multiplication, division, and comparisons) that express bounds on velocities, positions and timing parameters of two intersecting objects. The instance is industrial‑style, with one existential quantifier, 19 bit‑vector variables, a moderate term depth (22) and a dense conjunction of arithmetic predicates, making it a challenging non‑linear BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node267578.smt2",
    "description": "This instance is a safety‑verification condition extracted from the KeYmaera hybrid‑systems tool (the “intersection‑example‑simple” benchmark) and translated into 32‑bit bit‑vector arithmetic. It asserts that no assignment to the quantified time variable can violate a set of signed arithmetic constraints involving non‑linear operations (multiplication, division), range bounds, and relational conditions on several vehicle‑state variables, together with a few auxiliary equalities. The problem features a single existential quantifier, a moderate number of constants (18), deep nesting (term depth 20) and a mix of linear and non‑linear BV constraints, making it a typical industrial‑style non‑linear arithmetic verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node189817.smt2",
    "description": "This instance encodes a safety verification condition from the KeYmaera hybrid‑system prover (the “intersection‑example” in the safe‑intersection case study).  The property is expressed as a single quantified formula over 32‑bit bit‑vectors that combines linear constraints with non‑linear arithmetic (multiplication of variables and a division), and it is asserted in negated‑existential form to check that no violating time stamp exists.  The problem belongs to the industrial verification family, features a moderate size (18 constants, depth 20) but is challenging because of the combination of a quantifier, bit‑vector non‑linear operations, and several interdependent range constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node167638.smt2",
    "description": "The benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems prover (the “safe‑intersection” example) as a quantifier‑free bit‑vector formula. It checks that, under non‑negative bounds on two velocities, positions and a time horizon, no reachable state violates the invariant expressed by a series of linear and non‑linear (multiplication, division) arithmetic constraints; the property is asserted as the negation of an existential witness, so the instance is unsatisfiable if the safety proof holds. The problem originates from the industrial‑style Keymaera benchmark suite, features 19 32‑bit variables, moderate term depth (≈20) and a mixture of arithmetic relations that make the BV encoding of the original non‑linear arithmetic challenging for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node288026.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system prover (the “intersection‑example‑simple” proof node) as a single quantified bit‑vector formula. It asserts that, for all admissible initial states and parameters bounded by a non‑negative constant V, the computed continuous‑time updates (involving non‑linear operations such as multiplication and division) stay within the prescribed bounds and respect ordering constraints on the time variables. The instance features one existential quantifier, 19 32‑bit variables, deep (≈19) term nesting, and non‑linear BV arithmetic, making it a challenging industrial verification query.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node171462.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system verifier (the “intersection‑example”), translated into 32‑bit bit‑vector arithmetic. The formula asserts the negation of an existential goal that combines non‑linear operations (multiplication and signed division), numerous linear inequalities, and several equality constraints modeling non‑negative parameters, bounds on velocities and distances, and discrete mode switches. The presence of a single quantifier, deep nested let‑expressions, and non‑linear bit‑vector terms makes the instance a challenging industrial verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node23307.smt2",
    "description": "This benchmark encodes a safety verification condition from the Keymaera hybrid‑systems tool (the “intersection‑example‑onelane” case) as a 32‑bit bit‑vector formula. The goal is to refute the existence of a time variable that satisfies a conjunction of linear bounds, non‑linear multiplications, a division, and several positivity constraints on vehicle‑related quantities (speed, position, etc.). The instance features a single existential quantifier, deep (depth 22) non‑linear arithmetic terms, and a moderate number of Boolean conjuncts, making it a representative industrial verification problem that stresses BV solvers’ handling of non‑linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node476753.smt2",
    "description": "This benchmark encodes a verification condition from the KeYmaera hybrid‑system verifier (the “safe intersection” example) as a 32‑bit bit‑vector formula.  The single quantified assertion checks that, under a collection of linear range constraints on positions, velocities, and a time parameter, a derived non‑linear expression (involving multiplication, division and a quadratic term) always stays within prescribed bounds; the outer ¬∃ turns the problem into a safety proof (unsatisfiability) rather than a search for a counterexample.  The instance features a modest number of variables (18) but combines an existential quantifier, deep term nesting (depth 20), and non‑linear arithmetic encoded in BV, making it a representative industrial verification case that is difficult for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node479629.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems prover (the “intersection‑example‑simple” proof node). The goal is to show that, under a collection of arithmetic constraints on 32‑bit bit‑vector variables representing positions, velocities, time bounds and parameters, no assignment exists that violates the required inequalities (the outer `not (exists …)` asserts the absence of a counterexample). The instance is a single quantified formula in the BV logic that mixes linear and non‑linear bit‑vector arithmetic (multiplication, division, and quadratic terms), contains 19 variables, a moderate term depth (20) and several nested relational operators, making it a representative industrial verification problem with non‑linear arithmetic encoded as bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node268901.smt2",
    "description": "This benchmark is a verification condition extracted from the KeYmaera hybrid‑system verifier for a “safe intersection” example.  The original real‑valued VC has been translated to 32‑bit bit‑vector arithmetic (including a quadratic term v₂·v₂) and wrapped in a single existential quantifier that is negated, so the solver must prove the condition holds for all admissible time steps.  The instance features a handful of non‑negative and bound constraints on positions, velocities, and timing parameters, making it a medium‑size industrial B‑V verification problem with moderate term depth and a single quantifier‑alternation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node250605.smt2",
    "description": "This instance encodes a safety verification condition for a hybrid‑systems model of a vehicle intersection (the “intersection‑example‑simple” from the KeYmaera benchmark suite).  The goal is to prove that no assignment to the time variable ts (and the associated state variables) can violate a set of mixed linear and non‑linear (multiplicative) constraints on positions, velocities, and parameters such as a safety distance B, total speed bound V, and a bound ep, all represented as 32‑bit bit‑vectors.  The formula is the negated existential of these constraints, so the SAT check confirms the original safety invariant; the problem features a moderate number of variables, deep nested arithmetic terms, and a single quantifier, making it a typical industrial non‑linear bit‑vector verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node54892.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system verifier (the “intersection‑example‑onelane” proof). The constraint is a quantified BV formula that checks, for a 32‑bit time variable, whether the hybrid dynamics (expressed with non‑linear bit‑vector arithmetic such as products and divisions) can lead to a state where the position variable violates a safety bound; the outer negation turns the check into a proof of absence of such a counterexample. The instance features 13 32‑bit variables, nonlinear multiplications (including a quadratic term) and a moderate quantifier depth, making it a non‑linear arithmetic verification problem of industrial size.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node490353.smt2",
    "description": "This benchmark encodes a safety verification condition for the “intersection‑example” hybrid system from the KeYmaera tool chain. After translating the original real‑valued dynamics into 32‑bit bit‑vectors, the formula asserts (negated) that there exists a time instant ts satisfying a collection of linear and non‑linear (multiplication/division) arithmetic constraints together with several range and ordering requirements on the system variables. The problem is therefore an industrial‑style BV verification query with a single existential quantifier, moderate size (19 variables) and relatively deep terms (depth ≈ 20), featuring non‑linear bit‑vector arithmetic that makes it challenging for standard solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node287501.smt2",
    "description": "This benchmark encodes a safety verification condition from the Keymaera hybrid‑system verifier (the “safe‑intersection” example) that was translated to 32‑bit bit‑vectors.  It asks whether there exists a time‑step value satisfying a conjunction of linear bounds (non‑negativity, upper limits V, A, B) together with a non‑linear arithmetic constraint involving a quadratic term v₂·v₂ divided by 2·B; the overall formula is the negation of an existential, so the solver must prove it unsatisfiable.  Despite a modest size (19 constants, one quantifier, term depth 20), the mix of multiplication, division and several inequality relations makes it a good test of BV solvers’ capability to handle encoded non‑linear arithmetic in an industrial verification setting.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node688713.smt2",
    "description": "This instance is a safety‑verification condition extracted from the KeYmaera hybrid‑systems benchmark “intersection‑example‑simple”, translated to 32‑bit bit‑vector arithmetic. It asserts (negated) that, under non‑negative parameters and bounds on velocities and positions, there exists a time step ts that satisfies a set of linear‑inequality constraints together with two non‑linear terms (A·ts and –B·ts) that must stay within the interval [0,V]; the formula also encodes specific integer constants for mode indices (I1, I2). The problem features a single existential quantifier, moderate term depth (≈20), and non‑linear BV multiplication, making it a compact but non‑trivial industrial verification query.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node151296.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system proof “intersection‑example‑simple” (a safe‑intersection case study). The original real‑valued VC has been translated to 32‑bit bit‑vector arithmetic, resulting in a single quantified formula whose negation is asserted; the solver must show it is unsat, i.e., that no counterexample exists. The problem features non‑linear operations (multiplication and division), many mixed signed‑inequality constraints, and a modest quantifier depth, making it a typical industrial verification instance that challenges BV solvers on non‑linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node17304.smt2",
    "description": "This instance encodes a safety verification condition from the KeYmaera hybrid‑system verifier (the “intersection‑example‑onelane” proof). The goal is to show that the negated VC is unsatisfiable: it contains one existentially‑quantified time variable together with a network of non‑linear bit‑vector constraints (multiplications, divisions, and comparisons) that model bounds on positions, velocities and timing for two vehicles at a crossing. The problem is a single‑quantifier, non‑linear BV verification task of industrial origin, featuring deep term nesting (depth 23) and several arithmetic operations, which makes it a challenging benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node20269.smt2",
    "description": "This benchmark encodes a verification condition from the KeYmaera hybrid‑systems tool (the “intersection‑example‑onelane” proof). After a translation to 32‑bit bitvectors, it asks whether there exists a time instant satisfying a conjunction of linear and non‑linear arithmetic constraints (including multiplications, a division, and several safety‑range bounds on speeds, positions and parameters) that would violate the safety invariant of a single‑lane intersection scenario. The problem is an industrial‑style BV verification task featuring a single existential quantifier, moderate variable count (13), and relatively deep, non‑linear term structure.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node368539.smt2",
    "description": "The instance is a verification condition originating from the KeYmaera hybrid‑system verifier (the “safe‑intersection” example). It checks, using 32‑bit bit‑vectors, that a set of non‑linear arithmetic constraints – involving multiplications (e.g., v₁·v₁, v₂·v₂) and a signed division – together with bounds on variables such as speeds, positions and a time‑step variable, cannot be violated. The formula is the negation of the safety property, wrapped in a single existential quantifier, so the solver must prove unsatisfiability. The benchmark is industrial‑style, modest in size (20 constants, one quantifier) but challenging because of the non‑linear BV arithmetic and the mixture of inequalities, which makes it a typical hard case for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node368193.smt2",
    "description": "This benchmark is a bit‑vector encoding of a safety verification condition taken from the Keymaera hybrid‑system prover (the “intersection‑example‑simple” case). The formula asserts, for a set of numeric parameters modelling positions, velocities, and time bounds of two vehicles, that under a number of linear‑ and non‑linear (multiplication, signed division) constraints the safety predicate cannot be violated; the SMT‑LIB file checks the negation of this predicate, using a single existential quantifier over a time variable. It therefore represents a non‑linear arithmetic verification problem with moderate size (≈ 18 bit‑vector constants, term depth 20) that challenges solvers’ handling of quantified bit‑vector arithmetic and mixed arithmetic operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node151408.smt2",
    "description": "This benchmark encodes a safety verification condition originally generated by the KeYmaera hybrid‑system verifier for a “safe intersection” scenario, translated from real arithmetic into 32‑bit bit‑vector arithmetic. The formula asserts that there **does not exist** a time value (the quantified variable) satisfying a conjunction of linear and non‑linear constraints on positions, velocities, and physical parameters (including multiplications and a division), together with numerous non‑negativity and bound conditions. As an industrial‑style BV instance it features a single existential block, 20 bit‑vector constants, moderate term depth (21) and non‑linear arithmetic, making it a representative challenge for BV solvers handling quantified, non‑linear constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node95128.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems tool (the “intersection‑example” from the safe‑intersection case study) as a 32‑bit bit‑vector formula. The goal is to show that no assignment to the existential timestamp variable can satisfy a conjunction of non‑negative bounds, ordering constraints on positions, and non‑linear arithmetic relationships (products of constants with the timestamp) while also respecting a global upper‑bound V and a positive deadline ep. It features a single existential quantifier, 18 declared bit‑vector constants, moderate term depth (19), and several nonlinear multiplications, making it a compact but non‑linear BV verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node48396.smt2",
    "description": "This instance encodes a safety verification condition from the KeYmaera hybrid‑system verifier (the “intersection‑example‑onelane” proof) that has been translated into 32‑bit bit‑vector arithmetic. The single quantified assertion checks that, under a series of positivity and bound constraints on time, position and velocity variables, a non‑linear inequality involving products and a division (e.g., \\(x_I > x + v^2/(2B)\\)) always holds; the outer `not` turns the problem into an unsatisfiability check. It features one existential quantifier, nested `let` bindings, and a moderate term depth (23) with several non‑linear BV multiplications, making it a challenging industrial‑style BV‑non‑linear verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node173665.smt2",
    "description": "This benchmark is a bit‑vector encoding of a safety verification condition from the KeYmaera hybrid‑systems prover (intersection‑example‑simple), translated by Mathias Preiner. It asks whether there exists a time stamp (`ts807uscore0`) that violates a conjunction of linear and non‑linear arithmetic constraints (including multiplications, a signed division, and several order relations) over 32‑bit signed bit‑vectors, while all system parameters (velocities, positions, constants) remain within prescribed non‑negative bounds. The instance features a single existential quantifier, deep nested Boolean structure (depth 20), and non‑linear BV arithmetic, making it a challenging industrial‑style verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node602111.smt2",
    "description": "This benchmark encodes a verification condition from the KeYmaera hybrid‑system verifier (the “safe intersection” example) as a single quantified bit‑vector formula. It asserts that no assignment to a 32‑bit time variable can satisfy a conjunction of signed inequalities involving non‑linear arithmetic (multiplication and division) over several program variables, all constrained to lie within given bounds. The problem features a single existential quantifier, moderate term depth (≈21), and a handful of 32‑bit variables, making it a representative industrial V‑C that stresses BV solvers’ handling of non‑linear arithmetic and quantified reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node30209.smt2",
    "description": "The benchmark is a verification condition extracted from the KeYmaera hybrid‑systems verifier for a “safe intersection” scenario (the one‑lane example).  It has been translated into a quantifier‑rich, non‑linear bit‑vector formula (32‑bit BV) that checks that no choice of the time variable ts can violate a series of linear and quadratic bounds on positions, velocities and safety distances; the outer‑most ¬∃ encodes the safety proof obligation.  The instance contains a single existential quantifier, moderate term depth (23), and many mixed multiplication/division constraints, making it a typical industrial‑scale BV non‑linear arithmetic verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node264195.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems prover (the “intersection‑example” proof), translated to 32‑bit bit‑vector arithmetic. It asserts that under a set of non‑negative bounds on several state variables, mode identifiers, and a non‑linear relation (involving multiplication and a division by 2·B) the safety property cannot be violated; the formula is a single‑quantifier (existential over a time variable) negated implication, whose unsatisfiability is checked. The instance features moderate term depth (21) and a mix of linear and non‑linear bit‑vector constraints, typical of industrial hybrid‑system verification problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/safety-lemma-node14050.smt2",
    "description": "This instance encodes a safety‑lemma from the KeYmaera hybrid‑system verifier as a single quantified bit‑vector formula over 15 32‑bit variables. The goal is to show that no assignment to the existential variable ts7₀ can satisfy a conjunction of non‑linear constraints involving products, squares, and divisions (e.g., bounds on b, A, ep, and quadratic relations such as (v·v – d·d) ≤ 2·b·(m−z)). The benchmark is an industrial‑style verification problem, featuring one existential quantifier, deep (≈23) nested arithmetic terms, and extensive non‑linear BV operations, which makes it a challenging case for solvers handling non‑linear bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node550289.smt2",
    "description": "This benchmark encodes a safety verification condition from the Keymaera hybrid‑system proof “intersection‑example‑simple”, translated to 32‑bit bit‑vector arithmetic. It asserts (via a negated existential) that no assignment to the quantified time variable can satisfy a collection of signed inequality constraints involving non‑linear terms (multiplication and a division) that model vehicle speeds, positions and timing parameters; essentially it checks that a potential collision state is unreachable. The instance is moderate in size (19 variables, depth 20) but features a single quantified block with many non‑linear BV operations, making it a challenging industrial verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node561425.smt2",
    "description": "This benchmark is a safety verification condition extracted from a KeYmaera proof of a simple traffic‑intersection hybrid system. After being translated to 32‑bit bit‑vectors, it asserts—under a mixture of linear ordering constraints, positivity conditions, and non‑linear arithmetic (multiplications and a division)—that no existential time value can violate the required bounds on the system’s variables; the formula uses a single existential quantifier with a let‑binding. The instance is of moderate size (19 declared constants, term depth 20) but features non‑linear BV arithmetic, making it a challenging industrial‑style verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node290206.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems tool (the “intersection‑example‑simple” proof) as a quantified bit‑vector formula.  It asserts the negation of an existential statement over a 32‑bit time variable, relating positions, velocities and parameters with non‑linear arithmetic (multiplications, a division and a negation) together with a mixture of signed comparisons and bounds.  The instance is a QF_BV problem with one existential quantifier, deep terms (depth 20) and several non‑linear operations, making it a tough industrial‑style verification case for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node45106.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems tool for a one‑lane traffic‑intersection scenario. The goal is to prove (by refutation) that there exists no time instant `ts101` satisfying a set of non‑linear arithmetic constraints that model vehicle positions, velocities, and timing limits; the constraints involve 32‑bit bit‑vector multiplications, divisions, and several signed inequality relations, together with an existential quantifier over the time variable. The instance is a translation of a real‑valued VC into the BV logic, featuring a single quantified formula, moderate term depth (24), and a small but non‑trivial mix of linear and non‑linear bit‑vector arithmetic, making it representative of industrial verification problems with non‑linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node198058.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system prover (the “safe intersection” example) as a single quantified bit‑vector formula. The goal is to show that, under a collection of bounds on velocities, positions, and a timing variable, no reachable state violates a set of non‑linear arithmetic constraints (products and a division) that model the dynamics of two vehicles at an intersection. The instance features one existential quantifier, several nested let‑bindings, and a mixture of linear and non‑linear BV operations, making it a challenging industrial verification problem for solvers that handle quantified non‑linear bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node365013.smt2",
    "description": "The file encodes a safety verification condition taken from the KeYmaera hybrid‑system verifier (the “intersection‑example‑simple” proof node). It is a quantified 32‑bit bit‑vector formula that asserts, via a single existential time variable, a conjunction of non‑linear arithmetic constraints—quadratic terms (e.g. v₁·v₁, v₂·v₂), signed division by 2·B, and numerous non‑negativity and upper‑bound relations on velocities, positions and parameters. The top‑level `not (exists … )` checks that no such violating time exists, turning the problem into a non‑linear BV satisfiability/verification task with moderate size (18 variables, term depth 20) and a single quantifier block.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/binary_driver-2007-10-09-node10280.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system prover (binary driver example) as a quantifier‑free bit‑vector problem with one existentially quantified variable. The single top‑level assertion states that no choice of the quantified time variable can make a conjunction of linear and quadratic (non‑linear) BV constraints—among them bounds, divisions, and products of several program variables—false. Consequently the solver must check the unsatisfiability of a non‑linear BV formula with moderate size (14 constants, depth ≈ 21) and a single quantifier alternation, typical of industrial verification tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node490015.smt2",
    "description": "This benchmark encodes a verification condition from the KeYmaera hybrid‑systems tool (the “safe intersection” example) as a quantifier‑rich, non‑linear bit‑vector formula. The single top‑level assertion checks that, under a collection of linear and quadratic arithmetic constraints on 32‑bit variables (including products like A·t and B·t, and divisions), no witness exists for a timestamp ts that would violate bounds on vehicle positions, velocities, and safety margins (all expressed with signed‑greater/less‑or‑equal comparisons). The problem features one existential quantifier inside a negation, deep nesting (max term depth 20) and several non‑linear multiplications, making it a challenging industrial‑style BV verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node52492.smt2",
    "description": "This benchmark is a verification condition extracted from the KeYmaera hybrid‑systems prover (the “safe‑intersection” example) and translated into 32‑bit bit‑vector arithmetic. The formula asserts the negation of an existential witness for a time variable that would violate a set of linear and non‑linear (multiplicative) safety constraints involving positions, velocities and constants, all bounded by non‑negative ranges. It therefore tests BV solvers on a quantified, non‑linear arithmetic problem originating from industrial hybrid‑system verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node12481.smt2",
    "description": "This instance encodes a safety‑verification condition from the KeYmaera hybrid‑systems benchmark “intersection‑example‑onelane”. The formula asserts the non‑existence of a time value satisfying a large conjunction of non‑linear 32‑bit bit‑vector arithmetic constraints (including multiplication, division and quadratic terms) that model relationships between positions, velocities and timing of a traffic‑intersection scenario. It features a single existential quantifier, deep term nesting (depth 24) and a mix of ordering, equality and arithmetic operations, making it a challenging quantified non‑linear bit‑vector verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node347816.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera proof of a “safe intersection” hybrid‑system example (the “intersection‑example‑simple” proof node). The condition is translated to 32‑bit bit‑vectors and contains non‑linear arithmetic (squared velocities, multiplications, signed division) together with a single existential quantifier and many signed inequality constraints, resulting in deep term nesting (depth 21). It originates from the Jovanovic‑de Moura industrial benchmark suite and is difficult because it combines quantification, non‑linear BV operations, and a relatively large set of variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node252840.smt2",
    "description": "This instance encodes a verification condition from the KeYmaera hybrid‑system verifier (the “intersection‑example‑simple” safety proof) that has been translated into 32‑bit bit‑vector arithmetic.  The formula asserts, after negating an existentially‑quantified time variable, a conjunction of linear and non‑linear BV constraints (multiplications, a division, and several signed inequalities) describing bounds on positions, velocities and parameters of the intersecting traffic model.  It tests the solver’s ability to handle a single quantified block together with non‑linear BV arithmetic in a moderately sized problem (19 constants, term depth 21).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node289202.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system prover for a “safe intersection’’ scenario.  The single assertion is a negated existential over 32‑bit bit‑vectors that mixes non‑linear arithmetic (multiplication and division) with a number of linear ordering constraints on velocities, positions and timing variables, thereby asking whether a counterexample to the safety invariant can exist.  It is part of the Preiner‑keymaera industrial suite and, while modest in size, features deep term nesting and mixed arithmetic that make it a non‑trivial BV‑non‑linear verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node673088.smt2",
    "description": "This instance is a safety‑verification condition extracted from the Keymaera hybrid‑systems prover (the “safe intersection” example) and translated into 32‑bit bit‑vector arithmetic. It checks, via a single quantified assertion, that under non‑negative positions, velocities, and time bounds, the computed positions of two moving objects (encoded with non‑linear multiplications and divisions) never violate a safety distance before a deadline. The problem lives in BV logic, features a moderate number of variables (18), deep nested arithmetic (term depth 19), and a quantifier‑alternation‑free but highly conjunctive formula, making it a challenging industrial benchmark for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node605043.smt2",
    "description": "This benchmark encodes a verification condition from the KeYmaera hybrid‑system verifier (the “safe‑intersection” example) as a single quantified bit‑vector formula.  The goal is to show that, under a collection of linear and non‑linear (multiplication/division) constraints on 32‑bit variables, an existential witness for a bad state cannot exist—i.e., the formula’s negation must be unsatisfiable.  The instance features a single quantified block, several arithmetic inequalities, and non‑linear operations, giving it moderate depth (≈20) and making it a typical industrial BV‑encoding of a nonlinear safety proof.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node29839.smt2",
    "description": "This benchmark encodes a verification condition from the KeYmaera hybrid‑system verifier (the “intersection‑example‑onelane” case study) that has been translated into 32‑bit bit‑vector arithmetic. The formula asserts, via a single existentially‑quantified time variable, a collection of non‑linear (quadratic) constraints involving positions, velocities and safety parameters, and then checks the negation of this condition—i.e., it tests whether the safety property holds. The instance features moderate size (13 bit‑vector constants, depth 23) but includes non‑linear multiplication and division, making it a challenging BV‑non‑linear arithmetic verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node47513.smt2",
    "description": "This benchmark is a verification condition from the KeYmaera hybrid‑system tool (the “intersection‑example‑onelane” case) that was translated into 32‑bit bit‑vector arithmetic. The formula asserts the non‑existence of a time instant satisfying a collection of linear and non‑linear constraints involving additions, multiplications and divisions of several variables (e.g., position, velocity, and timing parameters) together with safety bounds; the solver must refute the existential clause. The instance features a single existential quantifier, a moderate number of bit‑vector variables (13), deep nested conjuncts (≈22 term depth) and many nonlinear (bvmul, bvsdiv) operations, making it a challenging industrial‑style BV non‑linear arithmetic verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/train_goal6-node8607.smt2",
    "description": "This benchmark encodes a safety verification condition from the European Train Control System (KeYmaera “train_goal6”) that was translated into 32‑bit bit‑vector arithmetic.  The formula asserts that no value of the time‑step variable can violate a collection of non‑linear relationships among speeds, distances, control parameters and physical limits (e.g., bounds on acceleration, speed, and braking distance), expressed through a large conjunct of multiplications, divisions, and linear inequalities.  It is a single quantified (existential) check originating from an industrial verification benchmark, featuring 16 bit‑vector constants, deep nested terms (depth 21) and many arithmetic operations, which makes it a demanding instance for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node43393.smt2",
    "description": "This benchmark is a safety‑verification condition taken from the KeYmaera hybrid‑system verifier (the “intersection‑example‑onelane” proof node), translated into 32‑bit bit‑vector arithmetic. It asserts, under a set of non‑negative bounds on several variables, that a quadratic inequality involving products and divisions of these variables can never be violated; the outer `not` together with an existential quantifier checks the unsatisfiability of a counter‑example. The instance features non‑linear BV operations (multiplication, division), deep nested let‑bindings (term depth 23) and a single quantified block, making it a challenging industrial verification query for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node560442.smt2",
    "description": "This instance encodes a safety verification condition from the KeYmaera hybrid‑systems benchmark “intersection‑example‑simple”.  The goal is to prove, via bit‑vector arithmetic, that a set of linear and non‑linear (multiplication/division) constraints on 32‑bit variables—modeling positions, velocities, and timing at a traffic intersection—cannot be satisfied; it is expressed as the negation of an existential formula and is checked for unsatisfiability.  The problem features a single quantifier, moderate size (≈20 constants) and deep non‑linear term nesting (depth 21), making it a typical industrial BV verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node488920.smt2",
    "description": "This benchmark encodes a KeYmaera safety verification condition for a hybrid‑system “intersection” example, translated into 32‑bit bit‑vector arithmetic. The formula asserts that no assignment to the existential time variable can violate a set of non‑linear constraints (multiplication, division and signed comparisons) describing bounds on velocities, positions and a safety interval, so the solver must prove the negated existential (i.e., universal safety) unsatisfiable. The instance is industrial‑scale, with 19 BV variables, deep nested terms (depth 22) and a single quantified block, making it a challenging case of non‑linear BV verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node561875.smt2",
    "description": "This instance encodes a safety verification condition for a hybrid‑systems model of a road intersection (the “intersection‑example” from the KeYmaera benchmark suite). The original real‑valued arithmetic involving positions, velocities, and parameters A, B, V, ep is translated into 32‑bit bit‑vector arithmetic, preserving non‑linear operations (multiplication, division) and a single existential quantifier over a time variable. The solver must prove that the quantified condition is unsatisfiable (i.e., no violating execution exists), which requires reasoning about quantified, non‑linear bit‑vector constraints with moderate term depth and a handful of arithmetic inequalities.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node264307.smt2",
    "description": "This instance encodes a safety verification condition from the KeYmaera hybrid‑system prover (the “intersection‑example‑simple” proof) that was translated into 32‑bit bit‑vector arithmetic. The query asserts the negation of an existential statement over a time variable and checks whether a conjunction of non‑negative, bounded linear and quadratic relations (including products and a division) can be satisfied; thus it tests whether the safety invariant holds. The problem features a single quantifier, moderate term depth (20) and a handful of non‑linear BV operations, making it a typical industrial BV verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node295273.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system prover (the “intersection‑example‑simple” proof) and checks that, under a set of linear and non‑linear bounds on positions, velocities and timing variables, no unsafe state can be reached. The condition is expressed as a single quantified (∃ ts) negated assertion over 32‑bit bit‑vectors, mixing inequalities, addition, multiplication, and a single signed division, with deep term nesting (depth ≈ 20) and 18 declared constants. It originates from an industrial‑style verification case (safe intersections) and is intended to test solvers on non‑linear arithmetic translated to BV.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node551337.smt2",
    "description": "This instance encodes a verification condition extracted from the KeYmaera hybrid‑system proof of a “safe intersection” example. The formula asserts, via a negated existential over a time variable, that no reachable state can simultaneously satisfy a collection of linear and non‑linear 32‑bit bit‑vector constraints (including multiplications, a division, and many bounds on velocities, positions and a safety margin). It is a single‑quantifier, non‑linear BV problem originating from an industrial hybrid‑systems benchmark, with moderate size (19 constants, depth 20) that tests a solver’s ability to handle quantifiers and arithmetic non‑linearity.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/controllability-lemma-disturbed.proof-node770.smt2",
    "description": "This instance is a quantified bit‑vector verification condition extracted from a KeYmaera proof of a controllability lemma for a disturbed train‑control system. It checks, under a set of linear and quadratic inequality premises on several 32‑bit variables (e.g., non‑negative bounds, a relationship between a disturbance b and control u, and a safety condition involving v, d, m, z), that a final inequality relating the squares of v and d to the product 2·(b–u)·(m–z) holds. The encoding features non‑linear multiplication, a single alternation of ∃/∀ quantifiers, and deep term nesting, making it a challenging industrial‑level BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node369759.smt2",
    "description": "This benchmark is a verification condition extracted from the Keymaera hybrid‑system verifier (a safe‑intersection case study) and translated into 32‑bit bit‑vector arithmetic. It asserts, under a set of linear bounds on velocities, positions, and a time horizon, that certain non‑linear safety inequalities (involving products and signed divisions of bit‑vectors) hold for all admissible values, expressed with a single existential quantifier over a time variable. The formula features nested arithmetic expressions, multiple signed comparisons and a moderate number of variables, making it a typical industrial non‑linear BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node291850.smt2",
    "description": "This instance encodes a safety verification condition from the KeYmaera hybrid‑system benchmarks (the “intersection‑example” proof node) that has been translated into 32‑bit bit‑vector arithmetic. The single existential quantifier asserts the existence of a time value that would violate a conjunction of linear and non‑linear constraints (multiplications, a division, and several range checks on vehicle speeds, positions and parameters), and the outer negation turns the problem into an unsatisfiability check of that existential formula. The model features 19 bit‑vector constants, moderate term depth (21) and non‑linear arithmetic, making it a typical industrial verification case that challenges BV solvers on mixed arithmetic and quantified reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/train_goal3-node5717.smt2",
    "description": "This benchmark encodes a safety verification condition from the Keymaera family (European Train Control System case study) as a 32‑bit bit‑vector formula. The property is expressed as the negation of an existentially quantified inequality that combines numerous non‑linear arithmetic constraints (multiplications, divisions and quadratic terms) together with linear bounds on several system variables. The instance features a single quantifier, 16 bit‑vector constants, deep term nesting (depth 21) and heavy use of BV arithmetic, making it a challenging industrial verification problem for solvers handling non‑linear BV reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node169818.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system prover (the “intersection‑example‑simple” VC), translated into 32‑bit bit‑vectors. It asks whether a quantified existential block over a time variable can satisfy a conjunction of non‑linear arithmetic constraints (multiplications, a division) together with numerous linear bounds on positions, velocities and constants; the top‑level formula is negated, so the solver must prove unsatisfiability. The instance originates from the IJCAR 2012 “Solving Non‑Linear Arithmetic” paper, belongs to the industrial Preiner‑keymaera family, and is notable for its single quantifier, deep nesting (term depth 20) and a mixture of non‑linear and linear bit‑vector arithmetic that makes it challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node155401.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system prover (the “intersection‑example” for safe road crossings). After translation to 32‑bit bit‑vectors, it asserts that no assignment to a time variable can violate a set of nonlinear arithmetic constraints involving positions, velocities, and bounds (multiplication, division and signed comparisons) together with several invariant inequalities. The check‑sat query therefore tests the unsatisfiability of a quantified, non‑linear BV formula, a typical industrial verification problem with moderate term depth and a single quantified block.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node631276.smt2",
    "description": "The benchmark is an industrial verification condition originating from the KeYmaera hybrid‑system verifier (the “intersection‑example” safety proof). It encodes, in 32‑bit bit‑vector arithmetic, a set of nonlinear constraints on vehicle speeds, accelerations and distances (non‑negative parameters, quadratic terms v₁·v₁, v₂·v₂, divisions, and bounds on a time variable), and asks whether there exists a time instant that violates the safety inequality. The formula is a single quantified assertion with a moderate term depth (≈20) and a fairly dense conjunction of arithmetic comparisons, making it a typical non‑linear BV verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/FTRM-entry-tang-feasible-node1796.smt2",
    "description": "The instance encodes a verification condition from the KeYmaera hybrid‑system verifier for a curved‑flight collision‑avoidance maneuver (the “FTRM‑entry‑tang‑feasible” case). It asks whether there exist values for two auxiliary variables (representing geometric quantities) that satisfy a system of non‑linear equalities and inequalities involving squares and products of 32‑bit bit‑vectors; the overall formula is negated so the solver must prove the condition unsatisfiable. The benchmark therefore tests non‑linear arithmetic handling on bit‑vectors with two existential quantifiers, moderate term depth (≈12) and a handful of variables, reflecting an industrial verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node548277.smt2",
    "description": "This benchmark encodes a safety‑verification condition extracted from a KeYmaera hybrid‑system proof about a traffic‑intersection scenario. After translation to 32‑bit bit‑vectors it asserts (by negating an existential) that positions, velocities and parameters (including non‑linear products such as B·ts and v₂·v₂) always stay within prescribed bounds, using a mixture of signed inequalities and multiplications. The instance is an industrial‑style verification problem with a single quantifier, deep term nesting (depth 19) and non‑linear BV arithmetic, which makes it a challenging case for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node606132.smt2",
    "description": "This instance encodes a verification condition from the KeYmaera hybrid‑system verifier (the “safe‑intersection” example) that has been translated to 32‑bit bit‑vector arithmetic. The single assertion checks, via a negated existential quantifier, whether a set of non‑linear arithmetic constraints (multiplications, a division, and numerous signed inequality bounds on speeds, positions and timing variables) can be satisfied, essentially testing a safety property of the intersection model. The problem is industrial‑grade, involving a quantified bit‑vector formula with moderate size (20 constants) but a relatively deep term structure (depth 20) and a mixture of non‑linear operations, which makes it challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node362512.smt2",
    "description": "The benchmark encodes a verification condition from the KeYmaera hybrid‑systems verifier (the “safe‑intersection” example). After translating the original real‑valued safety proof to 32‑bit bit‑vectors, the formula checks that, for all admissible parameter values (non‑negative positions, velocities, and constants A, B) and for every time instant t, the computed future positions (which involve non‑linear terms v₁² / (2·B) and v₂² / (2·B)) stay within prescribed bounds and respect the timing deadline ep. It is a single quantified (∃ ts) assertion over BV arithmetic with many signed inequalities, quadratic multiplications, and a division, yielding moderate term depth (≈20) and a typical industrial‑style verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node288860.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system prover (the “intersection‑example‑simple” VC) as a 32‑bit bit‑vector problem.  The single quantified assertion combines non‑linear arithmetic (multiplications, a division) with a rich set of signed inequality constraints over variables representing velocities, positions and timing parameters, and it is deep (term‑depth 20) and heavily nested with Boolean connectives.  Consequently, the instance tests a solver’s ability to handle quantified, non‑linear BV arithmetic that arises from translating a real‑world hybrid‑systems verification case.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/ETCS-essentials-live-range2.proof-node577.smt2",
    "description": "This benchmark encodes a single verification condition extracted from the KeYmaera proof of the European Train Control System (ETCS) case study. It is a quantified non‑linear bit‑vector problem: under positivity constraints on three 32‑bit variables, it asks whether there exists a value for a fourth variable that can make a linear inequality involving a product of two variables hold. The instance therefore tests the solver’s ability to handle quantified, non‑linear arithmetic on 32‑bit bitvectors in an industrial verification context.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node53901.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system verifier (the “intersection‑example‑onelane” case) that has been translated to 32‑bit bit‑vector arithmetic. It asserts the negation of an existential formula over a time variable, coupling linear bounds on several state variables with a non‑linear quadratic term ( v·v ) and a division, together with numerous non‑negativity and range constraints. The problem thus tests a solver’s ability to handle a single quantified BV formula with mixed linear/non‑linear operations, moderate term depth (22) and 13 bit‑vector constants, typical of industrial hybrid‑system verification tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node294748.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system verifier (an “intersection” example) that has been translated into 32‑bit bit‑vector arithmetic.  The formula asserts that there is **no** assignment to a time variable satisfying a large conjunction of bound constraints (non‑negative velocities, positions, time limits, and a quadratic term v²/(2·B)) together with the system dynamics; the negated VC is checked for unsatisfiability.  It features a single existential quantifier, non‑linear operations (multiplication and division of bit‑vectors), many relational constraints, and a moderate term depth (19), making it a representative industrial verification instance that stresses BV solvers on quantified, non‑linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node174885.smt2",
    "description": "This instance is a safety‑verification condition extracted from the KeYmaera hybrid‑systems prover (the “intersection‑example” proof node), translated into 32‑bit bit‑vector arithmetic. It asserts the negation of an existential formula over a time variable, encoding a collection of non‑linear constraints (multiplication, division) that bound velocities, positions, and system parameters and require all variables to stay within prescribed ranges. The problem is purely a BV‑satisfiability check with a single quantifier and moderate term depth (≈20), featuring 18 declared constants and a mixture of linear and non‑linear arithmetic typical of industrial verification benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node171778.smt2",
    "description": "This benchmark is a safety‑verification condition extracted from the KeYmaera hybrid‑system proof of a “safe intersection” example. It is encoded in 32‑bit bit‑vector arithmetic and asserts (via a negated existential) that no time‑step `ts796uscore0` can satisfy a collection of non‑linear constraints involving multiplications, a division and numerous linear bounds (e.g., non‑negativity, upper limits V, and relational checks between positions xI1, xI2 and their primed counterparts). The instance features a single existential quantifier inside a negation, 20 bit‑vector variables, term depth 20, and non‑linear arithmetic, making it a typical industrial verification problem that challenges BV solvers on nonlinear reasoning rather than sheer quantifier complexity.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node346919.smt2",
    "description": "This benchmark is a safety‑verification condition extracted from a KeYmaera proof of a “safe intersection” hybrid‑system model and translated into 32‑bit bit‑vectors. It asserts the negation of an existential property over a time variable, combining numerous bounds on velocities, positions and interval parameters with non‑linear (quadratic) terms such as v₁² and v₂² divided by 2·B, together with positivity constraints on constants like B, V and ep. The formula features a single quantified variable, deep nesting of arithmetic predicates, and many conjuncts, yielding a moderate‑size (≈19 constants) but non‑linear BV verification problem that is representative of industrial hybrid‑system checks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/vsl.proof-node2761.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems prover, translated into 32‑bit bit‑vector arithmetic. The formula asserts that no choice of the time variable ts can satisfy a large conjunction of linear and non‑linear (multiplication, division) inequality constraints over several state variables, and the solver must prove the resulting universally quantified property (the outer not of an existential). The instance is industrial‑sized (≈10 bit‑vector constants, term depth 20) and challenges solvers with mixed arithmetic, a single quantifier layer, and non‑linear bit‑vector operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node175109.smt2",
    "description": "This benchmark encodes a verification condition coming from the KeYmaera hybrid‑system proof “intersection‑example‑simple” (a safety property for a vehicle crossing an intersection). After translation to 32‑bit bit‑vectors, the formula asserts (under a negated existential) a conjunction of linear and non‑linear inequalities (including multiplications, a division and a quadratic term) over 18 numeric variables that model positions, velocities and timing parameters. The problem is therefore a BV‑logic safety‑verification query with one quantified block, a moderate term depth (21) and a handful of arithmetic operators, making it a non‑linear, quantified BV instance typical of industrial hybrid‑system verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node387850.smt2",
    "description": "This instance encodes a safety verification condition generated by the KeYmaera hybrid‑system verifier for a “safe intersection” scenario.  The formula (negated existential) asserts that, under non‑negative bounds on velocities, positions, and parameters (A, B, V, ep) and with safety distances expressed as \\( \\frac{v^2}{2B\\cdot t + v_0}\\), no unsafe state can be reached; it therefore checks unsatisfiability of the negated condition.  The benchmark originates from the Jovanovic‑de Moura non‑linear arithmetic suite, has been translated to 32‑bit bit‑vectors, contains a single quantifier, several non‑linear multiplications and divisions, and exhibits moderate size (≈2.8 KB) with a term depth of 19, making it a representative industrial verification problem involving non‑linear arithmetic over bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node531710.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system verifier (the “intersection‑example‑simple” proof) as a 32‑bit bit‑vector formula. The goal is to refute the existence of a time‑step variable that violates a collection of linear and non‑linear constraints (positivity of parameters, bounds on velocities, and affine expressions involving products and a division), i.e., it checks whether a counterexample to the intersection safety property exists. The instance features a single existential quantifier over 18 bit‑vector variables, uses non‑linear BV arithmetic (multiplication and signed division), and has moderate term depth (20) and size, making it a typical industrial verification problem that challenges solvers’ handling of non‑linear bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node197625.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system proof “intersection‑example‑simple”, translated into 32‑bit bit‑vectors. The goal is to show that no assignment to the existentially quantified time variable can satisfy a conjunction of arithmetic constraints that model vehicle positions, velocities, accelerations and timing bounds (all required to be non‑negative and within given limits), together with a case split on a collision‑avoidance predicate. Thus the problem is a non‑linear BV verification task (with multiplication, division and signed comparisons) containing a single quantified formula and a moderate term depth, typical of industrial hybrid‑system safety checks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node480617.smt2",
    "description": "This benchmark encodes a safety‑verification condition from the KeYmaera hybrid‑system model of a traffic intersection, translated into 32‑bit bit‑vector arithmetic. The single assertion is the negation of an existential over a time variable, i.e. a universal safety property, and contains non‑linear operations (multiplication, division) together with numerous linear inequalities on positions, velocities and parameters. The formula involves 19 declared bit‑vector constants, a term depth of 20, and a quantified sub‑formula, making it a representative industrial BV non‑linear verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node250172.smt2",
    "description": "This benchmark encodes a verification condition for a hybrid‑system safety proof (the “intersection‑example” from KeYmaera) that has been translated from non‑linear real arithmetic into 32‑bit bit‑vector arithmetic.  The single quantified assertion checks that, under a set of linear and non‑linear (quadratic) relationships among time, positions, velocities and constants, no reachable state violates the safety bounds (e.g., positivity of distances and speeds, and a collision‑avoidance inequality).  The problem features a moderately deep term structure (depth ≈ 20), several intertwined inequality constraints, and a single existential quantifier, making it a typical industrial BV‑encoded verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node11136.smt2",
    "description": "This benchmark encodes a safety verification condition derived from the KeYmaera hybrid‑system proof “intersection‑example‑onelane”, translated into 32‑bit bit‑vector arithmetic. The query asserts the negation of an existential statement over a time variable, requiring that a collection of linear and non‑linear (variable × variable) inequality constraints on positions, velocities, and parameters remain within prescribed bounds; proving the VC amounts to showing the formula is unsatisfiable. The instance contains a single quantified block, 13 bit‑vector constants, deep nesting (term depth 23) and non‑linear multiplication, which together make it a challenging industrial BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node347928.smt2",
    "description": "This benchmark is a verification condition extracted from a KeYmaera proof of a “safe intersection” hybrid‑system model (the intersection‑example‑simple case).  After translation to 32‑bit bit‑vectors it asserts, under an existential time variable, a collection of linear and non‑linear (quadratic) inequalities over vehicle speeds, positions and timing constants, together with non‑negativity and range bounds.  The instance is industrial‑style, features a single quantified formula with deep nested arithmetic (multiplications, divisions, and conditionals) and therefore stresses solvers on combined quantifier handling and non‑linear bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node271565.smt2",
    "description": "This instance encodes a safety verification condition for a hybrid‑systems model of a road intersection (the “intersection‑example” from KeYmaera), translated to 32‑bit bit‑vector arithmetic. The problem asks to show that, under a set of linear and non‑linear (multiplication and division) bounds on variables such as speeds, positions and timing parameters, no reachable state can violate the safety limits; formally it is the negation of an existential witness, i.e. a universally quantified safety property. The benchmark features a single quantified block, a moderate depth of nested arithmetic terms (depth 19), and several non‑linear BV operations, making it a challenging industrial‑style verification case for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node674535.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems tool (the “intersection‑example” from the safe‑intersection case study) as a 32‑bit bit‑vector formula.  The formula asserts the negation of an existentially quantified timing variable together with a conjunction of non‑linear arithmetic constraints (multiplications, a square term, a signed division, and a mix of upper‑ and lower‑bounds) over several state variables, all expressed with BV arithmetic.  As an industrial‑style verification problem it features a single quantified block, many inequality literals, and moderately deep term nesting, making it a challenging BV instance for solvers that must handle non‑linear arithmetic and quantifier reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node459232.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system framework (the “safe intersection” example) as a quantifier‑free bit‑vector problem with one existentially quantified time variable. The formula asserts that, under non‑negative bounds on several 32‑bit variables and linear dynamics that involve mixed multiplications (e.g., A·ts and –B·ts), no assignment to the time variable can violate the safety constraints (bounds on positions, velocities, and a deadline ep). The instance features non‑linear BV arithmetic, a single quantified block, moderate term depth (≈19) and 18 declared bit‑vector constants, making it a representative industrial verification case for nonlinear arithmetic solving.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node384691.smt2",
    "description": "This benchmark encodes a verification condition from the KeYmaera hybrid‑system verifier for a simple safe‑intersection scenario.  It asks whether there exists a time stamp (as a 32‑bit vector) that satisfies a collection of nonlinear arithmetic constraints – bounding positions, velocities and accelerations, relating them through multiplication, division and addition, and enforcing non‑negativity and upper‑bound limits.  The formula is expressed in BV logic, contains a single existential quantifier, a moderate number of variables (18 constants) and a term depth of 20, making it a typical industrial‑style non‑linear BV verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node57081.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems verifier (the “intersection‑example‑simple” proof node) as a quantifier‑free bit‑vector formula. The goal is to show that, under a collection of non‑negative bounds on parameters (A, B, V, ep) and relational constraints on state variables (e.g., xI1 < x1, I1 = 2), there cannot exist a time step ts satisfying the hybrid dynamics expressed by the two affine updates v1 + A·ts and v2 – B·ts while remaining within the interval [0, V] and respecting a deadline ep. It is a BV‑logic (32‑bit) encoding of a non‑linear arithmetic verification problem, featuring a single existential quantifier, moderate term depth (20) and a handful of arithmetic and comparison operators.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node384936.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems proof “intersection‑example‑simple” (a safe‑intersection scenario) as a single quantified bit‑vector formula. The task is to prove that the existentially quantified state variables cannot satisfy a conjunction of non‑linear arithmetic constraints (multiplications, divisions, and linear bounds on positions, velocities, and time), i.e., the negated exists‑formula must be unsatisfiable. The instance features 19 32‑bit variables, deep term nesting (depth 20) and mixed signed comparisons, making it a challenging BV non‑linear arithmetic verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node25171.smt2",
    "description": "This benchmark encodes a verification condition extracted from the KeYmaera proof of a “safe‑intersection” hybrid‑system model (the one‑lane example) and was translated to 32‑bit bit‑vector arithmetic. The formula asserts the negation of an existential witness for a time variable that would violate a collection of safety bounds (position, velocity and timing constraints) involving non‑linear operations such as multiplication and division of bit‑vectors. The instance is industrial‑style, contains a single quantified block but deep nesting (term depth 23) and several non‑linear arithmetic constraints, which makes it a challenging case for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node347403.smt2",
    "description": "This instance encodes a safety verification condition from the KeYmaera hybrid‑systems prover (the “intersection‑example‑simple” proof).  The formula asserts that, under a set of linear and non‑linear (quadratic) constraints on 32‑bit vehicle‑state variables (positions, velocities, timing parameters, etc.), a certain safety inequality holds for all admissible times.  It is presented as a single quantified (∃) BV formula, translated from real arithmetic, with modest variable count (19) but non‑linear multiplications and a depth‑19 term structure, making it a typical industrial hybrid‑system verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/dccs-example-simple-node6246.smt2",
    "description": "This instance encodes a verification condition from the KeYmaera hybrid‑system verifier (adaptive cruise‑control example) as a quantified bit‑vector formula. It asks whether there exists a 32‑bit time variable satisfying a collection of linear and non‑linear (multiplication, division) inequalities over several state variables, and the outer negation turns the check into an unsatisfiability test. The problem is an industrial‑scale BV verification task featuring one existential quantifier, non‑linear arithmetic, and moderate term depth (≈20) with 12 bit‑vector constants.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node189374.smt2",
    "description": "This instance encodes a safety verification condition extracted from the KeYmaera hybrid‑system verifier (the “safe‑intersection” case study) and translated from non‑linear real arithmetic into 32‑bit signed bit‑vector arithmetic. The formula asserts (under a single existential quantifier over a time variable) a conjunction of linear and non‑linear constraints—signed inequalities, additions, multiplications and a division—relating positions, velocities and timing parameters, and is wrapped in a negated existential to be checked for unsatisfiability. The problem features moderate size (≈2.7 KB, 18 bit‑vector constants) but a relatively deep term structure (depth 21) and non‑linear BV operations, making it a challenging benchmark for BV solvers with quantifier handling.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node192767.smt2",
    "description": "The instance encodes a safety verification condition extracted from a KeYmaera hybrid‑systems proof about a vehicle‑intersection scenario. After translating the original real‑valued VC to 32‑bit bit‑vectors, it asserts that no assignment to a time variable can satisfy a conjunction of non‑linear arithmetic constraints (multiplications, a division, and several signed inequalities) together with boundary conditions on positions, velocities, and constants. The problem is therefore a single‑quantifier (existential) BV verification query, featuring moderate term depth (20) and a handful of non‑linear operations, typical of industrial hybrid‑system verification benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node388939.smt2",
    "description": "This instance encodes a safety verification condition from the KeYmaera hybrid‑system prover (the “intersection‑example” proof) as a 32‑bit bit‑vector problem. It checks that, for all admissible time values, a set of non‑linear arithmetic constraints (including products of variables and integer division) and several lower/upper bound inequalities hold, expressed as the negation of an existential witness. The formula contains a single deep conjunctive assertion with one existential quantifier, many arithmetic relations, and moderate size (≈19 constants, depth 20), making it a typical industrial verification benchmark with challenging non‑linear BV reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node620306.smt2",
    "description": "This benchmark encodes a safety verification condition from the Keymaera hybrid‑systems prover (the “intersection‑example‑simple” proof node). After being translated to 32‑bit bit‑vectors, it asserts that there exists a time stamp satisfying a collection of non‑linear arithmetic constraints (quadratic terms, a multiplication by a time variable, and a signed division) together with a large set of linear inequalities on the system’s state variables (positions, velocities, and bounds). The formula is a single quantified assertion with a moderate number of variables (≈19) but deep, non‑linear term structure (max depth 20), making it a challenging BV‑logic verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node391142.smt2",
    "description": "The benchmark encodes a safety verification condition for a hybrid‑system model of a road intersection (the KeYmaera “intersection‑example”), translated into 32‑bit bit‑vector arithmetic. It asserts that no choice of a time‑step variable can violate a collection of nonlinear inequalities involving squared velocities, divisions and bounds on positions, velocities and parameters, i.e., it checks that a certain safety invariant holds for all reachable states. The problem features a single quantified existential sub‑statement, nested nonlinear multiplications and divisions, and a moderate term depth, making it a non‑linear BV verification task of industrial origin.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node385140.smt2",
    "description": "This instance encodes a single verification condition from the KeYmaera hybrid‑system proof “safe intersections”, translated into 32‑bit bit‑vector arithmetic. The formula asserts that, under a set of non‑linear constraints (quadratic terms `v1*v1`, `v2*v2`, divisions, and several signed inequalities on variables representing positions, velocities and time), there is no witness for an existential time variable that violates the safety bound ‑‑ i.e. it checks the validity of the VC. The benchmark features a moderately deep term structure (depth 21), one existential quantifier, and a mixture of multiplication, division and signed comparisons, making it a representative industrial non‑linear arithmetic problem for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node51016.smt2",
    "description": "The instance is a safety‑verification condition extracted from the KeYmaera hybrid‑systems tool (the “intersection‑example‑onelane” case study) and translated into 32‑bit bit‑vector arithmetic. It asserts that no assignment to the time variable ts satisfies a large conjunct of nonlinear constraints involving positions, velocities and other parameters (multiplication, division and comparisons) – i.e., it checks the unsatisfiability of a negated existential, which corresponds to proving a safety invariant for a one‑lane traffic‑intersection model. The problem features a single quantified block, deep (depth 25) non‑linear BV terms, and a dense mixture of arithmetic and relational operators, making it a challenging BV‑non‑linear instance typical of industrial verification workloads.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node476004.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system verifier (the “intersection‑example‑simple” proof node) as a bit‑vector formula.  The assertion states, under a large conjunction of linear and non‑linear (multiplication, division) constraints on speeds, positions, and timing parameters, that there exists a non‑negative time step for which a safety bound is violated; the outer `not` makes the whole query check unsatisfiability of that VC.  Although the problem contains only 18 bit‑vector variables, it features an existential quantifier, deep nesting (depth 21) and non‑linear arithmetic over 32‑bit vectors, which together make it a challenging industrial‑style BV verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node605258.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems prover (the “intersection‑example‑simple” proof). The goal is to show that, under a collection of linear and non‑linear (multiplication, division) 32‑bit bit‑vector constraints on positions, velocities, and timing variables, a certain unsafe region (expressed by the existentially‑quantified time ts) cannot be reached; the formula is asserted negated, so the solver must prove it unsatisfiable. The instance features a single existential quantifier, a modest set of 19 bit‑vector variables, and moderately deep non‑linear arithmetic terms, characteristic of industrial hybrid‑system verification problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node632840.smt2",
    "description": "This benchmark encodes a verification condition from the KeYmaera hybrid‑system safety proof “Safe intersections” (intersection‑example‑simple) and was translated into 32‑bit bit‑vector arithmetic. The problem asks whether a universally‑quantified safety invariant holds by asserting the negation of an existential witness, involving non‑linear constraints such as quadratic terms (v₁·v₁, v₂·v₂), division, and multiple linear inequalities over non‑negative variables. The instance features a single, large conjunctive formula with a quantifier, a let‑binding, and deep terms (depth ≈ 20), making it a challenging BV‑non‑linear arithmetic case for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node287705.smt2",
    "description": "This benchmark is a safety verification condition extracted from the KeYmaera hybrid‑system proof “intersection‑example‑simple”, modelling a vehicle‑intersection scenario. It is encoded as a single quantified (existential) formula over 32‑bit bit‑vectors that mixes linear bounds with non‑linear arithmetic (multiplication and a division), numerous non‑negativity and ordering constraints, and a final disjunction that captures the safety property. The instance therefore tests an SMT solver’s ability to handle industrial‑style non‑linear BV verification problems with moderate variable count, deep term nesting (depth 21) and a single quantifier alternation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/binary_driver-2007-10-09-node8746.smt2",
    "description": "The benchmark is a safety verification condition drawn from the KeYmaera hybrid‑system proof “binary_driver‑2007‑10‑09” (node 8746), translated into 32‑bit bit‑vector arithmetic. It asserts, via a single existentially quantified time variable, a conjunction of many non‑linear inequalities (products, squares and divisions) over the system’s parameters and checks that this conjunction is unsatisfiable (the outer `not`), i.e., that the safety property holds. The problem features a moderate number of variables (15) but a deep term structure (depth 22) with several non‑linear BV multiplications and divisions, making it a challenging quantified BV verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node561079.smt2",
    "description": "This instance encodes a verification condition from the KeYmaera hybrid‑system proof of a safe traffic‑intersection scenario. The property is expressed as a negated existential quantifier over a 32‑bit time variable, together with a large conjunction of non‑linear signed bit‑vector constraints (multiplication, division and several inequality bounds on velocities, positions and parameters). The benchmark therefore tests a BV solver’s ability to handle non‑linear arithmetic and a single quantified block in a moderately sized industrial verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node548891.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems prover (the “intersection‑example‑simple” case).  The goal is to show that no assignment to the time‑stamp variable can satisfy a conjunction of arithmetic constraints describing vehicle speeds, positions, and a collision‑avoidance bound; this is expressed as the unsatisfiability of a quantified bit‑vector formula that mixes non‑linear operations (multiplication, division) with several linear orderings.  The instance therefore tests a solver’s ability to handle a moderately sized (19 BV‑32 variables) non‑linear bit‑vector problem with one existential quantifier, deep terms (depth 20) and a rich mix of comparators, typical of industrial verification workloads.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/vsli.proof-node2282.smt2",
    "description": "This benchmark encodes a safety verification condition generated by the KeYmaera hybrid‑system prover (node 2282 of *vsli.proof*), translated from its original real‑arithmetic form into 32‑bit bit‑vector arithmetic.  The SMT query asserts the negation of an existential formula that mixes non‑linear operations (multiplications, divisions) and a large conjunction of signed inequality constraints over a handful of variables, essentially checking that a certain invariant cannot be violated.  The problem therefore belongs to the verification‑condition category, features deep (depth 27) non‑linear BV terms and a single quantifier, making it a challenging industrial‑style instance for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/binary_driver-2007-10-09-node11384.smt2",
    "description": "This benchmark encodes a verification condition from the KeYmaera hybrid‑system verifier (the “binary_driver” example) that has been translated into 32‑bit bit‑vector logic. The single top‑level assertion checks the unsatisfiability of an existential formula that combines many non‑linear BV multiplications with a cascade of signed inequalities (≤, ≥, >) over fifteen variables, producing a deep term graph (depth 21) and a moderate overall size. Consequently, the instance tests a solver’s ability to handle quantified, non‑linear arithmetic in the BV fragment, a typical challenge in industrial hybrid‑system verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node361987.smt2",
    "description": "This benchmark encodes a verification condition from the KeYmaera hybrid‑system verifier (the “intersection‑example” safety proof) that has been translated to 32‑bit bit‑vectors.  The single quantified formula checks that, under a host of positivity and bounded‑by‑V assumptions, a nonlinear arithmetic implication involving multiplications, a division, and signed comparisons never holds; the outer negated existential makes the problem a SAT‑check for a counterexample.  The instance features 19 bit‑vector variables, a modest quantifier structure (one existential), deep nested arithmetic (term depth 21) and non‑linear operations, which together give it the character of an industrial verification/ non‑linear arithmetic benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node478879.smt2",
    "description": "This benchmark is a safety verification condition extracted from the KeYmaera hybrid‑system model of a traffic intersection (the “intersection‑example‑simple” proof) and translated into 32‑bit bit‑vector arithmetic. The formula asserts, via a single existential quantifier, that no choice of a time‐step variable can satisfy a conjunction of signed inequality constraints involving additions, multiplications and a division over the variables representing velocities, accelerations and positions; in other words the VC must be shown unsatisfiable. It features non‑linear bit‑vector operations, 19 declared constants, moderate term depth (≈20) and is representative of the industrial‑level verification benchmarks from the Preiner‑keymaera family.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/vsli-alert.proof-node2416.smt2",
    "description": "This instance encodes a safety verification condition originating from the KeYmaera hybrid‑systems prover (the “vsli‑alert” proof node). After translation into 32‑bit bit‑vector arithmetic, the formula asserts—via a single existential quantifier over a time stamp—that a complex combination of linear and non‑linear relations (multiplications, divisions, and quadratic terms) among several state variables can never hold; the outer `not` makes the solver check that the condition is unsatisfiable. The benchmark therefore tests BV solvers on a non‑linear verification problem with a moderate number of variables (14 constants), deep term nesting (depth 26), and a single quantifier alternation, reflecting typical industrial verification challenges.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/bouncing-ball-inv-node6249.smt2",
    "description": "This benchmark is a verification‑condition (VC) extracted from the KeYmaera hybrid‑systems prover for the “bouncing‑ball” example (node 6249). After being translated to 32‑bit bit‑vectors it asserts that there **does not exist** an assignment to the time variable `ts1uscore2` that violates a set of polynomial equalities and inequalities encoding the physical dynamics (gravity `g`, velocity `V`, height `h`, etc.) and the intended invariant of the system. The problem features a single existential quantifier over a heavily nested term (depth 24) with many non‑linear BV multiplications and a division, making it a challenging non‑linear arithmetic instance in the BV logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node605722.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems prover (the “intersection‑example‑simple” proof node).  Using 32‑bit bit‑vectors to model the system’s continuous variables, it checks that no witness exists for a time‐parameter ts satisfying a conjunction of linear and non‑linear constraints (including multiplications and a division) together with several bound and ordering requirements on velocities, positions, and timing constants.  The single quantified (existential) assertion, wrapped in a negation, makes the problem a non‑linear BV verification task with moderate size (19 constants) but a relatively deep term structure (depth 20), typical of industrial hybrid‑system safety proofs.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node268667.smt2",
    "description": "The benchmark encodes a safety verification condition from the KeYmaera proof of a “safe intersection” hybrid‑system example.  After translation to 32‑bit bit‑vectors it asserts (via a negated existential) that no choice of the time variable can violate a collection of linear and quadratic bounds on positions, velocities and parameters (involving multiplications such as v₂·v₂ and divisions).  It is an industrial‑style BV problem with a single quantified block, non‑linear arithmetic and many inequality constraints, posing a typical challenge for solvers that handle quantified non‑linear bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node632728.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera proof of a “safe intersection” hybrid‑system, translated into 32‑bit bit‑vector arithmetic. It asserts that, under numerous non‑linear constraints (quadratic terms, multiplication, signed division) and bounds on velocities, positions and time, no existential assignment to the time variable can violate the invariant that the vehicles remain within safe limits. The instance features a single quantified variable, deep (≈20) term nesting and mixed arithmetic‑inequality constraints, which makes it a challenging industrial BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node249484.smt2",
    "description": "This benchmark is a safety‑verification condition extracted from the KeYmaera hybrid‑systems prover for a “safe intersection” traffic example. After being translated to 32‑bit bit‑vector arithmetic, the formula asserts (via a negated existential over a time variable) that all involved positions, velocities and parameters stay within prescribed non‑negative ranges and respect several nonlinear relations (multiplication and division) that model the dynamics of two vehicles; the property to prove is expressed as a disjunction of a positional coincidence or a time‑bound condition. The instance contains a single quantified block, moderate term depth (20) and a handful of arithmetic operations, making it a typical industrial BV verification challenge with non‑linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/ETCS-d-braking-node1346.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system verifier for the ETCS (European Train Control System) braking model, translated into 32‑bit bit‑vector arithmetic. The single assertion is a quantified formula (∃ t₁ ∀ ts₁ …) that combines several ordering constraints with non‑linear operations such as multiplications (including a squared term) and a division by 2, asserting an inequality relating the variables that represent speeds, distances, and braking parameters. The presence of nested quantifiers, non‑linear BV arithmetic, and a relatively deep term structure makes the instance a representative industrial verification challenge.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-UltimateAutomizer/Primes_true-unreach-call.c_673.smt2",
    "description": "This instance is a safety‑verification check generated by Ultimate Automizer from an SV‑COMP 2015 benchmark (a small C program, here a “prime‑checking” example). It encodes, in 32‑bit bit‑vector logic, the condition that the program’s return value must equal its input n and that n is bounded by 2, while also asserting that no pair of auxiliary variables can satisfy a certain arithmetic inequality involving f1, n and multiples of 2; the negation of this conjunction is added to force the solver to prove the property unsatisfiable (i.e., the unsafe call is unreachable). The formula features a few quantified sub‑terms (two existential quantifiers) and modest term depth (≤8) with only four bit‑vector constants, making it a compact industrial verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-UltimateAutomizer/Primes_true-unreach-call.c_2207.smt2",
    "description": "The file is a bit‑vector safety‑verification query produced by Ultimate Automizer from a SV‑COMP “primes” benchmark. It asks whether there exists a 32‑bit value that simultaneously satisfies a simple linear inequality (involving a doubled program variable, another auxiliary value and a constant offset) together with the original input bound, while asserting that no such witness can exist for a closely related quantified sub‑condition. The problem is small (three 32‑bit constants, two existential quantifiers, shallow term depth) and belongs to the BV logic category of industrial verification instances.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-UltimateAutomizer/nested9_true-unreach-call.i_1070.smt2",
    "description": "This instance is a software‑verification condition generated by Ultimate Automizer from an SV‑COMP 2015 benchmark. It encodes the safety (unreachability) of a program fragment as a set of signed 32‑bit‑vector inequalities over three loop variables, together with a single existentially quantified witness that must satisfy additional linear constraints. The task is a small‑scale BV‑satisfiability check (one existential quantifier, low term depth, three declared constants) typical of industrial verification problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-UltimateAutomizer/Primes_true-unreach-call.c_678.smt2",
    "description": "This instance is a bit‑vector verification condition generated by Ultimate Automizer from the SV‑COMP 2015 benchmark *Primes_true‑unreach‑call.c*. It encodes a safety (unreachability) property: there must exist two 32‑bit witnesses satisfying a set of linear bv‑inequalities that relate the program’s returned value to its input, and the formula checks that the returned value cannot equal the input. The query contains only four BV constants, a handful of let‑bindings and two existential quantifiers, with moderate term depth (9), representing a typical BV‑only industrial verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-UltimateAutomizer/nested9_true-unreach-call.i_670.smt2",
    "description": "This instance is a software‑verification query generated by Ultimate Automizer for an SV‑COMP 2015 benchmark. It encodes a reachability (unreach‑call) condition over three 32‑bit integer variables using only linear bit‑vector arithmetic; the main check is a single SAT/UNSAT test that negates a safety property involving a nested existential quantifier. The problem is modest in size (three BV variables, depth 8) but includes a quantifier alternation, making it a typical BV‑logic verification case rather than a pure decision‑procedure benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-UltimateAutomizer/Primes_true-unreach-call.c_597.smt2",
    "description": "The instance is a bit‑vector encoding of a safety‑property check generated by Ultimate Automizer from the SV‑COMP 2015 benchmark *Primes_true‑unreach‑call.c*. It asserts that a certain arithmetic condition involving two existentially quantified 32‑bit variables (essentially “there exist v₁, v₂ satisfying linear bounds and 2·v₁+2·v₂+1 ≤ ret”) holds under the program’s pre‑conditions, and immediately negates the same existential clause to force unsatisfiability—thus encoding the standard unreachability proof obligation. The problem features a modest term depth (≤ 7), three bit‑vector constants, a single quantifier block, and is intended to be solved by a BV solver checking a single SAT/UNSAT query.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-UltimateAutomizer/nested9_true-unreach-call.i_1770.smt2",
    "description": "This instance is a safety‑verification query generated by the Ultimate Automizer tool from an SV‑COMP 2015 benchmark.  It encodes the program’s integer variables as 32‑bit bit‑vectors and asserts a conjunction of linear bounds and multiplications, together with two existentially‑quantified auxiliary variables, then negates the conjunction to test an unreachability condition.  The problem is a relatively small BV formula (3 declared variables, depth 8) but includes nested quantifiers and arithmetic, typical of bounded‑model‑checking style verification tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-UltimateAutomizer/Primes_true-unreach-call.c_187.smt2",
    "description": "This instance encodes a software‑verification condition generated by Ultimate Automizer for an SV‑COMP benchmark (the “Primes” unreachable‑call test). It checks a bit‑vector safety property by asserting that a certain existentially quantified inequality over three 32‑bit variables both holds and does not hold, i.e., it expects the formula to be unsatisfiable. The problem involves a small set of 32‑bit arithmetic terms (addition, multiplication by two, and comparisons) and a single block of existential quantifiers, making it a modest‑size BV verification query with limited quantifier depth.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-UltimateAutomizer/nested9_true-unreach-call.i_473.smt2",
    "description": "This instance is a software‑verification safety check generated by Ultimate Automizer from an SV‑COMP 2015 benchmark. It encodes, in 32‑bit bit‑vector arithmetic, a set of linear constraints over three program counters (i, j, k) together with two existentially quantified helper variables, and then asserts the negation of a conjunction of these constraints to test an unreachability property. The problem is a small but non‑trivial BV model with nested existential quantifiers, multiplication by a constant, and several bound constraints, making it a typical quantifier‑rich verification task for industrial‑scale solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/heapsort.i_9.smt2",
    "description": "The instance is a bounded‑model verification query generated by the Ultimate Automizer tool from the SV‑COMP 2023 “heapsort” benchmark. It asks whether, for all 32‑bit integers \\(n\\) in the range [1, 1 000 000], a simple arithmetic relation involving division by 2, multiplication by 2 and a +1 offset can ever produce a value equal to a previously computed constant; the property is encoded as a negated existential formula over bit‑vectors. The problem is purely quantifier‑free apart from three shallow existential blocks, contains only a handful of variables and low term depth (≤ 7), and thus represents a typical industrial software‑verification check for arithmetic overflow or invariant violation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/sum.i_0.smt2",
    "description": "This BV instance encodes a tiny verification condition generated by Ultimate Automizer for an SV‑COMP 2023 benchmark. It asserts that three return‑value variables of the program’s `main` are equal and then checks the negation of an existential statement saying that no two 32‑bit integers exist whose signed‑extended sum (truncated back to 32 bits) equals that common return value. In other words, the solver must decide whether the program’s result can be represented as a signed 32‑bit addition of two operands. The problem is purely quantifier‑free apart from a single existential, involves only three bit‑vector constants, and has very shallow term depth, making it a lightweight arithmetic‑overflow style verification query.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_4-1.c_2.smt2",
    "description": "The instance is a software‑verification condition generated by Ultimate Automizer from an SV‑COMP 2023 C benchmark.  It encodes a bit‑vector arithmetic safety property: a linear combination of three nondeterministic 32‑bit inputs (scaled by constants 8 and 4) added to fixed constants x, z, y must never equal the value 1.  Two universally quantified assertions capture this requirement, with the second one negated to ask whether a counterexample exists; the problem therefore reduces to checking the (un)satisfiability of a quantified BV formula.  The formula is small (three constants, nine BV operations) and shallow (max depth 7), but involves a negated ∀‑quantifier, which makes it a typical quantified BV verification query.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/heapsort.i_3.smt2",
    "description": "This instance is a safety‑property verification condition generated by Ultimate Automizer for a heapsort benchmark taken from the SV‑COMP 2023 industrial suite. It encodes a relationship between a 32‑bit counter and its “primed” successor using signed division and addition, and asserts that no value n in the bounded interval [1, 1 000 000] can simultaneously satisfy the same relation for the primed counter—essentially checking the absence of a counterexample to the loop invariant. The query involves two bit‑vector constants and two existential quantifiers with a modest term depth (7), but the presence of bounded quantification makes it a non‑trivial BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_6-1.c_2.smt2",
    "description": "This instance encodes a safety‑property check generated by the Ultimate Automizer verifier for the SV‑COMP 2023 benchmark **jain_6‑1.c** (industrial category). The formula asserts, via two quantified Horn‑like clauses, that a linear combination of three program constants (x, y, z) and several nondeterministic 32‑bit inputs—scaled by small constants (2, 4, 8)—can never equal the bit‑vector constant 4; the second clause is the negation of a similar universal property, turning the verification condition into a (potentially) unsatisfiable query. The problem resides in the BV logic, features a modest number of variables and a maximum term depth of 7, but includes multiple nested universal quantifiers and many small‑scale bit‑vector multiplications, making it a typical quantified bit‑vector verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_6-1.c_8.smt2",
    "description": "This instance is a safety‑verification problem generated by Ultimate Automizer from an SV‑COMP 2023 C benchmark.  It encodes a 32‑bit bit‑vector assertion that a particular linear combination of program inputs and nondeterministic values must never equal the constant 4; the script asserts the negation of that universal property to ask whether a counterexample exists.  The formula contains a handful of quantified variables (two nested universal quantifiers) and basic BV arithmetic (adds and multiplications), resulting in a modest‑size, quantifier‑rich BV query typical for industrial software model‑checking tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_6-1.c_5.smt2",
    "description": "This instance is a safety‑verification problem generated by Ultimate Automizer from an SV‑COMP 2023 benchmark. The original C program’s assert is encoded as a condition that a linear combination of several 32‑bit variables (including nondeterministic inputs) never equals the constant 4; the formula contains a universal quantifier and a negated universal quantifier (i.e., an ∃) over bit‑vector terms of depth 7. The task is to decide whether the asserted property holds, requiring a solver to handle quantified bit‑vector arithmetic with a modest number of variables but a quantifier alternation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_1-1.c.cil.c_0.smt2",
    "description": "This instance is a software‑verification query generated by Ultimate Automizer for a SV‑COMP 2023 benchmark concerning a floating‑point addition routine (soft_float_1‑1.c). The bit‑vector formula encodes the mantissa manipulation of the addition using existentially quantified 32‑bit variables and checks that a certain derived constant (representing the normalized mantissa) satisfies a safety condition; the final assertion negates a conjunction of two existence statements, turning the check into a verification condition. It features only a few bit‑vector variables, shallow term depth (≤ 8), but includes quantified constraints and bitwise operations, making it a modest‑size, quantifier‑heavy BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/btor2c-eagerMod.bakery.1.prop1-func-interl.c_10.smt2",
    "description": "This SMT‑LIB file encodes a safety‑verification task generated by Ultimate Automizer for an SV‑COMP 2023 benchmark (the “bakery” mutual‑exclusion program).  The goal is to prove that a certain state equality (`state_18 == var_165`) never holds while a collection of bit‑vector mask and arithmetic constraints—modeling the lock’s bit‑wise updates—are satisfied; the property is expressed as a negated assertion so that unsat proves the invariant.  The instance features a BV logic with seven declared 8‑ and 32‑bit variables, ten quantified formulas, very deep terms (depth ≈ 129) and thousands of bit‑vector operations (zero‑extend, extract, bvand, etc.), making it a challenging industrial verification case.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/psyco_abp_1-2.c_2.smt2",
    "description": "This SMT‑LIB file is a tiny safety‑verification query generated by Ultimate Automizer for a C benchmark from the SV‑COMP 2023 industrial suite. It fixes one 32‑bit variable to the constant 6 and asks whether there exists a 32‑bit value that makes a simple bit‑vector equation (the negation of the value plus 1 equals another variable) hold; the formula is negated, so the solver must prove the equation is unsatisfiable. The instance contains only two assertions, two declared bit‑vector constants, a single existential quantifier, and shallow term depth, making it a very small, quantifier‑light verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_4-1.c_11.smt2",
    "description": "This instance encodes a safety‑verification problem for a C benchmark (jain_4‑1.c) from SV‑COMP 2023, generated by the Ultimate Automizer tool. The formulas model the 32‑bit transition relation of three program variables (x, y, z) updated with nondeterministic inputs, and an assertion that a specific linear combination of the updated values must never equal 1. The check consists of a universally quantified property over the nondeterministic inputs (expressing the invariant) together with its negation, yielding a quantified bit‑vector SAT query of moderate size (≈4.5 k characters, term depth 7) that challenges solvers with quantifier instantiation and arithmetic on 32‑bit vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/heapsort.i_0.smt2",
    "description": "This instance is a verification condition produced by Ultimate Automizer for an industrial SV‑COMP benchmark (the “heapsort” program). It asks whether there exists a 32‑bit integer n (bounded between 1 and 1 000 000) such that both (i) n/2 equals a fresh constant c and c > 0, and (ii) c can also be expressed as n/2 + 1; the formula is negated to check the inconsistency. Hence the problem is a quantified bit‑vector safety check involving division, modest term depth, but requiring reasoning about existential quantifiers over bounded ranges.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/sum.i_1.smt2",
    "description": "This instance is a bit‑vector safety‑verification query generated by Ultimate Automizer from an SV‑COMP 2023 benchmark. It encodes a simple C program’s main function, asserting that the three return‑value variables are equal, and then negates the existence of two 32‑bit integers whose signed sum (extended to 64 bits and truncated back) could produce that return value. The solver is asked to check whether this “no‑such‑pair” property holds. The problem is small (3 declared constants, 2 top‑level assertions, a single existential quantifier) and consists mainly of equality, bit‑vector addition with sign‑extension, extraction, and Boolean conjunctions, giving it a shallow term depth and low combinatorial complexity.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-2.c.cil.c_9.smt2",
    "description": "The file encodes a software‑verification condition generated by Ultimate Automizer for a SV‑COMP benchmark that implements a soft‑float addition routine.  It uses 32‑bit bit‑vectors to model mantissa extraction (via masks and bitwise‑or/and) and the subsequent shifted addition, asserting that a certain guard is non‑zero and then checking—through a negated existential formula—whether any choice of the two input operands and a delta can make the computed mantissa equal a right‑shifted sum.  The query therefore tests a safety/property of the floating‑point addition implementation and features three quantified 32‑bit variables with bit‑wise and shift operations (moderate term depth but non‑trivial quantifier reasoning).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_1-1.c.cil.c_2.smt2",
    "description": "The instance encodes a safety verification condition for a software implementation of floating‑point addition (the “soft_float” benchmark).  It asserts that there exist 32‑bit bit‑vector values for the two operand mantissas and a shift amount that satisfy the expected mantissa‑extraction formulas, and then checks that **no** choice of those values makes the computed result of the addition‑plus‑right‑shift equal the stored mantissa constant.  The formula uses only bit‑vector operations (and, or, shift, add) with three existential quantifiers and a top‑level negated existential, resulting in a modest-sized BV problem (≈2 kB, depth 9) drawn from the Ultimate Automizer SV‑COMP 2023 industrial benchmark suite.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/btor2c-eagerMod.bakery.1.prop1-func-interl.c_2.smt2",
    "description": "This SMT‑LIB file is a safety‑verification instance produced by Ultimate Automizer from an SV‑COMP 2023 benchmark that models a “bakery” lock implementation. The goal is to prove that a bit‑vector invariant (expressed via a large collection of masked bvand/bvor/bvnot operations on 8‑bit states and inputs) never violates a mutual‑exclusion property, which is encoded as a negated disjunction of quantified formulas. The problem features ten quantified variables, deep nesting (term depth ≈ 129), and a heavy use of zero‑extension, extraction, and bit‑masking, making it a demanding bit‑vector verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/linear-inequality-inv-a.c_6.smt2",
    "description": "This SMT‑LIB file is a software‑verification query generated by Ultimate Automizer for an SV‑COMP 2023 benchmark (the C program *linear‑inequality‑inv‑a.c*). It encodes a bit‑vector invariant: a 32‑bit variable must equal the sum of two zero‑extended 8‑bit values, while the formula asserts that it cannot simultaneously be represented as a sum of four, five or six such byte‑values—expressed with several existential quantifiers and a single negated conjunct. The instance is a typical BV‑logic verification problem with shallow term depth, a handful of quantified variables, and is aimed at checking that a linear‑inequality invariant holds across program executions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-1.c.cil.c_7.smt2",
    "description": "This instance encodes a software‑verification condition generated by Ultimate Automizer for a C benchmark involving a soft‑float addition routine. The query checks that, for all possible 32‑bit inputs (modelled with existentially quantified bit‑vectors representing mantissas), the computed result of the normalized addition (including shifting, masking and rounding) can never equal a specific masked value; this is expressed by a negated existential (i.e., a universal) property together with a simple signed‑greater‑or‑equal assertion used to model an `assert`. The problem is a relatively small BV verification task (5 declared constants, a handful of quantified variables, max term depth 9) typical of SV‑COMP industrial benchmarks, relying on bit‑vector arithmetic and logical operators rather than deep quantifier alternations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_1-1.c.cil.c_9.smt2",
    "description": "This BV instance encodes a software‑verification condition for a 32‑bit floating‑point addition routine that has been translated into bit‑vector operations by Ultimate Automizer (SV‑COMP 2023 benchmark). It asserts that there exist operand and delta values making a specific constructed expression equal to a constant, and simultaneously claims that no such values can make the same expression shifted right by one equal that constant—i.e., it checks a safety/rounding property of the addition implementation. The formula contains only two simple existential quantifier blocks, basic bit‑vector ops (and, or, add, shift), and is relatively small but involves non‑trivial term depth, typical of automated verification tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_6-1.c_7.smt2",
    "description": "This SMT‑LIB file encodes a software verification task generated by Ultimate Automizer from the SV‑COMP 2023 benchmark *jain_6‑1.c*.  The query models a small transition system over 32‑bit variables (including nondeterministic “aux” inputs) and checks that a `VERIFIER_assert` condition is preserved across the transition; the final `(assert (not (= … 1)))` asks the solver to refute a violation of that condition.  The instance uses only bit‑vector arithmetic but involves a couple of universally quantified variables and several nested multiplications/additions, giving a moderately deep term structure (depth 8) with 12 declared constants.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_6-1.c_10.smt2",
    "description": "This benchmark is a BV‑logic verification condition generated by Ultimate Automizer from an industrial SV‑COMP 2023 C program. It asserts that a certain program‑assertion variable is non‑zero and that a linear combination of several nondeterministic 32‑bit inputs (multiplied by constants 2, 4, 8) never equals the constant 4; the second clause negates a similar universally quantified property, turning the check into “does there exist a choice of inputs that violates the assertion?”. The formula therefore contains a single quantifier alternation (∃ ¬∀) with up to six quantified variables, modest term depth (≤ 7) and only simple bit‑vector arithmetic, resulting in a typical quantified‑BV verification query.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-2.c.cil.c_3.smt2",
    "description": "This instance is a bounded‑model‑checking query generated by Ultimate Automizer for a SV‑COMP 2023 benchmark that implements a software “soft‑float” addition routine. It models the extraction and normalization of the mantissas of two 32‑bit floating‑point values with bit‑vector masks and then asserts—via a negated existential—that no choice of inputs and a delta can make the shifted sum equal a previously computed constant, i.e., it checks a correctness property of the addition algorithm. The problem is a quantified bit‑vector verification task (few variables, moderate term depth) originating from an industrial C program, and the solver must prove the formula unsatisfiable to validate the property.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-1.c.cil.c_9.smt2",
    "description": "This instance is a software‑verification condition generated by Ultimate Automizer for a SV‑COMP 2023 benchmark that implements a soft‑float addition routine. The formula asserts basic equalities between bit‑vector representations of the operands and the result, then checks that no choice of the auxiliary variables (representing rounding‑related shifts and mantissa masks) can make a certain shifted sum equal a masked value—i.e., it verifies a safety property of the floating‑point addition implementation. It is a quantified BV problem (three existential quantifiers) with bitwise‑and,‑or, logical shifts and addition, of moderate size (≈2 KB) and depth 9, typical of industrial verification tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_6-1.c_9.smt2",
    "description": "This instance is a safety‑verification query generated by Ultimate Automizer from an SV‑COMP 2023 C benchmark. It encodes a 32‑bit bit‑vector model of a function that reads several nondeterministic inputs and asserts that a particular expression is non‑zero; the formula then checks, via two universal quantifiers, whether the asserted condition can be violated by any choice of those inputs. The problem is a quantified bit‑vector safety check with a handful of variables, moderate term depth (≤7), and only a few arithmetic constraints, characteristic of industrial software‑verification instances.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/btor2c-eagerMod.bakery.1.prop1-func-interl.c_4.smt2",
    "description": "This instance is a software‑verification benchmark generated by Ultimate Automizer for an SV‑COMP 2023 case (the “bakery” concurrent algorithm). It encodes a safety property as a quantified bit‑vector formula over 8‑ and 32‑bit values, asserting that a certain combination of state bits, input bytes and mask constants must never equal the zero vector (the final `(not (forall …))` is the negated safety invariant). The problem features a dense network of zero‑extensions, extracts, bitwise‑and/or/not and a few multiplications, with ten quantified variables and a maximum term depth of 129, making it a challenging quantifier‑heavy BV verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-2a.c.cil.c_9.smt2",
    "description": "This instance is a BV‑logic safety‑verification check generated by Ultimate Automizer from an SV‑COMP 2023 benchmark that models a software floating‑point addition routine with bit‑vector masks and shifts (simulating mantissa extraction). It asserts that, after extracting the 23‑bit mantissas of two operands, shifting the second operand by a delta and adding the results, the left‑shifted sum can never equal a specific shifted value – a property expressed by a negated existential quantifier. The problem involves only four bit‑vector constants, three existential quantifiers, and shallow term depth, making it a relatively small but non‑trivial verification query.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/btor2c-lazyMod.fischer.1.prop1-back-serstep.c_2.smt2",
    "description": "This SAT instance comes from the Ultimate Automizer tool applied to a SV‑COMP 2023 benchmark (the C file *lazyMod.fischer*).  It encodes a safety‑property check on a low‑level bit‑vector program: the assertions state that a certain 8‑bit “state” variable can never become zero while three input bytes are non‑zero and a 32‑bit counter variable respects specific masked multiplication/addition invariants.  The formula is pure bit‑vector logic with many nested bvand, zero_extend and extract operations, ten universal quantifiers over dozens of 8‑bit variables, and deep term nesting (depth 56), which together make the instance a challenging industrial verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_4-1.c_4.smt2",
    "description": "This instance is a software‑verification query generated by Ultimate Automizer from an SV‑COMP 2023 C benchmark. It encodes an assertion that a linear combination of four 32‑bit program variables (including several nondeterministic inputs) never equals the constant 1; the property is expressed with a universal quantifier asserting inequality, while the surrounding assertions enforce the condition and then look for a counterexample by negating a similar universal statement. The problem lives in the BV logic, features two quantifier alternations over a handful of bit‑vector terms (depth 7, nine bvmul operations), and therefore represents a small but quantified bit‑vector verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-2.c.cil.c_4.smt2",
    "description": "This instance is a verification condition generated by Ultimate Automizer from an SV‑COMP 2023 industrial benchmark that models a tiny software routine for floating‑point addition using raw 32‑bit bit‑vectors. It defines three existentially quantified bit‑vectors that represent masked mantissa and exponent fields, relates them through bitwise‑and/or, shifts and an addition, and finally asserts (negated) that the resulting expression can never equal a pre‑computed constant—i.e., it checks that a certain overflow/rounding property does not hold. The problem is a modest‑size BV‑SAT check with a few existential quantifiers and shallow term depth (≈9), focusing on bit‑level arithmetic rather than large numbers of variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_2-2.c_0.smt2",
    "description": "The instance is a bit‑vector verification problem generated by Ultimate Automizer from an SV‑COMP 2023 C benchmark. It encodes a simple arithmetic property: a linear combination of two constant 32‑bit inputs and several nondeterministic 32‑bit variables (all multiplied by 2) must never equal the constant 1 (universal claim), while simultaneously asserting that there is a choice of two of those nondeterministic variables that makes the same combination equal 1 (existential claim, expressed via a negated ∀). The clash of a universal and an existential condition creates a quantified contradiction, making the formula unsatisfiable; the problem features a modest number of variables but involves quantifier alternation that can be challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_1-1.c.cil.c_3.smt2",
    "description": "This instance encodes a software‑verification condition for a floating‑point addition routine, translated by Ultimate Automizer into 32‑bit bit‑vector arithmetic (masking, shifting and adding). The formula asserts a set of concrete bit‑vector relationships derived from the program and then checks the negation of an existential statement, i.e., it asks whether there exists any choice of the original inputs that would make a derived “mantissa‑combination” expression equal to a shifted sum. The problem originates from an SV‑COMP 2023 benchmark, features only a handful of variables and shallow terms, but the presence of a quantified existential makes it a non‑trivial verification query for BV‑solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_7-1.c_3.smt2",
    "description": "This instance encodes a safety‑verification problem for a small C benchmark (SV‑COMP 2023) that was transformed by Ultimate Automizer into a quantified bit‑vector formula. The core property asserts that a linear combination of several 32‑bit program variables and nondeterministic inputs can never equal the constant 0x00100000; the script checks the negation of this universally quantified condition to discover a potential assertion failure. The problem is in the BV logic, contains only a handful of quantified variables, modest term depth (≤ 9) and a small number of arithmetic operations, making it a typical quantified‑BV verification query rather than a large‑scale industrial synthesis or scheduling task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/btor2c-lazyMod.protocols.1.prop1-func-interl.c_0.smt2",
    "description": "This SMT‑LIB file is a bit‑vector encoding of a safety‑checking problem generated by **Ultimate Automizer** for an SV‑COMP 2023 benchmark (industrial C code with many byte‑wide variables, masks and bitwise updates).  The formula represents the transition relation of the program (primed “next‑state” variables) together with an `assert`‑condition (`c_ULTIMATE.start___VERIFIER_assert_~cond`) that must remain true for all possible 8‑bit inputs, and it is closed by a final `check‑sat` that expects the condition to hold.  The instance is large (≈ 715 constants, > 160 k AST nodes, max term depth 80) and contains numerous nested `extract`, `zero_extend`, `bvand`/`bvor` expressions and a few existential quantifiers, making it a challenging bit‑vector verification case for SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_7-1.c_5.smt2",
    "description": "This instance is a safety‑verification problem generated by Ultimate Automizer from an SV‑COMP 2023 benchmark.  It encodes the transition relation of a C function that updates three 32‑bit variables (x, y, z) with large constant multipliers and nondeterministic inputs, and it checks whether a `__VERIFIER_assert` condition can ever be violated.  The encoding uses universal quantifiers over the nondeterministic values together with straight‑line bit‑vector arithmetic (adds, multiplies, negations) and an `ite` for the assert condition, making the core difficulty the handling of quantified BV arithmetic rather than sheer size (12 constants, depth 10, modest term count).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_7-2.c_1.smt2",
    "description": "This SMT‑LIB file is a verification condition produced by Ultimate Automizer for an SV‑COMP 2023 C benchmark (jain_7‑2.c). It encodes a safety property stating that a certain linear combination of the program’s 32‑bit inputs (including three nondeterministic variables) can never equal the constant 2²⁰; the property is expressed with a universal quantifier and its negation (i.e., an existential counterexample). The instance involves only a handful of bit‑vector constants and multiplications by fixed powers of two, but the presence of quantified bit‑vector arithmetic makes the solving task non‑trivial despite its modest size (≈ 3 kB, two quantified assertions).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_7-1.c_2.smt2",
    "description": "This instance is a software‑verification query generated by Ultimate Automizer from the SV‑COMP 2023 benchmark suite (the C program *jain_7‑1.c*).  The model checks that a `__VERIFIER_assert` can never be violated: it encodes the program’s integer variables as 32‑bit bit‑vectors, updates the “primed” state with linear arithmetic (adds and multiplications by constant factors), and represents nondeterministic inputs with existentially quantified bit‑vector variables.  The solver is asked to prove unsatisfiability of a transition that could produce a state where the asserted condition is false, leading to a pure‑exists quantified BV problem of moderate size (12 constants, depth 9) typical for automata‑based safety verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_6-1.c_11.smt2",
    "description": "This instance is a safety‑verification query generated by Ultimate Automizer for a C benchmark (jain_6‑1.c) taken from the SV‑COMP 2023 competition.  It encodes the program’s transition relation with 32‑bit bit‑vector variables, nondeterministic “aux” inputs, and the condition of an `__VERIFIER_assert`.  The final formula asks whether there exists a reachable state that violates the assertion, using quantified constraints and several non‑linear bit‑vector multiplications, which makes the problem moderately challenging despite the relatively small number of constants.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_4-1.c_7.smt2",
    "description": "This instance is a safety‑verification query generated by Ultimate Automizer from an SV‑COMP 2023 C benchmark. It encodes the effect of three nondeterministic updates to 32‑bit variables x, y, z and asserts that a specific linear combination of the updated values must equal 1; a final clause forces the negation of that assertion, turning the check into a reachability‑of‑error problem. The formula uses only bit‑vector arithmetic but includes two universal quantifiers over the nondet inputs, giving a modestly quantified, medium‑depth BV problem typical of automated software‑model‑checking tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_2-2.c_10.smt2",
    "description": "This instance encodes a verification condition for a small C benchmark (jain_2‑2.c) generated by Ultimate Automizer for SV‑COMP 2023.  It models a transition with two 32‑bit variables updated by nondeterministic increments, defines an assertion that the sum of the updated variables is never equal to 1, and then asks whether there exists a combination of nondeterministic choices that can make a related summed expression equal to 1, using quantified Boolean formulas over bit‑vectors.  The problem is a reachability / assertion‑violation check with a few quantified variables and moderate term depth, typical of industrial software‑verification queries.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/linear-inequality-inv-a.c_0.smt2",
    "description": "This benchmark is a bit‑vector verification condition generated by Ultimate Automizer from an SV‑COMP 2023 C benchmark. It asserts that a 32‑bit constant equals the sum of four zero‑extended 8‑bit variables and then checks (by negating another existential) that no different collection of five such variables can yield the same sum, i.e., it encodes a linear‑inequality invariant about the uniqueness of the decomposition. The instance features only a handful of 8‑bit variables, shallow term depth (≤ 6), and a single existential quantifier block, resulting in a small but quantifier‑rich BV‑logic check.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_2-2.c_3.smt2",
    "description": "This benchmark encodes a software‑verification safety check generated by Ultimate Automizer from the SV‑COMP 2023 C benchmark *jain_2‑2.c*.  It asserts that a bit‑vector expression involving additions and double‑multiplications of three program variables can never be equal to 1 for any nondeterministic values, and then negates a similar universally‑quantified condition to test the assertion.  The problem is a quantified bit‑vector safety verification with a handful of variables, shallow term depth (≤ 7) and two forall quantifiers, characteristic of the industrial verification instances produced by Ultimate Automizer.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_7-1.c_9.smt2",
    "description": "This instance encodes a safety‑verification problem generated by Ultimate Automizer from an SV‑COMP 2023 C benchmark. It asks whether a bit‑vector assertion in the original program can be violated: a quantified linear combination of several nondeterministic 32‑bit inputs (involving many multiplications by large constants) may ever equal the constant 1 048 576, and whether the program’s “assert” condition can become non‑zero. The formula is pure BV with two nested forall‑quantifiers, moderate term depth (9) and a handful of large‑scale affine constraints, making it a typical industrial BV‑verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_6-1.c_1.smt2",
    "description": "The file is a bit‑vector safety verification condition generated by Ultimate Automizer from an SV‑COMP 2023 C benchmark. It asserts that, for all possible 32‑bit nondeterministic values of several program variables, a weighted sum (a series of `bvmul` and `bvadd` operations involving three fixed constants) can never be equal to the constant 4, and then negates a similar universally‑quantified equality to express the existence of a counterexample. The presence of quantified bit‑vectors and multiple multiplication terms makes the instance a non‑trivial BV‑logic check typical of automated software model‑checking encodings.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/btor2c-eagerMod.cambridge.1.prop2-func-interl.c_2.smt2",
    "description": "This benchmark is a software‑verification instance generated by Ultimate Automizer from an SV‑COMP 2023 C benchmark. It encodes the semantics of the program in 8‑bit bit‑vectors and checks a safety property that a complex masked state expression (built from many nested bvand, bvor, bvnot, extract and zero‑extend operations) must equal a specific program variable; the property is asserted both directly and under a negated universal quantifier. The formula is large (≈26 k nodes) with very deep term nesting and numerous bit‑vector manipulations, making it a hard BV‑logic verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/btor2c-eagerMod.bakery.1.prop1-func-interl.c_11.smt2",
    "description": "This instance is a safety‑checking condition generated by the Ultimate Automizer tool for a SV‑COMP 2023 benchmark (the “bakery” mutual‑exclusion program).  It encodes a bit‑vector model of the program’s state using 8‑bit variables extended to 32 bits and asserts that a particular state equality (the “critical‑section” flag) never holds, together with several universally quantified mask‑and‑multiplication invariants that capture the algorithm’s bitwise updates.  The formula contains seven deep, highly nested bit‑vector expressions (max term depth ≈ 129) and ten‑variable universal quantifiers, making it a demanding industrial verification problem for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-2.c.cil.c_10.smt2",
    "description": "The instance is a software‑verification condition generated by Ultimate Automizer for a floating‑point routine (soft_float_4‑2.c) from the SV‑COMP 2023 benchmark suite. It encodes the semantics of a mantissa‑addition step using 32‑bit bit‑vectors, bit‑masking, logical OR/AND and logical right‑shifts, and asserts that no choice of input operands and shift amount can make a particular equality hold—i.e., it checks a safety property of the floating‑point implementation. The formula contains a few existential quantifiers over the three 32‑bit inputs, moderate term depth (≤ 9) and only a handful of variables, making it a compact yet quantifier‑rich BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_4-1.c_5.smt2",
    "description": "This instance is a software‑verification condition generated by Ultimate Automizer from an SV‑COMP 2023 benchmark. It encodes, in the BV logic, a safety assertion that a linear combination of program variables and several nondeterministic 32‑bit inputs (scaled by small constants) must never equal the constant 1; the condition is asserted true and then its negation is quantified to test for a counterexample. The formula features two universal quantifiers, bit‑vector addition and multiplication, and a modest term depth, making it a typical quantifier‑heavy verification query.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/btor2c-eagerMod.vis_arrays_vsa16a_p6.c_5.smt2",
    "description": "This SMT‑LIB file is a safety‑verification query produced by the Ultimate Automizer tool from an SV‑COMP 2023 benchmark. It encodes, with quantified 8‑bit bit‑vectors, a property that a masked combination of the program’s state, a counter variable and a constant mask can never equal a particular value (the equality of the state and a reference variable is asserted at the end). The formula contains many nested `zero_extend`, `extract`, bitwise (`bvand`, `bvor`, `bvnot`) and shift/add operations, several universal quantifiers and a deep term structure (depth ≈ 54), making it a demanding BV‑logic verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-2.c.cil.c_6.smt2",
    "description": "The instance encodes a verification condition for a 32‑bit software implementation of floating‑point addition (the “soft_float” benchmark).  Using bit‑vector operations that extract and combine mantissa and exponent fields (shifts, masks, adds, and bitwise ors/ands), it asserts a set of relationships between the pre‑state values and their primed post‑state counterparts, and then negates an existential query that would witness a violation of those relationships.  The problem, generated by Ultimate Automizer from an SV‑COMP 2023 benchmark, is a single‑quantifier BV‑satisfiability check (unsat ⇔ the addition routine satisfies the intended invariant), with a modest number of variables and shallow term depth.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_6-1.c_4.smt2",
    "description": "This instance is a bounded‑verification query generated by Ultimate Automizer for the SV‑COMP 2023 benchmark *jain_6‑1.c*.  It encodes a 32‑bit bit‑vector program with several nondeterministic inputs and asserts that a particular linear combination of those inputs and the program’s initial variables can never equal the constant 4 – an encoding of a `VERIFIER_assert` condition.  The formula contains a handful of universally quantified variables and a single outer negated forall, yielding a modest term depth (7) and a small number of symbols, making it a typical industrial software‑verification problem that checks for the existence of a counterexample to the asserted invariant.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_4-1.c_1.smt2",
    "description": "This instance is a software‑verification condition generated by Ultimate Automizer from the SV‑COMP 2023 C benchmark “jain_4‑1.c”. It encodes a quantified bit‑vector property: for all nondeterministic 32‑bit inputs a certain linear combination (using additions and multiplications by small constants) must never equal the constant 1, while a second clause asserts the opposite (i.e., there exists an input making the sum equal 1). The formula consists of only a handful of bit‑vector variables, shallow term depth (7), and a single quantifier alternation, yielding a small but non‑trivial quantified BV benchmark whose satisfiability check reduces to proving the contradiction between the two assertions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-1.c.cil.c_8.smt2",
    "description": "This instance is a bounded‑model‑checking verification condition generated by Ultimate Automizer from an SV‑COMP 2023 industrial benchmark (soft‑float addition). It encodes the mantissa manipulation of a 32‑bit floating‑point add using bit‑vector masks, addition, logical‑or/and and logical right‑shifts, and asserts that a certain existential combination of inputs cannot make the shifted result equal a given constant (i.e., the negated existential expresses a universal safety property). The formula contains a modest number of bit‑vector constants (six) and three nested existential quantifiers (giving a single quantifier alternation) with term depth up to 9, making it a small but non‑linear BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_1-2.c.cil.c_6.smt2",
    "description": "This instance is a BV‑encoded verification condition generated by Ultimate Automizer for a floating‑point addition routine taken from the SV‑COMP 2023 benchmark suite. It asserts that certain masked/or’ed bit‑vector representations of the two operands exist, and then checks that no choice of operands and a delta value can make a derived expression (involving addition, shifts and masking) equal a previously computed constant – essentially a correctness/overflow property of a soft‑float implementation. The formula contains only existential quantifiers, a moderate term depth (9) and a small number of variables, making it a typical, relatively compact industrial verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/heapsort.i_2.smt2",
    "description": "This instance encodes a software‑verification condition generated by Ultimate Automizer for a heapsort benchmark from SV‑COMP 2023. It checks, using 32‑bit bit‑vector arithmetic, that for any input size n bounded by 1 000 000 the derived values l = ⌊n/2⌋+1 and r = n satisfy a certain arithmetic property; the formula asserts the negation of an existential statement that would violate this property. The problem involves only three variables, shallow term depth (≤ 7), and a single existential quantifier, making it a relatively small, quantifier‑heavy BV verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-2.c.cil.c_7.smt2",
    "description": "This instance is a safety‑property verification condition generated by Ultimate Automizer for the SV‑COMP 2023 benchmark “soft_float_4‑2.c”. It encodes a soft‑floating‑point addition using 32‑bit bit‑vectors, with existentially quantified variables representing input mantissas and exponents; the main check asserts that no assignment can make the derived mantissa equal to a shifted, added combination of the inputs, i.e., it verifies that a certain assert in the source program cannot be violated. The formula contains only BV operations (bitwise and, or, shift, add) and three existential quantifiers, giving a modest term depth (9) but requiring a solver to handle quantified bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_6-1.c_6.smt2",
    "description": "This instance encodes a safety‑verification task for a 32‑bit C benchmark (jain_6‑1.c) taken from SV‑COMP 2023.  Ultimate Automizer translates the program into a bit‑vector transition system with primed (post‑state) and unprimed (pre‑state) variables, introduces nondeterministic inputs, and asserts that a certain arithmetic condition (the VERIFIER_assert) must always hold.  The final formula contains universally quantified nondet variables together with a negated ∀ to express the existence of a counter‑example; the solver is asked to decide satisfiability, i.e., whether the asserted property can be violated.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/heapsort.i_6.smt2",
    "description": "This benchmark encodes a small arithmetic verification task generated by Ultimate Automizer from an SV‑COMP 2023 benchmark (industrial category). It asks whether, for some 32‑bit integer n with 1 ≤ n ≤ 1 000 000, the value l computed as (n ÷ 2) + 1 can hold, while simultaneously checking that no n in the same range can satisfy l = (n ÷ 2). The formula uses only bit‑vector arithmetic, a single quantified variable and shallow terms (depth ≤ 6), resulting in a relatively simple instance with two existential assertions and a negated existential, typical of software‑verification invariant checks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-1.c.cil.c_1.smt2",
    "description": "This BV instance encodes a verification condition for a C routine that implements a 32‑bit “soft‑float” addition operation.  The formula asserts, via a pair of existentially‑quantified auxiliary values and a final negated existential, that after certain updates (incrementing a counter and shifting a mantissa) the relation “a is not less than b” must hold for all possible inputs, which translates to checking the unsatisfiability of a quantified bit‑vector inequality.  It is an industrial benchmark from SV‑COMP 2023 generated by Ultimate Automizer, featuring a modest number of constants and a shallow term depth but includes quantifier alternation that makes the problem non‑trivial for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_1-1.c.cil.c_10.smt2",
    "description": "This instance is a verification condition generated by Ultimate Automizer from a SV‑COMP 2023 benchmark that implements a software routine for floating‑point addition using bit‑vector arithmetic (the “soft_float” benchmark). The formula asserts that there exist bit‑vector values representing the mantissas and exponent‑adjustment of the two operands such that the constructed result matches the expected mantissa fields, and then checks that no combination of those operands can make the final shifted‑add expression equal to the previously derived mantissa – i.e., it encodes a safety property of the floating‑point addition implementation. The problem is a pure BV check with a handful of 32‑bit variables, a few nested existential quantifiers, moderate term depth (≤9), and no alternation of quantifiers, making it a relatively small but non‑trivial bit‑vector verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_2-2.c_9.smt2",
    "description": "This instance is a software‑verification condition generated by Ultimate Automizer for the SV‑COMP 2023 benchmark *jain_2‑2.c*. It encodes, in 32‑bit bit‑vector arithmetic, two universally quantified safety properties about linear combinations of the program’s inputs (modeled as nondeterministic bit‑vectors) and asserts that a verifier‑generated condition must be non‑zero; the overall query asks whether the negation of one of these universals is satisfiable, i.e., whether the original assertion can be violated. The problem features a small set of quantified variables, moderate term depth (7), and only bit‑vector operations (addition, multiplication), making it a typical bounded‑model‑checking instance with a single quantifier alternation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-2a.c.cil.c_10.smt2",
    "description": "This instance encodes a verification condition for a software implementation of floating‑point addition (the “soft_float” benchmark from SV‑COMP 2023).  Using 32‑bit bit‑vectors, it introduces existentially quantified variables that represent the mantissa components and the rounding shift of the addition, and asserts that the computed result must satisfy the intended relationship; the final clause negates the existence of a state where a right‑shifted sum equals the previously stored mantissa, thus checking a rounding/overflow invariant.  The problem is a quantified BV verification query generated by Ultimate Automizer, with a modest number of variables, shallow term depth (≤ 9), and a mix of bitwise, shift, and addition operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/linear-inequality-inv-a.c_5.smt2",
    "description": "This instance encodes a verification condition generated by Ultimate Automizer for a C benchmark from SV‑COMP 2023. It asks whether a 32‑bit value can simultaneously be expressed as the sum of three zero‑extended 8‑bit variables (existentially quantified) and **not** be expressible as the sum of six zero‑extended 8‑bit variables (the negated existential). The problem is a pure bit‑vector linear‑inequality check with only existential quantifiers, a handful of 8‑bit variables, shallow term depth, and therefore represents a small‑scale industrial invariant‑verification query.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-2a.c.cil.c_8.smt2",
    "description": "This instance is a software‑verification query generated by Ultimate Automizer from an SV‑COMP 2023 benchmark (category “industrial”). It encodes a safety property of a floating‑point addition routine using 32‑bit bit‑vectors: three constants are defined as masked versions of input words, and the final check asserts that no choice of inputs and a “delta” value can make a certain shifted‑add expression equal to one of the masked constants. The problem is expressed in BV logic with three existential quantifiers and a modest term depth (≈9), making it a relatively small but quantifier‑rich verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_7-1.c_0.smt2",
    "description": "This instance is a bit‑vector safety‑verification query generated by Ultimate Automizer from an SV‑COMP 2023 C benchmark. It encodes a property that a certain linear combination of program constants and nondeterministic 32‑bit variables must never equal the constant 1048576; the property is expressed with two universal quantifiers (one asserted, one negated) over several nondeterministic variables, using only multiplication by small constants, addition, and negation. The formula is modest in size (≈3 KB, depth 9) but its quantified arithmetic makes it non‑trivial for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_7-1.c_4.smt2",
    "description": "This instance is a BV‑based software‑verification problem generated by Ultimate Automizer from an SV‑COMP 2023 C benchmark (industrial category). It encodes a safety claim that a verifier‑assertion must hold and that a linear combination of the program’s variables x, y, z together with three nondeterministic inputs can never equal the constant 1 048 576. The property is expressed with quantified bit‑vector arithmetic (two universal quantifiers, one of which is negated to introduce an existential check) and involves several large‑scale multiplications, giving a moderate term depth (9) and a quantifier‑alternation pattern that makes the benchmark challenging for quantifier‑capable solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_1-1.c.cil.c_6.smt2",
    "description": "This instance is a bounded‑verification query generated by the Ultimate Automizer tool for an SV‑COMP 2023 industrial benchmark (a C program that implements a soft‑float addition routine). It encodes the arithmetic of a 32‑bit floating‑point addition using bit‑vector operations (shifts, bitwise and/or, addition) and checks, via a negated existential, that a certain relationship between the reconstructed mantissa/exponent parts and the rounded sum can never hold—i.e., it tries to prove a correctness/invariant property of the addition implementation. The problem involves a modest number of 32‑bit bit‑vectors (four constants and three quantified variables), a maximum term depth of nine, and only existential quantifiers (effectively a universal property), making it a typical quantifier‑heavy BV verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/Primes.c_3.smt2",
    "description": "This BV instance originates from Ultimate Automizer’s verification of a SV‑COMP 2023 benchmark (industrial code). It asserts that the result of computing 4·x + 1 for an unknown 32‑bit input x cannot also be expressed as 6·y + 1 for any 32‑bit value y, i.e., it checks the non‑existence of an alternative witness for the same output. The formula contains only two quantified‑free bit‑vector constants, a single negated existential (equivalently a universal) condition, and shallow terms (depth ≤ 6), making it a small, quantifier‑only verification query.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/btor2c-eagerMod.unsafe_arbitrated_fifos_n2d8w8.c_1.smt2",
    "description": "This instance is a safety‑verification condition generated by Ultimate Automizer for an industrial C benchmark from SV‑COMP 2023 (the “unsafe arbitrated FIFOs” program). It encodes, in the BV logic, a property that a masked combination of several 8‑bit state and input variables must always evaluate to zero; the property is expressed with nested bit‑wise operators (zero‑extend, extract, bvand, bvor, bvnot) and wrapped in three universal quantifiers, while the outermost assertion negates the intended invariant to test for a counterexample. The formula is relatively small (four declared bit‑vectors, two assertions) but has a deep term structure (depth ≈ 48) and quantified bit‑vector arithmetic, making it a challenging instance for solvers that handle quantifiers and heavy bit‑wise reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvadd_x_s_4.smt2",
    "description": "This instance encodes a verification condition for 4‑bit vector addition: it asserts that a trivially true predicate `CC` must be distinct from the existence of a value `x` (constrained by a mask‑based “between” relation on the given bounds `xlo`/`xhi`) together with a literal constraint `x + s = t`. In other words, the solver must show that the quantified existential formula is unsatisfiable, i.e., no `x` and `s` can satisfy the mask and addition constraints for any choice of `t`, `xlo`, `xhi`. The benchmark is a handcrafted verification case (from Preiner & Niemetz, FMCAD 2020) with a single existential quantifier over 4‑bit vectors, a handful of auxiliary definitions (count‑trailing/leading‑zero functions) that are unused, and modest term depth (7) but enough bit‑vector reasoning to challenge quantifier‑aware solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvashr_x_s_32.smt2",
    "description": "This is a crafted BV‑verification benchmark from the FMCAD 2020 paper by Preiner and Niemetz, meant to check the consistency of two characterisations of a 32‑bit arithmetic right‑shift expression under a mask constraint. The model defines explicit count‑leading/trailing‑zero functions (via deep nested ite‑chains) and a predicate CC that depends on whether the shift result t is all‑zero or all‑one, otherwise bounding a witness by leading‑zero counts; the final assertion asks whether CC differs from the existence of a masked value x and a shift amount s such that (bvashr x s) = t. The problem features a handful of 32‑bit constants, several exists quantifiers, and high term depth (≈35), making it a non‑trivial bit‑precise verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvult_x_s_32.smt2",
    "description": "This instance encodes a crafted bit‑vector consistency check: it declares four 32‑bit variables and defines a set of helper functions (including explicit bit‑wise implementations of count‑trailing‑zeros/leading‑zeros). The core property asserts that a simple predicate CC (which merely requires xlo ≠ ‑1) must be distinct from the existence of a value x within the interval [xlo, xhi] (captured by mcb) that is strictly lower than some bound s; the model must also satisfy a validity condition on xlo/xhi. The solver is therefore asked to find a counterexample to this consistency condition, involving only a single existential quantifier but deep term nesting from the handcrafted ctz/clz definitions, making the problem a bit‑precise verification of operator semantics rather than a large‑scale search.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_concat_s_x_32.smt2",
    "description": "This instance encodes a crafted bit‑vector consistency check (FMCAD 2020) in the 32‑bit BV logic. It verifies that a mask predicate on a word tx (requiring tx to be bounded by the bit‑masks xlo and xhi) cannot be simultaneously satisfied by another word x that, together with some auxiliary word s, reproduces the same 64‑bit concatenation as the given pair (ts,tx). The formula contains a single existential quantifier, four 32‑bit constants and deep, ite‑based definitions of count‑trailing/leading‑zero functions, yielding a relatively low variable count but high term depth that stresses bit‑precise solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvshl_x_s_32.smt2",
    "description": "This instance is a crafted BV‑logic verification query from the FMCAD‑2020 benchmark suite. It encodes a consistency condition for 32‑bit shift‑left operations: one predicate (`CC`) uses a count‑trailing‑zeros bound together with a mask‑containment property (`mcb`), while the other directly asserts the existence of a value and shift amount whose left‑shift yields the target term `t`. The solver is asked to find a model where the two predicates differ, i.e., to prove (or refute) that the derived `CC` condition is equivalent to the literal shift specification under the given mask constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvxor_x_s_32.smt2",
    "description": "This crafted BV‑logic instance encodes a verification condition for a bit‑vector operator: it asserts that the “consistency condition” CC(t,xlo,xhi) (trivially true) must be different from the existence of a pair (x,s) that both satisfies a mask constraint mcb(xlo,xhi,x) (i.e., x is bounded between xlo and xhi) and makes t equal to x ⊕ s. The problem thus checks whether a particular xor‑based relation can be satisfied under the given low/high mask bounds. Although it contains only four 32‑bit variables, the formula includes deep nested ite chains for ctz/clz definitions (unused elsewhere) and a single existential quantifier, giving a moderate term depth (≈35) that can challenge solvers on quantifier handling and large‑depth Boolean reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvuge_s_x_64.smt2",
    "description": "This instance is a crafted verification problem from the FMCAD 2020 paper on bit‑precise reasoning. It checks a consistency condition for a bit‑vector “mask‑constrained” interval: given a pair (xlo,xhi) that satisfies the invariant bvor(¬xlo, xhi)=all‑ones, it asserts that there is **no** 64‑bit value x inside the interval (i.e. bvand xhi x = x ∧ bvor xlo x = x) together with any 64‑bit s that is unsigned‑greater‑or‑equal to x. The core formula is a simple “true ≠ (exists …)” Boolean assertion, but the file contains many auxiliary definitions (ctz, clz, etc.) built with deep nested ite and extract constructs, giving the benchmark a high term‑depth (67) and a large number of bit‑extractions despite having only two top‑level asserts.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvand_x_s_4.smt2",
    "description": "This instance encodes a crafted verification check for a bit‑vector consistency condition introduced in the FMCAD 2020 paper on ternary propagation. It asserts that, for 4‑bit vectors, a simple “upper‑mask” predicate (the conjunction of a bitwise‑and with a high bound) is not equivalent to the existence of a value satisfying a mask‑coverage constraint together with a literal‑generation predicate; the model thus tests the coherence of these two propagation rules. The problem lives in BV logic, uses a handful of constants and helper functions (including custom ctz/clz definitions) and features a single existential quantifier, making it a small but non‑trivial benchmark for solvers handling quantifiers and nested ite‑based bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvsge_s_x_64.smt2",
    "description": "This crafted BV instance encodes a verification condition for a bit‑vector consistency property used in the “ternary propagation‑based local search” paper (FMCAD 2020). It asserts that, for any pair of 64‑bit masks xlo/xhi satisfying the invariant (bvor (bvnot xlo) xhi) = all‑ones, there does **not** exist a value x respecting the mask ( bvand xhi x = x and bvor xlo x = x ) together with a signed value s that is greater‑or‑equal to x ( bvsge s x ). The formula consists of a single existential quantifier over x and s, a deep term (nested 64‑level ite chains for ctz/clz), and moderate term depth (≈67), making it a non‑trivial bit‑vector verification problem with quantified reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_x_s_32.smt2",
    "description": "This instance encodes a crafted verification condition for 32‑bit bit‑vector operators: it asserts that, for every pair (xlo, xhi) satisfying the “mask‑consistency” relation (bvor (bvnot xlo) xhi) = all‑ones, the always‑true predicate CC must be distinct from the existence of a value x constrained by a mask ( bvand xhi x = x and bvor xlo x = x) and equal to some literal s. The formula therefore checks that no such masked value exists, i.e., a consistency property of the mask operators. It features a single existential quantifier, deep nested ite expressions (the definitions of ctz and clz), many bit‑extractions, and a term depth of 35, making it a non‑trivial bit‑vector reasoning benchmark for SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_distinct_x_s_64.smt2",
    "description": "This crafted BV‑logic instance encodes a verification condition for a bit‑precise consistency rule between two 64‑bit masks xlo and xhi: the masks must be complementary (every bit is either set in xhi or cleared in xlo) and there must be **no** pair of 64‑bit values x and s such that x lies between the masks in the bitwise sense (xlo ⊆ x ⊆ xhi) while x ≠ s. The formula asserts the distinctness of the always‑true predicate CC from an existential statement, essentially checking that the existential is unsatisfiable under the mask constraint. Although only two top‑level constraints are present, the file contains very deep term structures (nested ite chains for ctz and clz) and many extracts, giving a high term‑depth (≈67) that challenges solvers despite the small number of variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvsge_s_x_32.smt2",
    "description": "This crafted BV instance checks a consistency condition for a bit‑vector mask operator used in the FMCAD‑2020 study on bit‑precise reasoning. It asserts that a pair of 32‑bit bounds (xlo, xhi) must be complementary and then requires that no value x satisfies both the mask condition (x is between the bounds bitwise) and a signed‑greater‑or‑equal relation with some auxiliary s. The formula contains a single existential quantifier, deep nested ite expressions for count‑trailing/leading‑zero functions (term depth ≈ 35), and relies heavily on bitwise extracts, making it a non‑trivial verification query for solvers handling quantified bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvsge_x_s_32.smt2",
    "description": "This crafted BV‑32 instance checks a consistency condition for a bit‑mask interval: it asserts that the pair (xlo, xhi) is a valid mask (every bit set in xlo is also set in xhi) and then requires that the always‑true predicate CC be distinct from the existence of a value x within that mask that is signed‑greater‑or‑equal to some s. Because any mask‑consistent x (e.g., x = xlo) together with s = x satisfies the existential, the distinctness forces a contradiction, making the formula unsatisfiable. The problem features a single existential quantifier, a few simple bit‑vector relations, but also deep nested ite structures for count‑trailing/leading‑zero functions that inflate term depth (≈35) without affecting the core check.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvlshr_s_x_4.smt2",
    "description": "This crafted 4‑bit BV instance encodes a consistency check for a bit‑vector operator used in the FMCAD 2020 paper on ternary propagation. It defines auxiliary bit‑vector utilities (count‑trailing/leading zeros, mask‑cover‑bits, odd‑test, etc.) and two predicates: **CC**, which relates a target vector t to bounds xlo/xhi via a bounded “mask‑cover‑bits” condition, and **LIT**, which ties a shift of a mask s to the same target t. The sole property asserted is that the truth of **CC** for the given bounds is *distinct* from the existence of a mask x and shift s satisfying both the mask condition and the shift relation—i.e., a verification of a subtle equivalence/consistency condition for the `bvlshr` operator. The problem is small (four 4‑bit variables, depth 7) but includes nested `ite` definitions and existential quantifiers, making it a typical bit‑precise verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvuge_s_x_32.smt2",
    "description": "This crafted BV‑logic benchmark encodes a verification condition for a consistency rule of the unsigned‑greater‑or‑equal (`bvuge`) relation under a pair of bit‑mask bounds. It asserts that, for any 32‑bit masks `xlo`/`xhi` satisfying a non‑emptiness constraint, there must **not** exist a value `x` fitting the mask (via `mcb`) together with a witness `s` such that `s ≥ x`; the formula is thus expected to be unsatisfiable. Although the core property is simple, the file contains deep, nested `ite` definitions for `ctz`, `clz`, etc., yielding a high term depth (≈35) and many extracts, which makes it a non‑trivial test for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvshl_s_x_4.smt2",
    "description": "This crafted BV instance encodes a verification check for a consistency condition relating a left‑shift (`bvshl`) operation to a mask‑based predicate (`mcb`) and a trailing‑zero count (`ctz`). It asserts that, for 4‑bit vectors, the predicate `CC(t,xlo,xhi)` (which allows either `t = 0` or the existence of a value bounded by `ctz(t)` that satisfies the mask) must be *distinct* from the existence of a pair `(x,s)` that both obey the same mask and fulfill `bvshl(s,x) = t`. The problem therefore asks whether the two formulations can ever disagree, i.e., it verifies the equivalence of the derived condition with the concrete shift‑left specification. The query involves several small helper functions (count‑leading/trailing zeros, oddness, etc.), a couple of existential quantifiers, and modest term depth, making it a low‑dimensional but non‑trivial bit‑precise verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvlshr_s_x_32.smt2",
    "description": "This instance is a crafted bit‑vector verification problem that checks a consistency condition for a mask‑based predicate involving the logical right‑shift (`bvlshr`). It asserts that, for any pair of 32‑bit masks `xlo`/`xhi` satisfying a validity relation, the Boolean formula `CC` (which combines a zero test, a bound on the shift amount, and a mask‑containment predicate) is **not** equivalent to an alternative formulation that existentially quantifies a value `x` and a shift result `s` linked by the same mask predicate and the shift equality `bvlshr s x = t`. The model therefore tests the correctness of two different encodings of the same bit‑precise property, using a moderate number of variables, deep nested `ite` chains for `ctz`/`clz`, and a single layer of existential quantification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_udiv_s_x_32.smt2",
    "description": "The instance is a crafted BV‑verification benchmark that checks a consistency condition for a 32‑bit unsigned division operator.  After fixing a pair of mask constants ( xlo, xhi ) that must satisfy a simple complement property, the formula asserts that the predicate **CC** – which mixes mask‑membership, overflow‑free multiplication and a special case for the all‑ones divisor – is *different* from the existence of a value x and a “literal” s such that x matches the mask and t = s ÷ x.  The problem therefore encodes a quantified equivalence check (two existential quantifiers, no alternation) with deep term nesting (bit‑level ctz/clz definitions) in the BV logic, making it a non‑trivial verification task for bit‑precise solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvuge_x_s_32.smt2",
    "description": "This crafted BV instance encodes a consistency‑check verification problem from the FMCAD 2020 paper on bit‑precise reasoning. It asserts that a trivially true predicate must be distinct from an existential condition that looks for a 32‑bit value `x` lying inside a bit‑wise range defined by `xlo`/`xhi` (the `mcb` mask) and simultaneously satisfying `x ≥ s` (`bvuge`). The core difficulty lies in the quantified existential combined with bitwise mask constraints, while the rest of the file contains auxiliary definitions (ctz, clz, etc.) that are not directly used.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_udiv_x_s_32.smt2",
    "description": "This crafted BV‑logic instance encodes a verification condition for a 32‑bit unsigned division operator: it defines low‑level bit‑vector utilities (count‑ trailing/leading zeros, overflow predicates for addition and multiplication) and a predicate CC that relates a candidate divisor t and interval bounds xlo, xhi to the existence of a factor‑by‑factor decomposition. The final assertion checks whether CC is equivalent to the existence of a pair (x,s) with x inside the interval and x ÷ s = t; the formula is made satisfiable only if the two predicates differ. The problem features deep nested ite/extract chains, two existential quantifiers and several custom overflow checks, yielding a term depth of 35 and a non‑trivial search space for bit‑precise solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvslt_x_s_4.smt2",
    "description": "This crafted BV instance encodes a verification problem that checks whether a simple consistency condition on a 4‑bit interval (the “CC” predicate) agrees with the existence of a signed‑less pair \\(x < s\\) that also satisfies a mask‑coverage constraint defined by the “mcb” function. The formula contains a single existential quantifier over two 4‑bit variables, a few auxiliary bit‑vector functions (e.g., count‑trailing‑zeros, count‑leading‑zeros) and a basic interval‑validity assertion, yielding a modest term depth (≈7) and a very small domain. It was generated by Preiner and Niemetz for the FMCAD 2020 paper on ternary propagation‑based local search, aiming to stress bit‑precise reasoning rather than large‑scale scalability.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvslt_s_x_32.smt2",
    "description": "This crafted BV‑32 instance checks the equivalence of a lightweight consistency predicate (‑ if the lower and upper bounds are equal they must not be the minimal value) with a more expressive specification that asserts the existence of a value x between the bounds (bitwise‑masked by xlo/xhi) that is larger than some signed s. The model must satisfy a bit‑wise inclusion constraint on xlo and xhi and then demonstrate that the two predicates differ; thus it is a verification‑type problem testing whether the simple predicate correctly captures the existential condition. The formula contains a single existential quantifier, deep nested ite chains for count‑trailing/leading‑zero helpers (unused elsewhere), and a moderate term depth (≈35), making it a non‑trivial BV verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvlshr_x_s_4.smt2",
    "description": "The benchmark verifies a consistency condition for a 4‑bit bit‑vector operator: it defines a predicate CC that existentially quantifies a shift amount i and checks a mask‑containment property, and it also defines an alternative formulation that looks for a literal x (satisfying the same mask) and a shift s such that shifting x by s yields the target t. The instance asserts that the low/high mask pair is well‑formed (the complement of xlo combined with xhi covers all bits) and then demands that the two predicates be **distinct**, i.e., that the two characterisations are not equivalent. This is a crafted verification query from the FMCAD 2020 paper on ternary propagation‑based local search, involving several nested ite/extract definitions and two existential quantifiers, which makes quantifier reasoning the primary source of difficulty despite the tiny 4‑bit domain.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvult_x_s_64.smt2",
    "description": "This instance is a crafted verification problem from the FMCAD 2020 paper on bit‑precise reasoning, checking the consistency of a “bit‑wise interval” predicate ( mcb ) together with an unsigned‑less‑than condition. It asserts that a simple condition on the lower bound (the lower bound is not the all‑ones constant) must differ from the existence of any value fitting the interval that is smaller than some other bit‑vector, thereby testing a subtle logical equivalence. Although only two top‑level assertions are present, the file contains explicit definitions of count‑trailing‑zero and count‑leading‑zero functions built from 64 nested ite expressions, inflating the term depth (≈ 67) and making the benchmark challenging for solvers that must handle deep, extract‑heavy terms.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_udiv_x_s_64.smt2",
    "description": "This instance encodes a bit‑precise verification check for a 64‑bit unsigned‑division consistency condition.  It defines a mask predicate mcb that relates a lower and upper bound (xlo, xhi) to a candidate value, and a function CC that combines several arithmetic checks (add‑overflow, multiplication overflow, and mask violation) with an inner existential witness.  The final assertion demands that the condition CC is *not* equivalent to the existence of a pair (x, s) satisfying bvudiv x s = t under the same mask, thereby testing the soundness of the derived consistency predicate.  The problem features 64‑bit bit‑vectors, deep nested ite/​extract chains (e.g., for ctz/clz), and two existential quantifiers, making it a crafted, quantifier‑rich verification query.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvshl_x_s_64.smt2",
    "description": "This crafted BV‑logic benchmark checks a consistency condition for the 64‑bit left‑shift operator: it asserts that the “masked‑carry‑bit” definition (a conjunction of bit‑wise mask properties together with a bound on the shift amount via ctz) is **distinct** from an alternative existential formulation that requires a value x and a shift amount s such that shifting x by s yields the target term t. The instance originates from the FMCAD 2020 paper on bit‑precise reasoning and features two quantified assertions (existential over a 64‑bit index and over a pair (x,s)) combined with deep, manually‑encoded definitions of ctz and clz using 64‑nested ite branches, leading to high term depth (≈67) and many bit‑extract operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvand_x_s_32.smt2",
    "description": "This instance checks a consistency condition for 32‑bit mask operations: it asserts that the simple predicate “t is a subset of the high‑mask xhi” ( bvand t xhi = t ) is distinct from the existence of some value x lying between a low‑mask xlo and xhi (and therefore satisfying the “mask‑constrained bits” condition) together with a mask s such that bvand x s = t. The formula originates from the FMCAD 2020 paper on ternary‑propagation‑based local search for bit‑precise reasoning and is classified as a crafted verification benchmark. Although only one existential quantifier appears, the encoding contains very deep nested ite‑expressions for count‑leading/trailing‑zero functions, many bit‑extractions, and a high term‑depth (≈35), which makes it a challenging bit‑vector SAT/SMT case for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvuge_x_s_4.smt2",
    "description": "This instance is a handcrafted bit‑vector verification problem (BV 4) that checks a consistency condition for a mask‑based interval predicate together with an unsigned‑greater‑or‑equal test. After enforcing that the low/high mask pair (xlo, xhi) forms a valid complementary interval, it asserts that there is **no** 4‑bit value x and bound s satisfying both the mask‑concretization (the “mcb” condition) and the ordering predicate (x ≥ s); the check is expressed with a single existential quantifier whose falsity is required. The formula is small (four declared constants, one quantifier, depth 7) but includes several auxiliary bit‑vector definitions (ctz, clz, etc.) that increase term structure without affecting the core logical difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvashr_x_s_64.smt2",
    "description": "This instance encodes a **verification** check for a 64‑bit bit‑vector “carry‑condition’’ (named CC) that relates a mask‑pair (xlo,xhi) to a shift‑right operation (bvashr). It asserts that, under the invariant that xlo and xhi form a complementary mask, the CC predicate is **not equivalent** to the existence of a value x and a shift amount s such that shifting x by s yields a given target t. The formula features deep, handcrafted bit‑vector definitions of count‑trailing‑zeros/leading‑zeros (nested ite and extract) and three quantifier‑alternating sub‑formulas, giving a moderate‑size (≈8 KB) but high term‑depth (≈67) BV problem that stresses precise bit‑level reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_concat_x_s_32.smt2",
    "description": "This crafted BV benchmark verifies a consistency condition for a bit‑masking predicate used in local‑search bit‑precise reasoning. It asserts that the simple mask‑check predicate (requiring a value to lie between two bounds) is **distinct** from the existence of a value and a suffix that together form a given concatenation, thereby checking whether the two formulations can ever coincide. The problem features a single existential quantifier and very deep, nested ite‑chains (e.g., for count‑trailing/leading zeros), yielding high term depth despite only four 32‑bit variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_distinct_x_s_32.smt2",
    "description": "This instance is a crafted BV‑logic verification check from the FMCAD 2020 benchmark suite, testing a consistency condition for a bit‑vector mask operator. It asserts that a trivially true predicate (`CC`) must be distinct from an existential formula that requires a value `x` to lie within a mask defined by `xlo`/`xhi` (the “mcb” condition) and to be different from some other bit‑vector `s`; the masks are constrained to be complementary (`bvor (bvnot xlo) xhi = all‑ones`). The problem contains only four 32‑bit variables but includes very deep nested‑ite definitions for `ctz`/`clz` (unused in the final check) and a single quantifier, yielding a high term depth (≈35) that makes it a non‑trivial bit‑precise consistency verification case.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_x_s_64.smt2",
    "description": "This crafted BV instance encodes a verification condition for a 64‑bit “consistency” predicate (CC) used in the FMCAD 2020 study on bit‑precise reasoning.  After defining auxiliary bit‑vector utilities (including exhaustive ite‑based implementations of count‑trailing‑zeros and count‑leading‑zeros) it asserts that the interval‑encoding pair xlo/xhi is well‑formed and then requires that the trivially true predicate CC be distinct from the existence of any x satisfying the interval constraints mcb and the literal equality LIT, i.e. it checks that such an x cannot exist.  The problem features a single existential quantifier, deep nesting (term depth ≈ 67) with many extracts and ite‑chains, and therefore stresses solvers’ handling of large, bit‑vector‑heavy formulas.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_urem_x_s_4.smt2",
    "description": "This instance encodes a verification condition for a 4‑bit unsigned remainder operation: it checks whether a mask‑consistency predicate (CC) is equivalent to the existence of a pair (x,s) that satisfies a mask predicate (mcb) and the equality (bvurem x s) = t, under the constraint that xlo and xhi form a complementary mask.  The formula uses a collection of helper bit‑vector functions (count‑trailing/leading zeros, overflow tests, etc.) and contains a single existential quantifier, giving a modest‑size but non‑trivial BV problem that exercises quantified reasoning and conditional bit‑vector operators.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_concat_s_x_4.smt2",
    "description": "This crafted BV instance checks a consistency condition for a 4‑bit “mask‑contained‑by” predicate versus a concatenation equality.  It asserts that the interval mask defined by two 4‑bit bounds (xlo, xhi) is not equivalent to the existence of a value x in the same interval such that concatenating x with some 4‑bit suffix yields the same 8‑bit word as concatenating the given suffix ts with tx.  The problem stems from the FMCAD‑2020 verification benchmark (Preiner/Niemetz), features a single existential quantifier, several auxiliary bit‑count functions, and a modest term depth (≈7) with only four declared bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvadd_x_s_64.smt2",
    "description": "This crafted BV‑logic instance checks a consistency condition for a 64‑bit addition: it asserts that the always‑true predicate CC(t,xlo,xhi) must be *distinct* from the existence of a value x (lying between the bounds xlo and xhi) and a summand s such that x + s = t. The bounds are required to be complementary ( bvor(bvnot xlo, xhi) = all‑ones ), and the existence check is encoded with a small interval predicate (mcb) and a simple linear equation (LIT). Although the core property involves only one existential quantifier, the file contains very deep, nested ite‑chains for bit‑counting functions (ctz, clz) that inflate term depth to 67, making the instance a stress test for bit‑precise reasoning and solver handling of large ite/extract structures.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvslt_x_s_32.smt2",
    "description": "This crafted BV instance, taken from the FMCAD‑2020 “ternary propagation” paper, encodes a verification condition that a simple consistency predicate on two 32‑bit bounds (`xlo`, `xhi`) is equivalent to the existence of a value satisfying a mask‑based bound (`mcb`) and a signed‑less‑than relation (`LIT`).  The formula asserts the relationship between the bounds (including a distinctness requirement from the maximal constant) and checks whether the quantified existential clause can be true, i.e., it is a SAT/UNSAT query for a bit‑precise consistency property.  Although only one existential quantifier appears, the file defines very deep ite‑chains for `ctz`/`clz` (term depth 35) and uses many bit‑vector extracts, making the bit‑vector reasoning non‑trivial for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_urem_x_s_32.smt2",
    "description": "This instance encodes a crafted verification problem for 32‑bit bit‑vector arithmetic, checking a consistency condition that relates the unsigned remainder operator (`bvurem`) with a mask‑range predicate (`mcb`). It asserts that a complex Boolean formula—built from nested `ite` chains for counting leading/trailing zeros, overflow predicates, and a quantified existence of a pair `(x,s)` satisfying the remainder condition—must be different from another quantified formula, under the side‑condition that `xlo` and `xhi` form a valid mask. The problem uses deep term nesting (depth ≈ 35), several bit‑extractions, and a mix of existential quantifiers, making it a non‑trivial bit‑vector verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvsge_s_x_64.smt2",
    "description": "This instance is a crafted bit‑vector verification problem that checks the correctness of an invertibility condition for the signed‑greater‑or‑equal (`bvsge`) operator over a masked interval. It encodes a predicate `IC` that approximates the existence of a value `x` with `s ≥ x` inside the interval defined by `xlo`/`xhi`, and asserts that this approximation must differ from the concrete existential condition using the mask‑constrained predicate `mcb`. The formula contains only five 64‑bit constants, a single existential quantifier, but deep term structures (large `ite` ladders for `ctz`/`clz`) that make solving non‑trivial despite the small number of variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_x_s_4.smt2",
    "description": "This instance is a bit‑vector verification benchmark (BV, 4‑bit vectors) that checks an invertibility condition for a masking‑based operator, as described in Preiner & Niemetz (FMCAD 2020). It asserts that the mask constraints on lower/upper bounds are well‑formed and then asks whether the defined invertibility predicate differs from the existence of a concrete value satisfying those masks and equal to a given constant. The problem is small (five constants, one existential quantifier, depth ≤ 7) but involves non‑linear bitwise operations and a distinctness check, making it a crafted test of solver handling of quantified BV reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_sext_1_4.smt2",
    "description": "This crafted BV instance checks a **verification condition for an invertibility condition** of the 4‑bit sign‑extension operator. It asserts that a pair of bounds (xlo, xhi) satisfies a simple mask property, then requires that the manually derived invertibility condition (IC) for the operation be *distinct* from the existence of a concrete 4‑bit value x that both lies within those bounds (via the mcb mask predicate) and satisfies the sign‑extension equation. The problem involves a single existential quantifier, a few bit‑extractions and extensions, and small‑width bit‑vectors, making it a focused, quantifier‑rich verification query rather than a large‑scale search or scheduling problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_sext_3_4.smt2",
    "description": "This instance encodes a verification task for an *invertibility condition* (IC) of a sign‑extension operation on 4‑bit vectors, as used in the FMCAD‑2020 study on bit‑precise reasoning. The formula asserts that the syntactic IC (relating the sign‑bit of a 3‑bit “tn” and the high‑bit of a 4‑bit “tx” together with a mask‑cover‑both condition on “xlo”/“xhi”) is **distinct** from the semantic existence of a concrete 4‑bit value “x” satisfying the same mask and the sign‑extension equality; the check‑sat thus looks for a counterexample to the IC’s correctness. The problem is a crafted BV benchmark with only five constants, a single existential quantifier, shallow term depth (≤7) and simple bit‑vector operations, making it a small but non‑trivial quantifier‑reasoning case.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvshl_x_s_4.smt2",
    "description": "This instance encodes a verification task for the invertibility condition of the 4‑bit left‑shift operator. It asserts that the generic condition IC(s,t,xlo,xhi) – which combines a shift‑based equation with a mask‑containment predicate – is **distinct** from the concrete existence of a bit‑vector x (restricted by the same mask) that satisfies the literal (bvshl x s) = t. The benchmark is a small, handcrafted BV problem (5 constants, one existential quantifier) designed to test solvers’ ability to reason about quantified bit‑vector constraints arising from invertibility proofs.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvsge_x_s_4.smt2",
    "description": "This instance checks the correctness of an *invertibility condition* for the signed‑greater‑or‑equal bit‑vector operator (bvsge) on 4‑bit values. After encoding auxiliary functions (mask‑cover‑bounds, count‑trailing/leading zeros, etc.), it asserts that a pair (xlo, xhi) forms a valid interval and then demands that the condition IC (s, t, xlo, xhi) must be equivalent to the existence of a concrete value x within that interval satisfying x ≥ₛ s; the solver is asked to find a model where the two differ. The problem is a crafted BV verification case with a single existential quantifier, very shallow terms (depth ≤ 7) and only five 4‑bit variables, making it small but still representative of bit‑precise reasoning challenges.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvshl_s_x_4.smt2",
    "description": "This instance encodes a verification task for an invertibility condition of the bit‑vector left‑shift operator (bvshl) on 4‑bit values. It defines auxiliary functions (e.g., count‑trailing‑zeros, mask‑and‑bound checks) and asserts that the proposed condition IC for the existence of a shift amount x is *not* equivalent to the explicit existential formula “∃ x · (mcb xlo xhi x ∧ (s bvshl x = t))”. The problem is a small, crafted BV‑logic benchmark with a single existential quantifier, shallow term depth (≤ 7), and a moderate mix of bitwise, arithmetic, and conditional operators.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_concat_x_s_64.smt2",
    "description": "This crafted BV instance tests an **invertibility condition** for a 64‑bit concatenation operator: it asserts that the concrete assignment `s = ts` with a mask‑constrained value `tx` (ensuring `tx` lies between `xlo` and `xhi`) is *distinct* from any value `x` that both respects the same mask and makes the concatenation `concat(x,s)` equal to `concat(tx,ts)`. The formula originates from the FMCAD 2020 paper on ternary propagation‑based local search and encodes auxiliary bit‑vector functions (ctz, clz, odd, etc.) with extremely deep nested `ite` chains (max term depth ≈ 67). Although it contains only two top‑level assertions, the heavy use of extracts and conditionals makes the instance non‑trivial for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvsge_s_x_32.smt2",
    "description": "This SMT‑LIB instance checks the correctness of an invertibility condition for the signed‑greater‑or‑equal bit‑vector operator ( bvsge ) on 32‑bit values. It encodes a derived condition IC that should be equivalent to the existence of a value x lying within a mask‑defined interval (given by xlo and xhi) and satisfying s ≥ x; the query asserts that the two formulations are distinct, i.e., it looks for a counterexample to the intended equivalence. The model uses a handful of 32‑bit constants, an existential quantifier over x, and deep ite‑chains for counting‑trailing/leading zeros, making the term depth relatively high but the quantifier structure simple.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvsge_x_s_32.smt2",
    "description": "This instance is a crafted bit‑vector verification problem that checks the correctness of an invertibility condition for the signed‑greater‑or‑equal (`bvsge`) operator on 32‑bit words. It asserts that a predicate IC involving the sign bits of two bound values (`xlo`, `xhi`) is equivalent to the existence of a concrete value x (restricted by a mask‑cover‑bounds predicate `mcb`) that satisfies the same signed‑comparison against a given constant `s`. The formula contains only five 32‑bit variables, a single existential quantifier, and deep ite chains for `ctz`/`clz` definitions (term depth ≈ 35), making it a moderate‑size, quantifier‑light verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvurem_s_x_32.smt2",
    "description": "This instance is a crafted verification problem that searches for a counter‑example to an invertibility condition of the 32‑bit unsigned remainder operator ( bvurem ). It encodes a condition (IC) relating two bit‑vectors s and t and a mask pair xlo/xhi, together with a separate existential check for a divisor x satisfying s % x = t; the formula asserts that the two predicates differ while requiring the mask pair to be complementary. The benchmark uses pure bit‑vector logic (BV), contains nested ite‑chains for bit‑count functions, a few quantifier alternations, and a moderate term depth (≈35), making it a non‑trivial bit‑precise reasoning task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_concat_s_x_64.smt2",
    "description": "This benchmark checks the correctness of an invertibility condition for the 64‑bit concatenation operator. It defines a “mask‑contain‑bits” predicate, explicit (and very deep) definitions of count‑trailing‑zeros / count‑leading‑zeros, and asserts that the condition IC (which requires s = ts and the mask constraint) is *distinct* from the existence of a 64‑bit value x satisfying the same mask and making the concatenations of s  x and ts  tx equal. In other words, the instance verifies whether the derived invertibility condition for concat is sufficient. The problem is a crafted BV‑logic verification query with a single existential quantifier, five 64‑bit constants, and unusually deep term nesting (depth ≈ 67) due to the exhaustive ite chains.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvadd_x_s_32.smt2",
    "description": "This instance checks the **invertibility condition** for 32‑bit addition \\(t = s + x\\): it asserts that a mask‑based predicate (the “IC”) on the interval bounds \\(x_{lo},x_{hi}\\) is *distinct* from the existence of some \\(x\\) (within the same bounds) that satisfies the addition.  The problem is encoded in the BV logic with five 32‑bit constants, a handful of helper definitions (including painfully deep ite‑based definitions of count‑trailing/leading zeros), and a single existential quantifier, yielding a moderate‑size (≈5 KB) crafted benchmark with term depth 35 that tests a solver’s ability to reason about bit‑precise invertibility conditions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_concat_s_x_4.smt2",
    "description": "This instance is a bit‑vector verification problem (BV logic) that checks the correctness of an invertibility condition for the concatenation operator on 4‑bit vectors. It asserts that a concrete “mask‑condition” on lower and upper bounds together with an equality between two concatenations is **distinct** from the existence of a value satisfying the same mask and the concatenation equality, i.e., it tests whether the derived invertibility condition is equivalent to the existential formulation. The model is small (five 4‑bit constants, one existential quantifier, depth 7) but includes custom definitions for trailing/leading‑zero counts and uses masking, making it a crafted benchmark from the FMCAD 2020 study on bit‑precise reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvurem_s_x_4.smt2",
    "description": "This instance is a crafted bit‑vector verification problem that checks the correctness of an analytically derived invertibility condition for the unsigned‑remainder operator (bvurem).  It encodes a small 4‑bit domain with auxiliary mask‑range predicates, trailing‑zero/leading‑zero helpers, and a quantified sub‑formula that must be equivalent to the original condition; the final assertion tests that the two formulations are mutually exclusive (i.e., the derived condition is exact).  The problem features a handful of bit‑vector constants, nested ite/extract constructs, one existential quantifier and a modest term depth (≈7), making it a focused but non‑trivial bit‑precise reasoning benchmark from the FMCAD‑2020 study on invertibility conditions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_sext_2_32.smt2",
    "description": "This is a handcrafted bit‑vector verification instance (BV logic) that checks an **invertibility condition for a sign‑extension operation**.  The formula encodes a mask constraint (`mcb`) on a value `x` (forcing all bits between two bounds `xlo`/`xhi` to be 1), a literal condition (`LIT`) that the 32‑bit value `x` equals the sign‑extension of a 2‑bit tag `tn` concatenated with another 32‑bit word `tx`, and an “IC” condition linking `tn` and the sign bit of `tx`.  The final assertion requires that the IC condition be **distinct** from the existence of a masked value satisfying `LIT`, i.e., it tests whether the invertibility condition holds.  The problem contains a single existential quantifier, a moderate number of variables, and deep nested `ite` terms (used in auxiliary `ctz`/`clz` definitions), making it a moderate‑size, quantifier‑light BV satisfiability check.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_sext_4_4.smt2",
    "description": "This instance is a crafted BV verification benchmark that tests the correctness of an invertibility condition for a 4‑bit sign‑extension operator. It encodes a concrete condition (IC) involving the sign‑bit of the target value and a mask‑cover property (mcb), and asserts that this condition must be equivalent to the existence of a 4‑bit operand satisfying the mask and a literal relation (LIT). The solver is asked to find a model where the two formulations differ, using a single existential quantifier and modest term depth (≈7) with only five bit‑vector variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvashr_x_s_4.smt2",
    "description": "This crafted BV instance encodes a verification task for an **invertibility condition** of the arithmetic‑right‑shift operator ( bvashr ) with a 4‑bit shift amount `s`.  The formula asserts that the condition IC — which combines a shift‑by‑`s` identity, a special case for large shifts, and a mask‑containment predicate `mcb`—is **not equivalent** to the existence of a concrete operand `x` (bounded by `xlo`/`xhi`) that satisfies the shift equation `bvashr x s = t`.  The problem thus checks the correctness of the manually derived IC by contrasting it with an existential witness, using a single quantifier, nested `ite`s, extracts, and bit‑vector arithmetic on 4‑bit vectors (max term depth 7).  It originates from the FMCAD 2020 study on bit‑precise reasoning and serves as a small‑scale yet logically intricate benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvlshr_s_x_4.smt2",
    "description": "This crafted BV instance encodes a verification task for the invertibility condition of the logical right‑shift operator (`bvlshr`) on 4‑bit vectors. It defines auxiliary bit‑vector utilities (count‑leading/trailing zeros, mask constraints) and asserts that the formally derived condition IC for a shift amount lies in the interval \\([x_{lo},x_{hi}]\\) is **not** equivalent to the existence of a concrete shift amount x (satisfying the same mask) that makes the shifted value `s >> x` equal to t. The solver must decide the satisfiability of this discrepancy, testing the correctness of the published invertibility condition.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_sext_4_32.smt2",
    "description": "This crafted BV instance from Preiner & Niemetz (FMCAD 2020) verifies an invertibility condition for a 4‑bit sign‑extension to 32 bits: it asserts that the predicate IC (capturing the condition on the sign‑extension operand and a mask) is *distinct* from the existence of a concrete 32‑bit value satisfying both the mask constraints (mcb) and the literal‑definition (LIT). The formula contains a single existential quantifier but features many bit‑extractions and a deeply nested cascade of ite‑expressions (term depth ≈ 35), making it a non‑trivial bit‑vector reasoning benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_distinct_x_s_4.smt2",
    "description": "This instance encodes a verification task for a bit‑vector invertibility condition (IC) generated in the FMCAD‑2020 study. It asks whether the IC for a 4‑bit source value `s` (and a target `t`) differs from the existence of a concrete literal `x` that lies within a given interval `[xlo,xhi]` (expressed by the mask‑contain‑bound predicate). The formula is a small, handcrafted BV problem (five 4‑bit constants, one existential quantifier) that tests the correctness of the derived IC under the interval constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_distinct_x_s_64.smt2",
    "description": "This instance encodes a verification task for the invertibility condition of a 64‑bit bit‑vector operation (the “IC” predicate), generated for the FMCAD‑2020 paper on ternary‑propagation‑based local search.  The formula asserts that a pair of bounds (xlo, xhi) forming a valid bit‑mask interval is such that the condition IC(s,t,xlo,xhi) is distinct from the existence of a concrete value x within that interval that is also different from s.  The benchmark is crafted in BV, contains a single existential quantifier, deep nested ite expressions for `ctz`/`clz` (term depth ≈ 67), and therefore stresses solvers’ handling of large bit‑vector terms and quantifier reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_sext_4_64.smt2",
    "description": "This crafted BV instance encodes a verification check for the invertibility condition of a 4‑bit sign‑extension to 64 bits, together with a mask‑covering constraint (the “mcb” predicate) on a candidate literal. It asserts that the Boolean condition IC (linking the sign‑bit of the extended value with the 4‑bit selector tn) is distinct from the existence of a 64‑bit value x that both satisfies the mask bounds and matches the sign‑extended literal, thereby testing whether the invertibility condition holds. The formula contains a single existential quantifier but features very deep term structures (nested ite’s over 64 extracts for ctz/clz) and numerous bit‑extractions, which makes it challenging for bit‑vector solvers despite the modest number of variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvshl_s_x_32.smt2",
    "description": "This instance is a bit‑vector verification problem (BV logic) that checks the correctness of an *invertibility condition* for the left‑shift operator `bvshl`.  It encodes the condition `IC(s,t,xlo,xhi)`—relating the counts of trailing zeros of `s` and `t` and a mask constraint on a shift amount—and asserts that it is *not* equivalent to the existential statement “there exists a shift `x` within the allowed range such that `s << x = t`”.  The formula contains a single existential quantifier, a handful of 32‑bit variables, and very deep nested `ite` expressions for `ctz`/`clz`, giving a term depth of 35 while keeping the overall size modest (≈5 KB).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvurem_s_x_64.smt2",
    "description": "This instance encodes a verification task for the invertibility condition of the 64‑bit bit‑vector remainder operator (`bvurem`).  It asserts that a hand‑crafted condition IC (involving inequalities, a mask‑checking predicate mcb and an implication with an existential witness) is inequivalent to the direct existential formulation “∃ x. mcb x ∧ (s % x)=t”, while also enforcing that the mask bounds `xlo` and `xhi` form a complementary pair.  The problem lives in the BV logic, contains deep nested ite/extract chains (term depth ~67) and a few quantifier alternations, making it a crafted, quantifier‑heavy bit‑vector verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_sext_3_64.smt2",
    "description": "This instance encodes a verification task for an invertibility condition of a 64‑bit sign‑extension operator (extending a 3‑bit sign field). It asserts that the condition IC—relating the sign‑bit pattern tn, the 64‑bit value tx, and a bitwise interval defined by xlo/xhi—must be equivalent to the existence of a concrete 64‑bit witness x satisfying both the interval (via mcb) and the literal LIT (sign‑extending x equals the concatenation of tn and tx). The formula is a BV‑logic query with a single existential quantifier, deep nested ite chains (e.g., for ctz and clz), and a high term depth (≈67), making it a crafted, quantifier‑heavy verification benchmark from the FMCAD 2020 paper.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvshl_x_s_32.smt2",
    "description": "The instance encodes a bit‑vector verification task from the FMCAD 2020 study on invertibility conditions for bit‑vector operators. It checks that the manually derived condition IC for the left‑shift operation (shifting a value t by a symbolic amount s) is equivalent to the existence of a concrete operand x satisfying the mask‑cover constraints (mcb) and the literal equation (bvshl x s = t). The problem is a shallow BV formula with a single existential quantifier, but it contains very deep nested ite expressions (e.g., the explicit definitions of ctz/clz) and many bit‑extracts, which raise the term‑depth to 35 and make the instance non‑trivial for solvers despite its modest size.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvuge_s_x_64.smt2",
    "description": "This instance is a crafted BV‑logic verification benchmark (generated by Mathias Preiner and Aina Niemetz for FMCAD 2020) that checks an **invertibility condition for the bit‑vector “greater‑or‑equal” (bvuge) operator** on 64‑bit words.  It asserts that the simple bound `xlo ≤ s` is *not* equivalent to the existence of a value `x` inside the mask interval defined by complementary constants `xlo` and `xhi` (enforced by `(bvor (bvnot xlo) xhi) = ones`) that also satisfies `s ≥ x`.  The formula contains a single existential quantifier, a large number of nested `ite`/`extract` expressions (used for trailing/leading‑zero functions, though they are not otherwise needed), and a deep term depth (≈ 67), making it a non‑trivial, highly symbolic BV benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvxor_x_s_32.smt2",
    "description": "This benchmark encodes a verification task for a bit‑precise invertibility condition of the 32‑bit XOR operator. It asserts that a mask‑based condition on the xor of two unknown vectors (s and t) is distinct from the existence of an actual vector x satisfying both the mask constraints and the literal equation x ⊕ s = t, while requiring the low/high masks to be complementary. The problem lies in pure BV logic, featuring a single existential quantifier and deep nested ite‑based definitions (e.g., count‑trailing/leading zeros), making it a crafted, bit‑vector‑focused verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvult_x_s_64.smt2",
    "description": "This crafted BV‑64 instance checks a **verification condition** for an invertibility property of a bit‑vector operator: it asserts that the predicate IC (which requires a non‑zero s and xlo < s) is **not** equivalent to the existence of a value x that both satisfies the “mask‑contain‑both‑bounds” predicate mcb(xlo,xhi,x) and lies in the interval [0, s). The model includes manually expanded definitions of count‑trailing/leading zeros (via deep nested ite and extract chains) and an existential quantifier, giving the formula a large term depth (≈ 67) and making it challenging for solvers despite a modest number of variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_concat_s_x_32.smt2",
    "description": "This crafted BV instance encodes a verification check for an invertibility condition of a concatenation‑based bit‑vector operation. It asserts that a pair of mask constants ( xlo, xhi ) satisfies a “mask‑covers‑both‑sides” property and then asks whether the condition “s = ts ∧ mask‑covers‑tx” is *distinct* from the existence of a 32‑bit value x that both respects the same mask and makes the concatenations concat s x and concat ts tx equal. The model contains a single existential quantifier, a deep nesting of ite/​extract terms for count‑trailing‑zero/leading‑zero functions, and a term depth of 35, making the problem a bit‑precise invertibility‑verification case that stresses solvers’ handling of long, highly conditional bit‑vector expressions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_distinct_x_s_32.smt2",
    "description": "This instance encodes a verification condition for a 32‑bit‑vector invertibility rule: it asserts that the Boolean “invertibility condition” (IC) on four vectors `s, t, xlo, xhi` is **distinct** from the existence of a concrete value `x` that both satisfies a mask‑coverage predicate (`mcb`) and is unequal to the distinguished constant `s`.  The formula includes handcrafted definitions of `ctz`, `clz`, and related helpers, a validity constraint on the mask pair `(xlo,xhi)`, and a single existential quantifier.  Although the problem involves only five bit‑vector variables, the nested `ite` chains give a deep term structure (depth ≈ 35), making it a bit‑precise, crafted benchmark for checking equivalence of invertibility conditions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvuge_x_s_64.smt2",
    "description": "This crafted 64‑bit bit‑vector benchmark tests the *invertibility condition* for the unsigned‑greater‑or‑equal operator (BVUGE). It asserts that, for any pair of bounds `xlo`/`xhi` satisfying a mask constraint, the simple condition “`xhi ≥ s`” is *distinct* from the existence of a value `x` between the bounds that also satisfies “`x ≥ s`”, i.e., it checks whether the naïve invertibility condition is sufficient. The file contains numerous auxiliary definitions (e.g., `ctz`, `clz`) that introduce deep nesting (term depth ≈ 67) and many bit‑extracts, making the instance comparatively hard for BV solvers despite having only two top‑level assertions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvult_s_x_32.smt2",
    "description": "This instance is a bit‑vector verification query that checks an “invertibility condition” for the unsigned‑less‑than operator ( bvult ) on 32‑bit words.  It encodes a property stating that, for a given mask pair (xlo,xhi) that form a complementary interval, the condition IC ( s ≠ 0xFFFFFFFF ∧ xhi > s ) should be equivalent to the existence of a value x lying in that interval and satisfying the mask constraints; the formula asserts that the two are **distinct**, i.e., it looks for a counter‑example.  The problem is crafted, contains only five constants but many deeply nested ite‑chains (from the defined ctz/clz functions) giving a term depth of 35, and features a single existential quantifier, making it a focused “invertibility‑condition” verification task with moderate syntactic complexity.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_sext_2_4.smt2",
    "description": "This instance encodes a verification check for the invertibility condition of the 2‑bit sign‑extension operator on 4‑bit bit‑vectors. It asserts that a manually derived condition (IC), which relates the sign‑extension’s top bit and a mask constraint on a candidate range \\([x_{lo},x_{hi}]\\), is distinct from the actual existence of a concrete value \\(x\\) in that range that satisfies the sign‑extension equality. The problem involves a single existential quantifier, a few small bit‑vector functions (mask, count‑trailing/leading zeros, oddness), and modest term depth, making it a crafted, low‑dimensional BV verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_concat_x_s_4.smt2",
    "description": "This crafted 4‑bit‑vector benchmark encodes a verification task for an **invertibility condition** of the concatenation operator: it asserts that the concrete condition `IC(s,tx,ts,xlo,xhi)` (which fixes `s = ts` and requires `tx` to lie between the masks `xlo` and `xhi`) is **distinct** from the existence of a value `x` that both respects the same mask constraints and satisfies `concat(x,s) = concat(tx,ts)`.  The model defines helper functions for mask checking, trailing/leading‑zero counts, and basic constants, and contains a single existential quantifier together with a `distinct` assertion, making it a small‑scale verification‑of‑invertibility problem with moderate term depth (7) but non‑linear bit‑vector operations (concat, masks).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvlshr_x_s_32.smt2",
    "description": "This benchmark encodes a verification task for a 32‑bit invertibility condition of the left‑shift / logical‑right‑shift operator (`bvshl` / `bvlshr`). It asserts that the syntactic condition IC—stating that shifting a value t left by s and then right‑shifting by s yields t and that t lies within a masked range defined by xlo/xhi—does **not** coincide with the existential condition that there exists a concrete x satisfying the same mask (via mcb) and the literal relation `bvlshr x s = t`. The file is a crafted BV instance (≈5 k characters, term depth 35) from the FMCAD‑2020 study on bit‑precise reasoning, featuring a single existential quantifier, many bit‑extractions and deeply nested ite‑chains (ctz/clz definitions), which makes it moderately challenging for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvslt_x_s_64.smt2",
    "description": "This SMT‑LIB file checks a crafted invertibility condition for a 64‑bit signed‑less‑than (`bvslt`) operator: it asserts that a predicate `IC(s,t,xlo,xhi)` is **not** equivalent to the existence of a bit‑vector `x` inside the interval encoded by `xlo`/`xhi` that satisfies `x < s`.  The model includes explicit definitions of `ctz`/`clz` (and their complements) using deep nested `ite` chains, a single existential quantifier, and several auxiliary bit‑vector constants, giving a modest number of variables but a high term depth (≈67) that can make solving challenging.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvsge_x_s_64.smt2",
    "description": "This crafted BV‑logic instance encodes a verification condition for the invertibility predicate of the signed‑greater‑or‑equal operator ( bvsge ) on 64‑bit vectors. It asserts that a deterministic interval‑checking predicate IC(s,t,xlo,xhi) must be logically equivalent to the existence of a value x lying in the interval defined by the mask‑constrained bounds xlo, xhi (and satisfying x ≥ s), and then checks the negation of that equivalence. The formula features a single existential quantifier, five 64‑bit constants, and very deep, nested ite expressions for bit‑counting helpers (ctz/clz), making the term depth high (≈ 67) while the overall constraint graph remains small (only two top‑level asserts).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvult_s_x_4.smt2",
    "description": "This instance is a crafted BV‑logic verification problem that checks an *invertibility condition* for the unsigned‑less‑than operator (`bvult`).  It encodes a small 4‑bit domain with auxiliary functions (mask constraints, zero/one constants, etc.) and asserts that the proposed condition on the operands (`IC s t xlo xhi`) is not equivalent to the existence of a concrete value `x` satisfying the mask bounds and the literal `s < x`.  The formula contains only five 4‑bit constants, a single existential quantifier, and modest term depth, making it a focused bit‑precise reasoning test rather than a large‑scale or highly quantified benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvurem_x_s_64.smt2",
    "description": "This handcrafted BV benchmark verifies an analytically derived invertibility condition for the 64‑bit remainder operator ( x % s = t ) under a mask constraint, by asserting that the condition (IC) is equivalent to the concrete existence of a value satisfying the mask and the remainder equation. It features deep term nesting (up to depth 67) with extensive chains of bit‑extractions and ite‑expressions (e.g., for ctz/clz), and contains quantified sub‑formulas (existential y and x) but no alternations. The instance originates from the FMCAD 2020 paper on bit‑precise reasoning and is intended to stress solvers’ handling of large bit‑vector terms and overflow‑detecting predicates.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvsge_s_x_4.smt2",
    "description": "This instance encodes a crafted bit‑vector verification task that checks an invertibility condition for the signed‑greater‑or‑equal operator (`bvsge`). It asserts that a predicate (IC) relating a signed value `s*` to interval bounds `xlo`, `xhi` is equivalent to the existence of some 4‑bit value `x` that both respects the mask‑covering constraints (`mcb`) and satisfies `s* ≥_s x`. The formula involves a single existential quantifier, several small helper functions (trailing/leading zero counts, parity, constants) and operates over 4‑bit vectors, yielding a modest term depth (7) but enough Boolean/bit‑vector interplay to challenge solvers on invertibility‑condition reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvmul_x_s_64.smt2",
    "description": "This crafted BV‑64 instance checks the correctness of an invertibility condition for the multiplication operator: it asserts that the predicate “s has a modular inverse (or a shifted inverse when even) that maps t into the interval defined by the masks xlo/xhi” is distinct from the direct existence of a value x within the same interval satisfying s·x = t.  The model includes explicit definitions of count‑trailing‑zeros and count‑leading‑zeros via deep nested ite and extract expressions, a mask‑containment predicate, and several existential quantifiers, yielding a term depth of 67 and many Boolean connectives.  The problem originates from the FMCAD‑2020 study on ternary‑propagation‑based local search for bit‑precise reasoning and is intended to stress solvers with heavy bit‑vector arithmetic, large numbers of extracts, and quantified reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvshl_s_x_64.smt2",
    "description": "This instance encodes a verification condition for the invertibility of the 64‑bit left‑shift operator (`bvshl`). It asserts that the handcrafted invertibility predicate IC (relating the shift amount, the source, and bounds xlo/xhi) is **not** equivalent to the existence of a concrete shift amount x that both satisfies the range constraints (`mcb`) and makes the shift equation `s << x = t` true, while also requiring a valid bit‑mask relationship between xlo and xhi. The formula is quantifier‑free except for a single existential, but uses very deep nested ite‑chains to define `ctz`/`clz`, leading to high term depth (≈ 67) and a challenging bit‑vector reasoning task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvudiv_s_x_4.smt2",
    "description": "The benchmark verifies an invertibility condition for unsigned bit‑vector division on 4‑bit values: it asserts that a derived condition (IC) on the dividend `s`, divisor `t`, and interval bounds `xlo`/`xhi` is equivalent to the existence of a concrete divisor `x` (satisfying a mask constraint) such that `s / x = t`. The file contains auxiliary definitions (trailing/leading‑zero counts, overflow predicates, and a mask‑constraint helper) and a single quantifier‑free assertion about the validity of the bounds, together with a quantified assertion checking the distinctness of the IC predicate from the existential witness. It is a crafted verification instance with a small number of 4‑bit variables but includes nested `ite`s, bit‑vector division, and an existential quantifier, making the equivalence check non‑trivial for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvmul_x_s_4.smt2",
    "description": "The benchmark encodes a **verification of an invertibility condition for 4‑bit multiplication**.  It defines utility functions (count‑trailing‑zeros, count‑leading‑zeros, mask‑containment) and a predicate IC that characterises when a modular inverse of a multiplier exists and can be used to solve \\(s·x = t\\) within a given interval \\([x_{\\text{lo}},x_{\\text{hi}}]\\).  The instance asserts that this IC predicate must be equivalent to the concrete existence of an \\(x\\) satisfying the equation under the same interval bounds, and asks the solver to find a model where the two differ (i.e., a counterexample).  Although only four 4‑bit constants are declared, the problem involves nested ite‑expressions, bit‑extractions, and three existential quantifiers, making it a crafted BV benchmark that tests quantifier handling and bit‑level reasoning.",
    "is_truncated": false
  }
]